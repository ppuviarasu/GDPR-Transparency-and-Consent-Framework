var APNVideo_MobileVastPlayer =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Standalone VAST Video Player for Mobile SDK integrations
	 * @module MobileVastPlayer
	 */

	var _players = [];

	function getPlayerByTargetElementForPlaying(elemId, cacheMode) {
	    if (!elemId) {
	        return null;
	    }
	    for (var i = 0; i < _players.length; i++) {
	        if (_players[i].id === elemId) {
	            if (cacheMode) {
	                if (_players[i].cachePlayer) {
	                    _players[i].player = _players[i].cachePlayer;
	                    delete _players[i].cachePlayer;
	                }
	            }
	            return _players[i].player;
	        }
	    }
	    return null;
	}

	function getPlayerByTargetElement(elemId, cacheMode) {
	    if (!elemId) {
	        return null;
	    }
	    for (var i = 0; i < _players.length; i++) {
	        if (_players[i].id === elemId) {
	            if (cacheMode) {
	                if (_players[i].cachePlayer) {
	                    return _players[i].cachePlayer;
	                }
	                else {
	                    return null;
	                }
	            }
	            return _players[i].player;
	        }
	    }
	    return null;
	}

	function getNewPlayerByTargetElement(elemId, cacheMode) {
	    if (!elemId) {
	        return null;
	    }
	    var player = null;
	    for (var i = 0; i < _players.length; i++) {
	        if (_players[i].id === elemId) {
	            if (cacheMode) {
	                if (_players[i].cachePlayer) {
	                    return null;
	                    //return _players[i].cachePlayer;
	                }
	                player = new VastPlayer();
	                _players[i].cachePlayer = player;
	                return player;
	            }
	            if (_players[i].player) {
	                _players[i].player.stop();
	                //_players[i].player.removeFromPage();
	            }
	            _players.splice(i, 1);
	            break;
	        }
	    }
	    player = new VastPlayer();
	    if (cacheMode) {
	        _players.push({id: elemId, cachePlayer: player});
	    }
	    else {
	        _players.push({id: elemId, player: player});
	    }
	    return player;
	}

	var PlayerDefaultOption = __webpack_require__(1);

	var APN_VideoPlayerManager = __webpack_require__(2);
	var APNVideo_AdHandler = __webpack_require__(52);

	var VastPlayer = function () {
	    function debug(message) {
	        var logger = __webpack_require__(23);
	        logger.setDebugLevel(logger.TRACE_LEVEL_VERBOSE);
	        logger.logDebug(message, 'Vast Video Player');
	    }

	    debug('VERSION 1.4.15');

	    var options = {};
	    var targetElement;
	    var targetDivContainer;
	    var cbAdunits = {};

	    var APN_VideoPlayerManager_obj;
	    //var APNVideo_AdHandler_obj;

	    var startTimeout = null;
	    var isDoneForReady = false;
	    var timeToReady = 3000;
	    var notificationCallback = null;
	    var autoMode = false;
	    var bTerminated = false;
	    var nextPlayerData = null;
	    var isPlaying = false;
	    var vFramework = null;

	    var needStartPlay = false;
	    var cacheZindex = 0;
	    //var isPlayingVideo = false;
	    //var hasFocus = false;

	    var dtStartPlayer;

	    /*var isAndroid = function () {
	        return (/android/i.test(navigator.userAgent.toLowerCase()));
	    };*/

	    //Changes made by mobile team to send callback for quartile trackers fired
	    var cbWhenQuartile = function (quartileFired) {
	        debug('VastPlayer > cbWhenQuartile ' + quartileFired);
	        notificationCallback(quartileFired, {});
	    };

	    //core video event to get all events from AdHandler
	    var cbCoreVideoEvent = function (eventType, eventName) {
	        /**
	         * eventType
	         *
	         * AdUnit: event exposed by video.js
	         * VPAID: event exposed by vpaid container
	         * AdHandler: event exposed by AdHandler
	         */
	        var nativeParams = {
	            type: eventType,
	            name: eventName
	        };

	        //event list that this player wants to dispatch
	        /**
	         * summary of type
	         *
	         * AdHandler: event from AdHandler where the callback notification(cbTerminate, cbRedner, ...etc) invokes
	         * AdUnit: event from Core player UI
	         * VPAID: event from VPAID containter
	         * VAST: event from Core player analysis module especiall VAST
	         */
	        var allowedEvents = [
	            {
	                type: "AdHandler",
	                name: "video_start",
	                mappedEventName: "videoStart"
	            },
	            {
	                type: "AdHandler",
	                name: "rewind",
	                mappedEventName: "videoRewind"
	            },

	            //Send notification of fullscreen enter and exit to HTML5 player.  2/9/2018, Mobile Engineering.
	            {
	                type: "AdHandler",
	                name: "video_fullscreen_enter",
	                mappedEventName: "video-fullscreen-enter"
	            },
	            {
	                type: "AdHandler",
	                name: "video_fullscreen_exit",
	                mappedEventName: "video-fullscreen-exit"
	            },

	            // {
	            //     type: "VPAID",
	            //     name: "AdSizeChange",
	            //     mappedEventName: "VPAID.AdSizeChange"
	            // },
	            // {
	            //     type: "VAST",
	            //     name: "impression",
	            //     mappedEventName: "VAST.impression"
	            // },
	            // {
	            //     type: "AdUnit",
	            //     name: "volume-change",
	            //     mappedEventName: "AdUnit.volume-change"
	            // },
	        ];

	        for (var idx = 0; idx < allowedEvents.length; idx++) {
	            tok = allowedEvents[idx];
	            if (tok.type === nativeParams.type && tok.name === nativeParams.name) {
	                notificationCallback(tok.mappedEventName, {});
	            }
	        }

	    };

	    var cbWhenVideoComplete = function (eventName) {
	        debug('VastPlayer > cbWhenVideoComplete ' + eventName);
	        notificationCallback(eventName, {});

	    };
	    var cbWhenSkipped = function (eventName) {
	        // do what you need to do with the skip event
	        debug('VastPlayer > cbWhenSkipped ' + eventName);
	        notificationCallback(eventName, {});
	    };

	    var cbWhenAudio = function (eventName) {
	        debug('VastPlayer > cbWhenAudio ' + eventName);
	        notificationCallback(eventName, {});
	    };
	    //End of changes
	    var cbWhenClickOpenUrl = function (dataObj) {
	        notificationCallback(dataObj, {});
	    };

	    var cbWhenFullScreen = function (eventName) {
	        debug('VastPlayer > cbWhenFullScreen ' + eventName);
	        notificationCallback(eventName, {});
	    };

	    var cbTerminate = function (isError, keepFullscreen, ignoreToPlay) {

	        debug('VastPlayer > cbTerminate isError: ' + isError);
	        var targetId = 'unknown';
	        if (targetElement) {
	            targetId = targetElement.id.toString();
	        }
	        debug('VastPlayer > cbTerminate:  bTerminated = ' + bTerminated + ', targetElement id = ' + targetId);
	        isPlaying = false;
	        if (!bTerminated) {
	            bTerminated = true;
	            /*if (triggerCheckFocus) {
	                clearInterval(triggerCheckFocus);
	            }*/
	            if (!keepFullscreen) {
	                // exit full-screen first if it's html5 and the ad was running at fullscreen before click skip. it will be better to add some condition to do following
	                exitFullscreen();
	            }
	            if (!ignoreToPlay && isFullscreenRunning() && options.overlayPlayer) {
	                exitFullscreen();
	            }
	            if (targetElement) {
	                if (vFramework) {
	                    //vFramework.isPlayingVideo = true;	// force to pause
	                    if (vFramework.isPlayingVideo) {
	                        debug('VastPlayer > cbTerminate: pause ad');
	                        vFramework.pause();
	                    }
	                    targetElement.style.height = '1px';
	                    vFramework.resizePlayer(1, 1);
	                }
	                setTimeout(function () {
	                    if (targetElement) {
	                        targetElement.innerHTML = '';
	                        targetDivContainer.removeChild(targetElement);
	                    }
	                    targetElement = null;
	                }, 2000);
	            }
	            if (notificationCallback) {
	                if (isError) {
	                    //The error messages thrown from the parser is different in differnt places. hence throw a consistent error when the
	                    //video player fails
	                    notificationCallback("video-error", {});
	                }
	            }
	        }
	    };

	    /*function documentHasFocus(doc) {
	        if (doc.hasFocus()) {
	            return true;
	        }
	        if (!doc.defaultView || !doc.defaultView.parent || doc == doc.defaultView.parent.document) {
	            return false;
	        }
	        return documentHasFocus(doc.defaultView.parent.document);
	    }*/

	    var exitFullscreen = function () {
	        if (document.exitFullscreen) {
	            document.exitFullscreen();
	        } else if (document.webkitExitFullscreen) {
	            document.webkitExitFullscreen();
	        } else if (document.mozCancelFullScreen) {
	            document.mozCancelFullScreen();
	        } else if (document.msExitFullscreen) {
	            document.msExitFullscreen();
	        }
	    };

	    var cbWhenReady = function (VideoFramework) {

	        var creativeUrl;
	        var duration;
	        var finalVastXml;
	        var finalVastUri;

	        creativeUrl = (VideoFramework && VideoFramework.options && VideoFramework.options.video && VideoFramework.options.video.url) ? VideoFramework.options.video.url : "";
	        duration = (VideoFramework && VideoFramework.options && VideoFramework.options.data && VideoFramework.options.data.vastDurationMsec) ? VideoFramework.options.data.vastDurationMsec : 0;
	        finalVastXml = (VideoFramework && VideoFramework.options && VideoFramework.options.finalVastXml) ? VideoFramework.options.finalVastXml : "";
	        finalVastUri = (VideoFramework && VideoFramework.options && VideoFramework.options.finalVastUri) ? VideoFramework.options.finalVastUri : "";

	        if (bTerminated) {
	            return;
	        }
	        isDoneForReady = true;
	        vFramework = VideoFramework;
	        debug('VastPlayer > cbWhenReady in ' + ((new Date()).getTime() - dtStartPlayer) + " msecs");
	        if (notificationCallback) {
	            //creative url from vast parser
	            //duration from vast parser and it's msec
	            notificationCallback(
	                'adReady',
	                {
	                    'creativeUrl': creativeUrl,
	                    'duration': duration,
	                    'vastXML': finalVastXml,
	                    'vastCreativeUrl': finalVastUri
	                }
	            );
	        }
	        if (options.initialPlayback !== 'click' && !options.cachePlayer) {
	            if (isFullscreenRunning() && options.overlayPlayer) {
	                if (options.forceAdInFullscreen) {
	                    needStartPlay = true;
	                    exitFullscreen();
	                }
	                else {
	                    if (targetElement) {
	                        targetElement.style.width = '1px';
	                        targetElement.style.height = '1px';
	                    }
	                    cbTerminate(false, true, true);
	                }
	            }
	            else {
	                vFramework.play();
	            }
	        }

	        /*hasFocus = document.hasFocus();
	        triggerCheckFocus = setInterval(function () {
	            if (!bTerminated && vFramework) {
	                if (documentHasFocus(document) && hasFocus === false) {
	                    if (isPlayingVideo) {
	                        vFramework.play();
	                    }
	                    hasFocus = true;
	                }
	                else if (!documentHasFocus(document) && hasFocus === true) {
	                    isPlayingVideo = vFramework.isPlayingVideo;
	                    vFramework.pause();
	                    hasFocus = false;
	                }
	            }
	        }, 500);*/
	    };

	    //build player
	    function fnBuildVideoPlayer(options) {


	        options.cbNotification = function (eventType, eventName) {
	            cbCoreVideoEvent(eventType, eventName);
	        };

	        debug('Build Ad Player Callback');
	        if (bTerminated) {
	            return;
	        }
	        if (autoMode) {
	            if (!nextPlayerData) {
	                if (isPlaying) {
	                    nextPlayerData = {
	                        options: options,
	                        callbacks: cbAdunits
	                    };
	                    notificationCallback(targetElement, {});
	                } else {
	                    options = APN_VideoPlayerManager_obj.init(options);
	                    APN_VideoPlayerManager_obj.buildPlayer(cbAdunits, options);
	                    isPlaying = true;
	                }
	            } else {
	                nextPlayerData.options = APN_VideoPlayerManager_obj.init(nextPlayerData.options);
	                APN_VideoPlayerManager_obj.buildPlayer(nextPlayerData.callbacks, nextPlayerData.options);
	                nextPlayerData = {
	                    options: options,
	                    callbacks: cbAdunits
	                };
	            }
	        } else {
	            nextPlayerData = null;
	            //build player
	            debug('Building single player');
	            options = APN_VideoPlayerManager_obj.init(options);
	            APN_VideoPlayerManager_obj.buildPlayer(cbAdunits, options);
	        }
	    }

	    function clearState() {
	        options = {};
	        targetElement = null;
	        targetDivContainer = null;
	        cbAdunits = {};

	        APN_VideoPlayerManager_obj = Object.create(APN_VideoPlayerManager);

	        if (startTimeout) {
	            clearTimeout(startTimeout);
	        }
	        startTimeout = null;
	        isDoneForReady = false;
	        timeToReady = 3000;
	        notificationCallback = null;
	        autoMode = false;
	        bTerminated = false;
	        nextPlayerData = null;
	        isPlaying = false;

	        dtStartPlayer = null;
	    }

	    function isFullscreenRunning() {
	        return document.fullscreenElement || document.webkitFullscreenElement ||
	            document.mozFullScreenElement || document.msFullscreenElement;
	    }

	    function repositionPlayer() {
	        debug('repositionPlayer: try reposion/resize overlay player');
	        if (options.cachePlayer || bTerminated) {
	            debug('repositionPlayer: never reposition terminated or cache palyer');
	            return;
	        }
	        var width;
	        var height;
	        if (isFullscreenRunning()) {
	            return;
	        }
	        else {
	            width = targetDivContainer.offsetWidth;
	            height = targetDivContainer.offsetHeight;
	            var brdWidth = targetDivContainer.style.borderWidth;
	            if (brdWidth && brdWidth.length > 0) {
	                var nBorder = Number(brdWidth.substring(0, brdWidth.length - 2));
	                width -= (2 * nBorder);
	                height -= (2 * nBorder);
	            }
	            targetElement.style.width = width + "px";
	            targetElement.style.height = height + "px";

	            var pos = getAbsoluteOffsetFromBody(targetDivContainer);
	            debug('repositionPlayer: targetDiv absolute posiotion =' + pos.left + ', ' + pos.top);
	            targetElement.style.left = pos.left + "px";
	            targetElement.style.top = pos.top + "px";
	            debug('repositionPlayer: size =  ' + width + ', ' + height);
	        }

	        if (options.overlayPlayer) {
	            vFramework.resizePlayer(width, height);
	        }
	        else {
	            vFramework.resizeVideo(null, false, null);
	        }
	    }

	    /*function fullscreenHandler() {
	        debug('Fullscreen event recieved');
	        if (targetElement && vFramework) {
	            repositionPlayer();
	        }
	    }*/

	    var origResizeBodyHandler = null;

	    function playerResizeHandler(ev) {
	        debug('Resize event happend');
	        if (targetElement && vFramework) {
	            if (needStartPlay) {
	                needStartPlay = false;
	                // put player on top of conainer elements
	                //Changes for Resize player to fit in container
	                if (options.fitInContainer) {
	                    targetElement.style.zIndex = cacheZindex;
	                }
	                //end
	                setTimeout(function () {
	                    repositionPlayer();
	                    if (options.initialPlayback !== 'click') {
	                        vFramework.play();
	                    }
	                }, 100);
	            }
	            else {
	                repositionPlayer();
	            }
	        }
	        if (origResizeBodyHandler) {
	            origResizeBodyHandler(ev);
	        }
	    }

	    //document.addEventListener('fullscreenchange', fullscreenHandler);
	    //document.addEventListener('webkitfullscreenchange', fullscreenHandler);
	    //document.addEventListener('mozfullscreenchange', fullscreenHandler);
	    //document.addEventListener('MSFullscreenChange', fullscreenHandler);

	    if (document.body.onresize) {
	        origResizeBodyHandler = document.body.onresize;
	    }
	    window.onresize = playerResizeHandler;

	    function playerNotification(notifName) {

	        debug('Got notification: ' + notifName);
	        switch (notifName) {
	            case 'leaveFullscreen':
	                exitFullscreen();
	                break;
	            default:
	                debug('Unknown player notification: ' + notifName);
	                break;
	        }
	    }

	    function getAbsoluteOffsetFromBody(el) {
	        var x = 0;
	        var y = 0;
	        while (el && (el.tagName !== 'BODY') && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
	            //if (el.style.position !== '' && el.style.position !== 'static') {
	            var pos = document.defaultView.getComputedStyle(el, null).position;
	            if (pos && pos !== '' && pos !== 'static') {
	                break;
	            }
	            x += (el.offsetLeft - el.scrollLeft + el.clientLeft);
	            y += (el.offsetTop - el.scrollTop + el.clientTop);
	            el = el.offsetParent;
	        }
	        return {left: x, top: y};
	    }

	    function isIosInlineRequired() {

	        /**
	         * get iOSversion as array [major,minor,build] if it's not proper mobile safari it will returen [0,0,0]
	         * @returns {*}
	         */
	        var iOSversion = function () {
	            try {

	                var platform = navigator.platform;
	                var agent = navigator.userAgent;
	                var appVersion = navigator.appVersion;
	                if (/iP(hone|od|ad)/.test(platform) && !(/CriOS/.test(agent))) {//Chrome browser doesn't regard as iOS
	                    var v = (appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/);
	                    return [parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)];
	                } else {
	                    return [0, 0, 0];//return this value when it's not iOS and Mobile Safari browser
	                }
	            } catch (ex) {
	                return [0, 0, 0];//return [0,0,0] if any error happens;
	            }

	        };

	        var result;
	        try {
	            result = (iOSversion()[0] >= 8 && options.enableInlineVideoForIos === true);
	        } catch (ex) {
	            debug(ex);
	        }
	        return result;
	    }

	    function getElementZindex(elem) {
	        var zIndex = document.defaultView.getComputedStyle(elem, null).zIndex;
	        if (zIndex !== 'auto') {
	            return zIndex;
	        }
	        return 0;
	    }

	    function getMaxZindexForChildren(parent, curZindex) {
	        if (!parent.children) {
	            return curZindex;
	        }
	        var zorder = Math.max(curZindex, getElementZindex(parent));
	        for (var i = 0; i < parent.children.length; i++) {
	            var child = parent.children[i];
	            zorder = Math.max(zorder, getMaxZindexForChildren(child, zorder));
	        }
	        return zorder;
	    }

	    function isIPhone() {
	        var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
	        return isFlag;
	    }

	    function isIos() {
	        var isFlag = isIPhone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
	        return isFlag;
	    }

	    function isMobile() {
	        return navigator.appVersion.indexOf("Mobile") > -1 || navigator.appVersion.indexOf("Android") > -1;
	    }

	    function isChrome() {
	        return navigator.userAgent.indexOf("Chrome") > -1;
	    }

	    function chromeVersion() {
	        var nPos = navigator.appVersion.indexOf('Chrome/');
	        if (nPos >= 0) {
	            var temp = navigator.appVersion.substr(nPos + 7);
	            nPos = temp.indexOf('.');
	            if (nPos > 0) {
	                return Number(temp.substr(0, nPos));
	            }
	            else {
	                return 0;
	            }
	        }
	        else {
	            return 0;
	        }
	    }

	    function play(targetDiv, notifCallback, playlistMode) {
	        debug('play function called');
	        isDoneForReady = false;
	        timeToReady = 3000;
	        if (options.vpaidTimeout) {
	            timeToReady = options.vpaidTimeout;
	        }
	        notificationCallback = null;
	        autoMode = false;
	        bTerminated = false;
	        if (playlistMode) {
	            autoMode = playlistMode;
	        }
	        if (notifCallback) {
	            notificationCallback = function (event, params) {

	                //default values if params doesn't exist
	                params = (params) ? params : {};

	                var nativeParams = {
	                    "event": event,
	                    "params": params
	                };
	                notifCallback(nativeParams);
	            };
	        }

	        if (isIPhone()) {
	            //this option is required to decide if the fullscreen button is required to be displayed on the player or not. For pricecheck interstitial video which is always shown in fullscreen this is false & for MobileSDK its true
	            if (options.showFullScreenButton === true) {
	                options.allowFullscreen = true;
	            } else {
	                options.allowFullscreen = false;	// have no sence for native player
	            }
	        }

	        if (isIos()) {
	            options.enableInlineVideoForIos = false;
	        }

	        debug('options before PlayerDefaultOption: ', JSON.stringify(options));

	        //if optons doesn't have default variables overrides it
	        options = PlayerDefaultOption(options);
	        debug('options after PlayerDefaultOption: ', JSON.stringify(options));

	        options.width = targetDiv.offsetWidth;
	        options.height = targetDiv.offsetHeight;
	        var brdWidth = targetDiv.style.borderWidth;
	        if (brdWidth && brdWidth.length > 0) {
	            var nBorder = Number(brdWidth.substring(0, brdWidth.length - 2));
	            options.width -= (2 * nBorder);
	            options.height -= (2 * nBorder);
	        }
	        options.playerHeight = options.height;
	        if (isIosInlineRequired()) {
	            options.playerHeight -= 30;
	        }

	        if (isFullscreenRunning()) {
	            options.fullscreenMode = true;
	        }

	        debug('offsetWidth=' + targetDiv.offsetWidth + ', offsetHeight=' + targetDiv.offsetHeight + ', borderWidth=' + targetDiv.style.borderWidth);
	        var container = document.createElement('div');
	        //container.style.width = "100%";
	        //container.style.height = "100%";
	        container.style.width = options.width + "px";
	        //Changes for Resize player to fit in container
	        if (options.fitInContainer) {
	            container.style.height = options.height + "px";
	        } else {
	            if (options.cachePlayer && options.overlayPlayer) {
	                container.style.height = "1px";
	            }
	            else {
	                container.style.height = options.height + "px";
	            }
	        }
	        //end
	        container.style.backgroundColor = "black";
	        container.id = targetDiv.id + "_overlay_" + (new Date()).getTime();

	        var pos = getAbsoluteOffsetFromBody(targetDiv);
	        debug('targetDiv absolute posiotion =' + pos.left + ', ' + pos.top);
	        container.style.position = "absolute";
	        container.style.left = pos.left + "px";
	        container.style.top = pos.top + "px";
	        //Changes for Resize player to fit in container
	        if (options.fitInContainer) {
	            container.style.zIndex = Math.max(100, getMaxZindexForChildren(targetDiv, 0) + 1);
	        } else {
	            cacheZindex = Math.max(100, getMaxZindexForChildren(targetDiv, 0) + 1);
	            if (options.cachePlayer && options.overlayPlayer) {
	                container.style.zIndex = 0;
	            }
	            else {
	                container.style.zIndex = cacheZindex;
	            }
	        }
	        //end
	        targetDiv.appendChild(container);
	        debug('player container offsetLeft = ' + container.offsetLeft + ', offsetTop = ' + container.offsetTop);

	        targetElement = container;		//targetDiv;
	        targetDivContainer = targetDiv;

	        dtStartPlayer = (new Date()).getTime();
	        debug('timeToReady = ' + timeToReady + ", start time = " + dtStartPlayer);
	        startTimeout = setTimeout(function () {
	            if (!isDoneForReady) {
	                cbTerminate(false);
	                if (notificationCallback) {
	                    notificationCallback('Timed-out', {});
	                }
	            }
	        }, timeToReady);

	        var cbRenderVideo = function (cbAdunits, options) {
	            debug('VastPlayer > cbRenderVideo called');
	            //build player
	            try {
	                debug('VastPlayer > cbRenderVideo options: ', JSON.stringify(options));
	            }
	            catch (e) {
	            }
	            fnBuildVideoPlayer(options);
	        };


	        cbAdunits.cbRenderVideo = cbRenderVideo;
	        cbAdunits.cbWhenDestroy = cbTerminate;
	        cbAdunits.cbWhenReady = cbWhenReady;
	        cbAdunits.cbWhenQuartile = cbWhenQuartile;
	        cbAdunits.cbWhenVideoComplete = cbWhenVideoComplete;
	        cbAdunits.cbWhenSkipped = cbWhenSkipped;
	        cbAdunits.cbWhenFullScreen = cbWhenFullScreen;
	        cbAdunits.cbWhenAudio = cbWhenAudio;
	        cbAdunits.cbWhenClickOpenUrl = cbWhenClickOpenUrl;

	        cbAdunits.cbCoreVideoEvent = cbCoreVideoEvent;//all events from core player


	        options.playerNotification = playerNotification;

	        if (options.overlayPlayer) {
	            if (!options.hasOwnProperty('allowFullscreen')) {
	                options.allowFullscreen = false;
	            }
	        }

	        debug('VP >> before options.initialAudio = ' + options.initialAudio);
	        if (options.initialPlayback === 'auto' && options.initialAudio === 'on' &&
	            isMobile() && isChrome() && chromeVersion() >= 53) {
	            // (nhedley) This is commented out because on PriceCheck Android we want the initialAudio to always start on
	            //options.initialAudio = "off";
	            options.showMute = true;
	            options.showVolume = true;
	        }
	        debug('VP >> after options.initialAudio = ' + options.initialAudio);
	        APNVideo_AdHandler(targetElement, options, cbAdunits);
	    }

	    this.playVast = function (targetDiv, pageOptions, vastContent, notifCallback, playlistMode) {
	        debug('VP >> playVast function called playerId = ' + this.vastPlayerId);
	        cbTerminate(false, true);
	        clearState();
	        options = pageOptions;
	        options.vastXml = vastContent;
	        play(targetDiv, notifCallback, playlistMode);
	    };


	    this.playAdObject = function (targetDiv, pageOptions, adObj, notifCallback, playlistMode) {
	        debug('VP >> playAdObject function called playerId = ' + this.vastPlayerId + ", cache mode = " + pageOptions.cachePlayer);
	        cbTerminate(false, true);
	        clearState();
	        options = pageOptions;
	        if (typeof adObj === 'string') {
	            options.vastXml = adObj;
	        }
	        else {
	            options.useAdObj = true;
	            options.adObj = adObj;
	        }
	        play(targetDiv, notifCallback, playlistMode);
	    };

	    this.stop = function () {
	        if (startTimeout) {
	            clearTimeout(startTimeout);
	            startTimeout = null;
	        }
	        cbTerminate(false);
	    };

	    this.removeFromPage = function () {
	        if (startTimeout) {
	            clearTimeout(startTimeout);
	            startTimeout = null;
	        }
	        bTerminated = true;
	        if (targetElement) {
	            targetElement.innerHTML = '';
	            targetDivContainer.removeChild(targetElement);
	            targetElement = null;
	        }
	    };

	    this.play = function () {
	        debug('VP >> play function called playerId = ' + this.vastPlayerId);
	        if (vFramework) {
	            options.cachePlayer = false;
	            if (isFullscreenRunning() && options.overlayPlayer) {
	                if (options.forceAdInFullscreen) {
	                    needStartPlay = true;
	                    exitFullscreen();
	                }
	                else {
	                    cbTerminate(false, true, true);
	                }
	            }
	            else {
	                //Changes for Resize player to fit in container
	                // put player on top of conainer elements
	                if (targetElement && options.fitInContainer === false) {
	                    targetElement.style.zIndex = cacheZindex;
	                }
	                //end
	                repositionPlayer();
	                if (options.initialPlayback !== 'click') {
	                    vFramework.play();
	                }
	            }
	        }
	    };

	    this.sendPlay = function () {
	        debug('VP >> sendPlay function called playerID = ' + this.vastPlayerId);
	        if (vFramework && !vFramework.isPlayingVideo) {
	            vFramework.play();
	        }
	    };

	    this.sendPause = function () {
	        debug('VP >> sendPause function called playerID = ' + this.vastPlayerId);
	        if (vFramework && vFramework.isPlayingVideo) {
	            vFramework.pause();
	        }
	    };

	    this.handleFullscreen = function (bFullscreen) {
	        if (vFramework) {
	            if (bFullscreen) {
	                // go full-screen
	                if (targetDivContainer.requestFullscreen) {
	                    targetDivContainer.requestFullscreen();
	                } else if (targetDivContainer.webkitRequestFullscreen) {
	                    targetDivContainer.webkitRequestFullscreen();
	                } else if (targetDivContainer.mozRequestFullScreen) {
	                    targetDivContainer.mozRequestFullScreen();
	                } else if (targetDivContainer.msRequestFullscreen) {
	                    targetDivContainer.msRequestFullscreen();
	                }
	            }
	            else {
	                if (document.exitFullscreen) {
	                    document.exitFullscreen();
	                } else if (document.webkitExitFullscreen) {
	                    document.webkitExitFullscreen();
	                } else if (document.mozCancelFullScreen) {
	                    document.mozCancelFullScreen();
	                } else if (document.msExitFullscreen) {
	                    document.msExitFullscreen();
	                }
	            }
	        }
	    };

	    this.vastPlayerId = (new Date()).getTime();

	    this.isTerminated = function () {
	        return (bTerminated);
	    };

	    this.getIsVideoPlaying = function () {
	      var isPlaying = (vFramework && vFramework.isPlayingVideo) ? true : false;
	      return isPlaying;
	    };

	    this.getCurrentPlayHeadTime = function () {
	        var currentTime = 0;
	        //VIDLA-2260
	        if (APN_VideoPlayerManager_obj && APN_VideoPlayerManager_obj.adVideoPlayer && typeof(APN_VideoPlayerManager_obj.adVideoPlayer.player) === "function") {
	            currentTime = APN_VideoPlayerManager_obj.adVideoPlayer.player().currentTime() * 1000;//ms of playhead
	            currentTime = (parseInt && typeof(parseInt) === "function") ? parseInt(currentTime) : currentTime;
	        }
	        return currentTime;
	    };

	};


	module.exports = {

	    /** Entry point for playing ad object.
	     * @param {object} targetDiv - HTML element contains VAST player.
	     * @param {object} options - object contains option list for Ad Video Player.
	     * @param {string} adObj - object contains data for play ad or VAST xml.
	     * @param {function} notifCallback - notification callback function.
	     * @param {function} playlistMode - should be false (not supported yet).
	     */
	    playAdObject: function (targetDiv, options, adObj, notifCallback, playlistMode) {
	        var player = getNewPlayerByTargetElement(options.targetElementId, options.cachePlayer);
	        if (player) {
	            player.playAdObject(targetDiv, options, adObj, notifCallback, playlistMode);
	        }
	    },


	    /** Entry point for playing VAST xml.
	     * @param {object} targetDiv - HTML element contains VAST player.
	     * @param {object} options - object contains option list for Ad Video Player.
	     * @param {string} vastContent - VAST xml.
	     * @param {function} notifCallback - notification callback function.
	     * @param {function} playlistMode - should be false (not supported yet).
	     */
	    playVast: function (targetDiv, options, vastContent, notifCallback, playlistMode) {
	        var player = getNewPlayerByTargetElement(options.targetElementId);
	        if (player) {
	            player.playVast(targetDiv, options, vastContent, notifCallback, playlistMode);
	        }
	    },

	    /** Entry point for playing VAST xml pointed by url.
	     * @param {object} targetDiv - HTML element contains VAST player.
	     * @param {object} options - object contains option list for Ad Video Player.
	     * @param {string} vastUrl - VAST url.
	     * @param {function} errorCallback - error callback function.
	     */
	    loadAndPlayVast: function (targetDiv, options, vastUrl, notifCallback, playlistMode) {
	        var UrlLoader = __webpack_require__(24);
	        UrlLoader.load(vastUrl,
	            function (error, responseText) {
	                if (error || responseText.length === 0) {
	                    var logger = __webpack_require__(23);
	                    logger.logDebug('Failed to load ' + vastUrl, 'Vast Video Player');
	                } else {
	                    var player = getNewPlayerByTargetElement(options.targetElementId);
	                    if (player) {
	                        player.playVast(targetDiv, options, responseText, notifCallback, playlistMode);
	                    }
	                }
	            });
	    },

	    /** Entry point to stop playing VAST xml.
	     * @param {object} targetDiv - HTML element contains VAST player.
	     */
	    stop: function (targetDiv, cacheMode) {
	        var player = getPlayerByTargetElement(targetDiv.id, cacheMode);
	        if (player) {
	            player.stop();
	        }
	    },

	    /** Entry point to remove player from container.
	     * @param {object} elemId - player container HTML element id.
	     */
	    removeFromPage: function (elemId) {
	        var player = getPlayerByTargetElement(elemId);
	        if (player) {
	            player.removeFromPage();
	        }
	    },

	    /** Entry point to play waiting ad.
	     * @param {object} targetElementId - player container HTML element id.
	     */
	    play: function (targetElementId, cacheMode) {
	        var player = getPlayerByTargetElementForPlaying(targetElementId, cacheMode);
	        if (player) {
	            player.play();
	        }
	    },

	    sendPlay: function (targetElementId) {
	        var player = getPlayerByTargetElement(targetElementId);
	        if (player) {
	            player.sendPlay();
	        }
	    },

	    sendPause: function (targetElementId) {
	        var player = getPlayerByTargetElement(targetElementId);
	        if (player) {
	            player.sendPause();
	        }
	    },

	    /** Entry point to enter or cancel the fullscreen mode.
	     * @param {object} targetElementId - player container HTML element id.
	     * @param {boolean} bFullscreen - if true go to fullscreen, if false cancel fullscreen.
	     */
	    handleFullscreen: function (targetElementId, bFullscreen) {
	        var player = getPlayerByTargetElement(targetElementId);
	        if (player) {
	            player.handleFullscreen(bFullscreen);
	        }
	    },

	    /**
	     * get current time of the video
	     * @returns {number}
	     */
	    getCurrentPlayHeadTime: function (targetElementId) {
	        var player = getPlayerByTargetElement(targetElementId);
	        if (player) {
	            return player.getCurrentPlayHeadTime();
	        }
	    },

	    /**
	     * Get the current Playing state of Video.
	     * @returns {boolean} isPlaying - true if video is playing, false otherwise
	     */
	    getIsVideoPlaying: function (targetElementId) {
	        var player = getPlayerByTargetElement(targetElementId);
	        if (player) {
	            return player.getIsVideoPlaying();
	        }
	    }

	};
	/*
	console.log(">>>>>APNVideo_VideoPlayerLoader:", APNVideo_VideoPlayerLoader);
	//attempt to signal a waiting consumer that we have been loaded
	if(typeof APNVideo_VideoPlayerLoader !== 'undefined' && typeof APNVideo_VideoPlayerLoader.notifyPlayerLoaded === 'function' ){
	    APNVideo_VideoPlayerLoader.notifyPlayerLoaded();
	} */


/***/ }),
/* 1 */
/***/ (function(module, exports) {

	var PlayerDefaultOption = function (options_) {

	    //define default option can be override if it deosn't exists
	    var defaultOptions = {
	    	"autoInitialSize": false,
	        "initialPlayback": "click",
	        "initialAudio": "on",
	        "playOnMouseover": false,
	        "audioOnMouseover": false,
	        "skippable": {
	            "enabled": true,
	            "videoThreshold": 15,
	            "videoOffset": 5,
	            "skipLocation": "top-left",
	            "skipText": "Video can be skipped in %%TIME%% seconds",
	            "skipButtonText": "SKIP"
	        },
	        "adText": "Ad",
	        "showMute": true,
	        "showVolume": true,
	        "showProgressBar": true,
	        "allowFullscreen": false,
	        "topDividerColor": "0x606060",
	        "bottomDividerColor": "0x606060",
	        "topDividerWidth": 1,
	        "bottomDividerWidth": 1,
	        "enableInlineVideoForIos": true,
	        "flash": {"swf": "http://acdn.adnxs.com/video/static/player/flash/adplayer/1.1.16/AppnexusFlashPlayer.swf"},
	        "sideStream": {"enabled": false},
	        "forceAdInFullscreen": true,
	        "data": {
	            "skipOffset": "",
	            "durationMsec": null,
	            "skipOffsetMsec": null,
	            "isVastVideoSkippable": false,
	            "vastProgressEvent": {},
	            "vastDurationMsec": null,
	            "adIcons": null
	        }
	    };


	    function isObject(obj) {
	        return typeof obj === 'object';
	    }

	    function isNull(o) {
	        return o === null;
	    }

	    function extend(obj) {
	        var arg, i, k;
	        for (i = 1; i < arguments.length; i++) {
	            arg = arguments[i];
	            for (k in arg) {
	                if (arg.hasOwnProperty(k)) {
	                    if (isObject(obj[k]) && !isNull(obj[k]) && isObject(arg[k])) {
	                        obj[k] = extend({}, obj[k], arg[k]);
	                    } else {
	                        obj[k] = arg[k];
	                    }
	                }
	            }
	        }
	        return obj;
	    }

	    //extend by default options
	    var options = extend({}, defaultOptions, options_ || {});

	    //manual touch
	    if (options.playerTechnology === undefined || options.playerTechnology.length === 0) {
	        options.playerTechnology = ["html5", "flash"];
	    }

	    //this options should be false anytime.
	    options.enableExplicitPause = true;

	    if (options.skippable && options.skippable.enabled) {
	    	try {
		    	if (options.skippable.hasOwnProperty('skipText') && options.skippable.skipText.trim().length === 0 &&
		    		options.skippable.hasOwnProperty('skipButtonText') && options.skippable.skipButtonText.trim().length === 0) {
		    		options.skippable.enabled = false;
		    	}
	    	}
	    	catch(e) {}
	    }

	    return options;//TODO is Object.create required for this?

	};

	module.exports = PlayerDefaultOption;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Ad Video Player Manager module.
	 * @module AdVideoPlayerManager
	 */

	//define reference of required modules
	var VideoJSPlayer = __webpack_require__(3);
	var BuildPlayerObj = __webpack_require__(6);
	var JSVpaidPlayer = __webpack_require__(45);
	var ExtendDefaultOption = __webpack_require__(46);
	var VideoSizeHandler = __webpack_require__(44);
	var Utils = __webpack_require__(8);
	var DelayEventHandler = Utils.DelayEventHandler;
	var unique = Utils.unique();
	var CustomSkinning = __webpack_require__(47);
	var ViewabilityTracking = __webpack_require__(49);
	var AutoplayHandler = __webpack_require__(51);

	var CONST_MESSAGE_VIDEO_FAILED = "'video_failed' reported from Flash player";
	var UID = new Date().getTime() + Math.floor(Math.random() * 10000);
	var externalNameOfVideoPlayer = "APNVideo_Player_" + UID;


	var prefixOfLog = "[PlayerManager_Main]";
	var APN_Logger = __webpack_require__(9);
	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};
	var error = function (message) {
	    APN_Logger.error(prefixOfLog, message);
	};
	// var info = function (message) {
	//     APN_Logger.info(message, prefixOfLog);
	// };


	var isIE11 = function () {
	    var index = navigator.userAgent.indexOf("Trident/7.0");
	    return (index > -1);
	};

	//for VID-1551
	var EVENTS_HAVE_TO_FILTER_OUT = ["AdPaused", "AdVolumeChange"];

	var EVENTS_RESTRICTED_SUPPRESSING = [
	    "AdLoaded",
	    // "AdStarted", //need to disscuss with Vikki or Jeff but I'm assuming this also should suppressed because the startAd will be invoked by programmatically instead of human activity
	    "AdStopped",
	    "AdSkippableStateChange",
	    "AdLinearChange",
	    "AdDurationChange",
	    "AdRemainingTimeChange",
	    "AdLog",
	    "AdError"
	];

	var ERROR_TYPE_VAST = 1;//vast-error (one of the error codes specified in the VAST spec)
	var VAST_ERROR_TIMEOUT = 402;
	var VAST_ERROR_UNDEFINED = 900;
	var VAST_ERROR_VIDEOFAILED = 405;


	/*
	 apply Vikki and Eugene's following opinion
	 We proposed to change initialPlayback to auto, initialAudio to off. Add the following options: vpaidTimeout : 5000, waterfallTimeout : 30000, waterfallSteps : -1
	 */
	//define default option for playerManager which can be overrided if it deosn't exists
	var DEFAILT_OPTIONS_FOR_PLAYER_MANAGER = {
	    "initialPlayback": "auto",
	    "initialAudio": "off",
	    "skippable": {
	        "enabled": true,
	        "allowOverride": false,
	        "videoThreshold": 15,
	        "videoOffset": 5,
	        "skipLocation": "top-left",
	        "skipText": "Video can be skipped in %%TIME%% seconds",
	        "skipButtonText": "SKIP"
	    },
	    "adText": "Ad",
	    "showMute": true,
	    "showVolume": true,
	    "showProgressBar": true,
	    "showPlayToggle": true,
	    "showBigPlayButton": true,
	    "allowFullscreen": true,
	    "playerSkin": {
	        "customPlayerSkin": "",
	        "controlBarHeight": 30,
	        "topDividerColor": "#606060",
	        "bottomDividerColor": "#606060",
	        "topDividerWidth": 1,
	        "bottomDividerWidth": 1,
	        "videoBackgroundColor":"#000000"
	    },
	    "disableCollapse": {
	        "enabled": false,
	        "replay": false
	    },
	    "endCard": {
	        "enabled": false,
	        "clickable": true,
	        "color": "",
	        "imageUrl": "",
	        "imageWidth": "",
	        "imageHeight": "",
	        "showCompanion": true
	    },
	    "enableInlineVideoForIos": true,
	    "delayExpandUntilVPAIDInit": false,
	    "delayExpandUntilVPAIDImpression": false,
	    "flash": {"swf": "http://acdn.adnxs.com/video/player/vastPlayer/AppnexusFlashPlayer.swf"},
	    "vpaidTimeout": 5000,
	    "waterfallTimeout": 30000,
	    "waterfallSteps": -1,
	    "fixedSizePlayer": true,
	    "disableTopBar": false,
	    "sideStream": {
	        "enabled": false,
	        "position": "bottom-right",
	        "xOffset": 0,
	        "yOffset": 0,
	        "space": "empty",
	        "dynamicBigPlayButtonOnSideStream": true
	    },
	    "sideStreamObject": {},
	    "preloadInlineAudioForIos": false,
	    "controlBarPosition": "over",
	    "customPlayerSkinCss": "",
	    "customButton": {
	        "enabled": false,
	        "url": "",
	        "altText": "",
	        "imageSrc": "",
	        "imgWidth": 50,
	        "imgHeight": 30
	    },
	    "enableNativeInline": false,
	    "androidDSOverride": false,
	    "cbNotification": function () {
	    },
	    "parentIframeIsModal": false,
	    "learnMore": {
	        "enabled": false,
	        "clickToPause": true,
	        "text": "Learn More",
	        "separator": "-"
	    },
	    "playerContextId": "anadvideoplayer",
	    "data": {
	        "skipOffset": "",
	        "durationMsec": null,
	        "skipOffsetMsec": null,
	        "isVastVideoSkippable": false,
	        "vastProgressEvent": {},
	        "vastDurationMsec": null,
	        "adIcons": null
	    },
	    "test": function () {
	    }
	};


	/**
	 * adVideoPlayerManager function
	 * @type {{externalNameOfVideoPlayer: string, videoPlayerObj, options: {}, adVideoPlayer: {}, callbackForAdUnit: {}, vpaidData: {}, iframeVideoWrapper: {}, isPlayingVideo: boolean, isDoneInitialPlay: boolean, isFullscreen: boolean, heightOffset: number, explicitPaused: boolean, aspectRatio: number, videoObjectId: {}, isViewable: boolean, isSkipped: boolean, isCompleted: boolean, isMuted: boolean, isExplicitMuted: boolean, isChrome: boolean, videojs_vpaid, overlayPlayer: boolean, forceToSkip: boolean, ExtendDefaultOption, delayEventHandler: null, pausedByViewability: boolean, init: adVideoPlayerManager.init, getValueFromPlayer: adVideoPlayerManager.getValueFromPlayer, isIosInlineRequired: adVideoPlayerManager.isIosInlineRequired, decidePlayer: adVideoPlayerManager.decidePlayer, buildPlayer: adVideoPlayerManager.buildPlayer, getPlayerStatus: adVideoPlayerManager.getPlayerStatus, notifyPlayer: adVideoPlayerManager.notifyPlayer, load: adVideoPlayerManager.load, play: adVideoPlayerManager.play, pause: adVideoPlayerManager.pause, explicitPause: adVideoPlayerManager.explicitPause, explicitPlay: adVideoPlayerManager.explicitPlay, mute: adVideoPlayerManager.mute, explicitMute: adVideoPlayerManager.explicitMute, unmute: adVideoPlayerManager.unmute, explicitUnmute: adVideoPlayerManager.explicitUnmute, mouseIn: adVideoPlayerManager.mouseIn, mouseOut: adVideoPlayerManager.mouseOut, destroy: adVideoPlayerManager.destroy, destroyWithoutSkip: adVideoPlayerManager.destroyWithoutSkip, getVideoObject: adVideoPlayerManager.getVideoObject, handlePlayerNotification: adVideoPlayerManager.handlePlayerNotification, handleOverlayNotification: adVideoPlayerManager.handleOverlayNotification, notifyVpaidEvent: adVideoPlayerManager.notifyVpaidEvent, notifyVpaidEvent_internal: adVideoPlayerManager.notifyVpaidEvent_internal, setChromeSize: adVideoPlayerManager.setChromeSize, click: adVideoPlayerManager.click, getRapamsAndExtensions: adVideoPlayerManager.getRapamsAndExtensions, dispatchEventToAdunit: adVideoPlayerManager.dispatchEventToAdunit, dispatchEventToAdunit_internal: adVideoPlayerManager.dispatchEventToAdunit_internal, resizeVideo: adVideoPlayerManager.resizeVideo, isIosInlineRequired: adVideoPlayerManager.isIosInlineRequired, resizePlayer: adVideoPlayerManager.resizePlayer, getFinalSize: adVideoPlayerManager.getFinalSize, log: log, debug: debug}}
	 */
	var adVideoPlayerManager = {

	    //binding objects for sub module
	    externalNameOfVideoPlayer: externalNameOfVideoPlayer,
	    videoPlayerObj: VideoJSPlayer,
	    autoplayHandler: AutoplayHandler,
	    mobileSupport: AutoplayHandler,//added for providing backward compatibility
	    customSkinning: CustomSkinning,
	    options: {},
	    adVideoPlayer: {},
	    callbackForAdUnit: {},//callback in adunit
	    vpaidData: {},
	    iframeVideoWrapper: {},
	    isPlayingVideo: false,
	    isDoneInitialPlay: false,
	    isFullscreen: false,
	    heightOffset: 0,
	    explicitPaused: false,
	    aspectRatio: 0,
	    videoObjectId: {},
	    isViewable: false,
	    isSkipped: false,
	    isCompleted: false,
	    isMuted: false,
	    isExplicitMuted: false,
	    hasBeenUnmuted: false,
	    isChrome: (navigator.userAgent.indexOf("Chrome") > -1),
	    videojs_vpaid: JSVpaidPlayer,
	    overlayPlayer: false,
	    forceToSkip: false,
	    ExtendDefaultOption: ExtendDefaultOption,
	    delayEventHandler: null,
	    pausedByViewability: false,
	    mutedByVisibility: false,
	    gotAdImpressionForFlash: false,
	    gotAdStartedForFlash: false,
	    isReadyToExpandForMobile: false,
	    isAlreadyPlaingForVPAID: false,
	    isSideStreamActivated: false,//this will be set after options.sideStream maxPageOverlay processed by its own logic
	    isExpanded: true,//this is final status of Outstream when it got expanded, also it doesn't need to be false here because other ad-units will always have shown up video other than Outstream
	    isVideoCompleteInjected: false,
	    isFullscreenToggled: false,//for VID-2558 VID-2554 Safari, Chrome browsers response lately from fullscreen change event so additional flag isFullscreenToggled will cover the situation
	    toggleWindowFocus: true,//toggle flag to know whether current window has a focus or not
	    viewabilityTracking: null,
	    isDoneFirstLoadStart: false,
	    flashBlockerTimeout: null,
	    startedReplay: false,
	    Utils: Utils,
	    isAlreadyStart: false,
	    isEnded: false,
	    blockTrackingUserActivity: false,
	    videoId: "",
	    divIdForVideo: "",


	    /**
	     * a start point for initializing playerManager
	     * @param _options
	     */
	    init: function (_options) {
	        var extendedOptions = ExtendDefaultOption(DEFAILT_OPTIONS_FOR_PLAYER_MANAGER, _options);//if optons doesn't have default variables for playerManager level, overrides it
	        this.options = extendedOptions;//TODO minthe : it will be better not to set at this time but remain this until code has more stable & clear state.

	        //VIDLA-1398
	        // VIDLA-1449 (Control bar has to position below ad for Overlay Player on mobile. Overlay player always uses native player.)
	        if (this.options.controlBarPosition === "below" && AutoplayHandler.isIOS() && this.options.enableInlineVideoForIos && !this.options.enableNativeInline) {
	            this.options.controlBarPosition = "over";
	        }

	        if (typeof this.options.disableCollapse === "boolean") {
	            this.options.disableCollapse = {"enabled": this.options.disableCollapse, "replay": false};
	        }

	        //if VAST3 override skippable option, it should also override enabled and videoThreshold to 0
	        if (this.options.skippable.allowOverride === true) {//fix VIDLA-525
	            this.options.skippable.videoThreshold = 0;
	            this.options.skippable.enabled = true;
	        }

	        this.delayEventHandler = new DelayEventHandler();//make instance of delay event handling
	        //set event delay handler
	        this.delayEventHandler.suppress(this.options.delayExpandUntilVPAIDImpression);
	        this.delayEventHandler.start();

	        //activate appnexus viewability
	        this.viewabilityTracking = new ViewabilityTracking();

	        return extendedOptions;
	    },

	    getValueFromPlayer: function (param) {

	        //this is just for iOS inline video, height of toolbar which will be added to video area. this is required to show whole area of video with controlbar
	        var result = 0;
	        try {
	            if (param === "controlBar.height") {
	                if (this.adVideoPlayer && this.adVideoPlayer.controlBar && this.adVideoPlayer.controlBar.height && typeof this.adVideoPlayer.controlBar.height === "function" && this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	                    result = this.adVideoPlayer.controlBar.height();
	                }
	            }
	        } catch (ex) {
	            error(ex);
	        }

	        return result;
	    },

	    /**
	     * return decision what to use for player
	     * @returns {string}
	     */
	    decidePlayer: function (arrTech) {

	        /*
	         parameter arrTech will have a result from rendition manager as this.options.requiredPlayer
	         Expected requiredPlayer from Rendition manager is :
	         0 - any,
	         1 - html5,
	         2 - flash
	         this result will be decided by Rendition Manager Module with VAST XML
	         */

	        /*
	         summary of result from rendition manager
	         rendition manager returns 0 when it doesn't find any specific playable format for each of technology between html5 and flash
	         if the "type" attribute of "<MediaFile>" element of vast XML has...
	         'video/x-flv', 'video/x-f4v','video/f4v', 'application/x-shockwave-flash' then rendition manager will return flash
	         'video/webm','video/ogg','application/javascript','application/x-javascript' then rendition manager will return html5
	         all the other case rendition manager will return 0
	         */

	        /*
	         special cases verified with Eugene
	         VPAID ad is always favorable by Rendition Manager so if VAST tag has VPAID creative, Rendtional Manager will try to choose VPAID one
	         and If VAST has both JSVPAID and FLASH-VPAID the selection will be depending on playerTechnology
	         */

	        var result = "";
	        var TECH_FLASH = "flash";
	        var TECH_HTML5 = "html5";

	        var isMobile = function () {
	            var index = navigator.appVersion.indexOf("Mobile");
	            var indexForAndroid = navigator.appVersion.indexOf("Android");
	            return (index > -1) || (indexForAndroid > -1);
	        };


	        //fix VID-1069
	        var playerTechnology = this.options.playerTechnology;//possible scenario : ["flash"], ["html5"], ["html5","flash"], ["flash","html5"]


	        //if playerTechnology is either of html5 and flash
	        if (playerTechnology && playerTechnology.length && playerTechnology.length === 1) {
	            switch (arrTech) {
	                case 1:
	                    result = TECH_HTML5;
	                    break;
	                case 2:
	                    result = TECH_FLASH;
	                    break;
	                case 0:
	                    result = (playerTechnology[0] === TECH_HTML5) ? TECH_HTML5 : TECH_FLASH;
	                    break;
	            }
	        }

	        //if playerTechnology has both html5 and flash
	        if (playerTechnology && playerTechnology.length && playerTechnology.length === 2) {
	            switch (arrTech) {
	                case 1:
	                    result = TECH_HTML5;
	                    break;
	                case 2:
	                    result = TECH_FLASH;
	                    break;
	                case 0:
	                    //for VID-1069 (kyungsuk)
	                    //confirmed with Jeff Outstream will favor HTML5 for this case even through Flash was listed first
	                    //a case for (arrTech==0 and jsVpaid==true) won't be happend by Rendition manager. if there's the case, AdHandler will destroy framework with error. this is confirmed with Eugene
	                    result = TECH_HTML5;
	                    break;
	            }
	        }

	        if (isMobile()) {//if it's mobile this manager will always choose html5
	            result = TECH_HTML5;
	        }

	        return result;

	    },


	    /** Build Player.
	     @param {Object} options - Options used to construct video player.
	     @param {Object} eventHandlerCallback - Messages from player will be called on this function.
	     */
	    buildPlayer: function (_callbackForAdUnit, _options) {

	        var playerManagerSelf = this;

	        if (_options.waterfallStepId) {
	            debug("CHECKING AUTOPLAY FOR WATERFALL STEP: " + _options.waterfallStepId);
	        }

	        // VIDLA-2027 - for Overlay Player the autoplay validation already done in Vast Mediation Manager
	        if (this.decidePlayer(_options.requiredPlayer) === 'html5' && this.autoplayHandler && !_options.overlayPlayer) {


	            var callbackForAutoplayHandler = function (result) {
	                var policy = playerManagerSelf.autoplayHandler.videoPolicy;
	                switch (result) {
	                    case policy.allowAutoplay:
	                        //do nothing
	                        break;
	                    case policy.stopMediaWithSound:
	                        if (_options.initialAudio === "on") {
	                            if (_options.initialPlayback === "auto" || _options.initialPlayback === "mouseover") {
	                                _options.initialAudio = "off";
	                                _options.audioOnMouseover = false;
	                            }
	                            if (_options.isWaterfall === true) {
	                                if (_options.adAttempt > 0) {
	                                    _options.initialAudio = "off";
	                                    _options.audioOnMouseover = false;
	                                } else {
	                                    _options.audioOnMouseover = true;
	                                }
	                            }
	                        } else {
	                            if (_options.initialPlayback === "auto" || _options.initialPlayback === "mouseover") {
	                                _options.audioOnMouseover = false;
	                            }
	                        }
	                        break;
	                    case policy.neverAutoplay:
	                        _options.initialPlayback = "click";
	                        if (_options.isWaterfall) {
	                            _options.isWaterfall = false;
	                            _options.stopWaterfall = true;
	                        }
	                        break;
	                }
	                if (_options.waterfallStepId) {
	                    debug("BUILDING PLAYER FOR WATERFALL STEP: " + _options.waterfallStepId);
	                }
	                playerManagerSelf.buildPlayerCallback(_callbackForAdUnit, _options);
	            };

	            var checkAudioSupport = (_options.initialAudio === "on") ? true : false;

	            //get media policy
	            playerManagerSelf.autoplayHandler.getAutoplayPolicy(callbackForAutoplayHandler, checkAudioSupport);

	        } else {
	            //no need to test autoplay-able
	            playerManagerSelf.buildPlayerCallback(_callbackForAdUnit, _options);
	        }


	    },

	    buildPlayerCallback: function (_callbackForAdUnit, _options) {

	        //register options and callbackForAdUnit
	        //this.options = _options;//deprecated it will be done at init method
	        this.callbackForAdUnit = _callbackForAdUnit;
	        if (_options.hasOwnProperty('overlayPlayer')) {
	            this.overlayPlayer = _options.overlayPlayer;
	            if (_options.hasOwnProperty('fullscreenMode')) {
	                _options.allowFullscreen = false;
	            }
	        }

	        if (isIE11() && this.decidePlayer(this.options.requiredPlayer) === "flash") {
	            //do nothing for now
	        } else if (this.options.targetElement && !this.options.firstAdAttempted) {
	            this.options.targetElement.style.visibility = "hidden";
	        }
	        if (this.decidePlayer(this.options.requiredPlayer) === 'flash') {
	            this.options.disableCollapse.replay = false;
	        }

	        var UID = new Date().getTime() + Math.floor(Math.random() * 10000);
	        var externalNameOfVideoPlayer = "APNVideo_Player_" + UID;
	        this.externalNameOfVideoPlayer = externalNameOfVideoPlayer;

	        BuildPlayerObj(_callbackForAdUnit, _options, this);

	    },

	    /** Get current property state of player.
	     @param {String} propertyName - Property name to get.
	     @returns {Object} Value of requested propertyName
	     */
	    //getPlayerProperty: function (propertyName) {
	    //    return null;
	    //},

	    /** Get entire player status object.
	     @returns {Object} Representation of all player status values (playerState, audioState etc)
	     */
	    getPlayerStatus: function () {

	    },

	    /** Send notification to the player
	     @param {String} notifiactionName - notification name.
	     @param {Object} notifiactionValue - notification value.
	     */
	    notifyPlayer: function (notifiactionName, notifiactionValue) {
	        this.adVideoPlayer.handleAdUnitNotification({name: notifiactionName, value: notifiactionValue});
	    },

	    load: function () {

	        if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	            debug("load video");
	            try {
	                if (this.adVideoPlayer && this.adVideoPlayer !== undefined && this.adVideoPlayer.load && typeof this.adVideoPlayer.load === "function") {
	                    // VID-2517 Force the video tag to be in non autoplay state and autoplay is handled by explicitly by ad unit.
	                    if (this.options.delayExpandUntilVPAIDImpression && this.adVideoPlayer.player() && this.adVideoPlayer.player().autoplay()) {
	                        this.adVideoPlayer.player().autoplay(false);
	                    }
	                    this.adVideoPlayer.load();
	                }
	            } catch (ex) {
	                error(ex);
	            }

	        }
	    },

	    /**
	     * replay video
	     */
	    replay: function () {
	        if (this.isEnded) {
	            this.dispatchEventToAdunit({"name": "rewind"});
	            this.startedReplay = true;
	            this.isEnded = false;
	            this.explicitPlay();
	            if (this.adVideoPlayer.controlBar.playToggle && this.adVideoPlayer.controlBar.playToggle.el() && this.adVideoPlayer.controlBar.playToggle.el().style) {
	                this.adVideoPlayer.controlBar.playToggle.el().style["pointer-events"] = "";
	            }

	            // Restore sidestream support when ad replays
	            if (this.options.sideStream && this.options.sideStream.wasEnabled === true) {
	                this.options.sideStream.enabled = true;
	                delete this.options.sideStream.wasEnabled;
	            }

	            // If EndCard screen the replay button is not a videojs play button so we need to explicitly tell vjs to start playing.
	            if (this.options.endCard && this.options.endCard.enabled) {
	                //this.adVideoPlayer.play();
	                this.actualPlayByVideoJS();

	                // Seems like this shouldn't be necessary, but big play never shows up when paused if we don't show it here for some reason.
	                if (!Utils.isIos()) {
	                    this.adVideoPlayer.bigPlayButton.show();
	                }
	            }
	        }
	    },


	    //add additional steps for videojs.play()
	    actualPlayByVideoJS: function() {
	        this.adVideoPlayer.play();
	    },


	    /**
	     * play video
	     */
	    play: function () {

	        if (this.isEnded === true) {
	            return;
	        }

	        //remedy for fixing a bug on iOS10.1 - iOS10.1 has a bug to break a div which has overflow = "hidden" after entering fullscreen where their native video player.
	        var needApplePatchForIos10 = AutoplayHandler.isMobile() && AutoplayHandler.iOSversion()[0] >= 10 && this.options.enableInlineVideoForIos === false;
	        if (needApplePatchForIos10) {
	            var _playerManager = this;
	            if (_playerManager.overlayPlayer) {
	                _playerManager.options.targetElement.style.overflow = "";
	            } else {
	                setTimeout(function () {
	                    _playerManager.options.targetElement.style.overflow = "";
	                }, _playerManager.options.expandTime);
	            }
	        }

	        //this.destroyWithoutSkip(true, "error occurred",null,900);

	        this.isAlreadyPlaingForVPAID = true;

	        if (this.isCompleted) {
	            return;
	        }
	        debug("play video");

	        //this is for VID-1820 : sending event should be prior than invoking actual play method because that play method will cause another event like "firstPlay" which could give us a flag (this.isDoneInitialPlay == true).
	        if (this.isDoneInitialPlay) {
	            if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	                if (!this.isPlayingVideo) {
	                    this.dispatchEventToAdunit({"name": "video_resume"});
	                }
	            }
	            else if (!this.isPlayingVideo) {
	                this.dispatchEventToAdunit({"name": "video_resume"});
	            }
	        } else {
	            // handle impression only for video cases.
	            if (!this.options.vpaid) {
	                this.dispatchEventToAdunit({"name": "video_start"});
	                this.dispatchEventToAdunit({"name": "video_impression"});
	            }
	        }

	        if (this.options.vpaid && this.isIosInlineRequired()) {
	            if (!this.isDoneInitialPlay) {
	                this.adVideoPlayer.trigger('play');//jsvpaid in iOS inline should have this call instead of .play() in order to get "AdStarted" event for JSVPAID after that, framework will have proper video url which is set by JSVPAID creative
	            } else {
	                //this.adVideoPlayer.play();//for resuming video
	                this.actualPlayByVideoJS();
	            }

	        } else {
	            // VIDLA-908 (support VPAID for native iOS9 video player in Overlay Player)
	            if (this.options.vpaid && this.options.overlayPlayer && AutoplayHandler.isIOS() && AutoplayHandler.iOSversion()[0] < 10 &&
	                !this.isDoneInitialPlay) {
	                this.adVideoPlayer.trigger('play');
	            }
	            // support VPAID for Android in Overlay Player waterfall if required user action (also datasaver case)
	            else if (this.options.vpaid && this.options.overlayPlayer && navigator.appVersion.indexOf("Android") > -1 &&
	                this.options.enableWaterfall && !this.isDoneInitialPlay) {
	                this.adVideoPlayer.trigger('play');
	            }
	            else {
	                //this.adVideoPlayer.play();
	                this.actualPlayByVideoJS();
	            }
	        }

	        if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	        } else {
	            this.isPlayingVideo = true;
	        }

	        this.isDoneInitialPlay = true;
	        this.isEnded = false;
	    },

	    /**
	     * reset vpaid
	     */
	    resetVpaid: function () {
	        this.dispatchEventToAdunit({"name": "reset"});
	    },

	    /**
	     * pause video
	     */
	    pause: function () {
	        if (this.isPlayingVideo) {
	            debug("pause video");


	            this.adVideoPlayer.pause();

	            if (!this.isCompleted && !this.isEnded) {
	                this.dispatchEventToAdunit({"name": "video_pause"});
	            }

	        }

	    },

	    /**
	     * explicit pause a video
	     */
	    explicitPause: function () {
	        debug("explicit pause video");
	        this.explicitPaused = true;
	        this.pause();
	    },

	    /**
	     * explicit play a video
	     * @constructor
	     */
	    explicitPlay: function () {
	        debug("explicit play video");
	        this.explicitPaused = false;
	        this.play();
	    },

	    /**
	     * mute audio
	     */
	    mute: function () {
	        if (!this.isMuted) {
	            debug("mute audio");
	            if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	                this.adVideoPlayer.muted(true);
	                this.dispatchEventToAdunit({"name": "video_mute"});
	            }
	            else {
	                // the flash player will notify player manager when audio is muted and then dispatchEventToAdunit for video_mute will be called
	                this.adVideoPlayer.mute();
	            }
	            this.isMuted = true;
	        }
	    },

	    explicitMute: function () {
	        debug("explicit mute video");
	        this.isExplicitMuted = true;
	        this.mute();
	    },

	    /**
	     * unmute audio
	     */
	    unmute: function () {
	        if (!this.isExplicitMuted && this.isMuted) {
	            debug("unmute audio");
	            if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	                if (this.adVideoPlayer.muted() === true) {//if already unmuted then set flag and return;
	                    this.adVideoPlayer.muted(false);
	                }
	                if (this.isMuted || this.options.initialAudio === "off") {
	                    this.dispatchEventToAdunit({"name": "video_unmute"});
	                }
	            }
	            else {
	                // the flash player will notify player manager when audio is unmuted and then dispatchEventToAdunit for video_unmute will be called
	                this.adVideoPlayer.unmute();
	                this.hasBeenUnmuted = true;
	            }
	            this.isMuted = false;
	        }
	    },

	    explicitUnmute: function () {
	        this.isExplicitMuted = false;
	        this.unmute();
	    },

	    resizeVideoWithDimensions: function (width, height) {
	        var playerManager = this;
	        this.options.width = width;
	        this.options.height = height;
	        playerManager.resizeVideo(playerManager.aspectRatio);
	    },

	    /**
	     * mouseIn (for flash only)
	     */
	    mouseIn: function () {
	        this.adVideoPlayer.mouseIn();
	    },

	    /**
	     * mouseOut (for flash only)
	     */
	    mouseOut: function () {
	        this.adVideoPlayer.mouseOut();
	    },

	    destroy: function (isError, message) {

	        this.isPlayingVideo = false;
	        this.adVideoPlayer.pause();

	        //invoke skip event
	        if (this.isCompleted === false) {
	            if (this.options.vpaid === false) {
	                this.dispatchEventToAdunit({"name": "video_skip"});
	            } else if (this.options.vpaid === true && this.isSkipped === false) {//VIDLA-1399
	                this.dispatchEventToAdunit({"name": "video_skip"});
	            }
	        }

	        if (typeof this.callbackForAdUnit.cbWhenSkipped === "function") {
	        	this.callbackForAdUnit.cbWhenSkipped("video-skip");
	        }
	        this.isSkipped = true;

	        //TODO all event should be clear in here
	        debug("destroy");
	        var code = VAST_ERROR_UNDEFINED;//Undefined Error in VPAID3.0 spec
	        if (typeof this.callbackForAdUnit.cbWhenDestroy === "function") {
	            if (this.overlayPlayer) {
	                if (isError && message) {
	                    this.callbackForAdUnit.cbWhenDestroy({
	                        type: ERROR_TYPE_VAST,
	                        code: code,
	                        message: message
	                    }, true, this.options);
	                } else {
	                    this.callbackForAdUnit.cbWhenDestroy(null, true, this.options);
	                }
	            }
	            else {
	                if (isError && message) {
	                    this.callbackForAdUnit.cbWhenDestroy({
	                        type: ERROR_TYPE_VAST,
	                        code: code,
	                        message: message
	                    }, null, this.options);
	                } else {
	                    this.callbackForAdUnit.cbWhenDestroy(null, null, this.options);
	                }
	            }
	        }
	    },

	    destroyWithoutSkip: function (isError, message, timeout, errCode) {

	        try {
	            var playerManagerSelf = this;
	            var performSkip = function () {
	                playerManagerSelf.isPlayingVideo = false;

	                if (playerManagerSelf.adVideoPlayer && playerManagerSelf.adVideoPlayer.pause && typeof(playerManagerSelf.adVideoPlayer.pause) === "function") {
	                    playerManagerSelf.adVideoPlayer.pause();
	                }

	                //TODO all event should be clear in here
	                debug("destroy without skip: " + playerManagerSelf.options.iframeVideoWrapperId);
	                var code = errCode || VAST_ERROR_UNDEFINED;//Undefined Error in VPAID3.0 spec
	                if (typeof playerManagerSelf.callbackForAdUnit.cbWhenDestroy === "function") {
	                    if (playerManagerSelf.overlayPlayer) {
	                        if (isError && message) {
	                            if (timeout) {
	                                code = VAST_ERROR_TIMEOUT;
	                            }
	                            playerManagerSelf.callbackForAdUnit.cbWhenDestroy({
	                                type: ERROR_TYPE_VAST,
	                                code: code,
	                                message: message
	                            }, true, playerManagerSelf.options);
	                        } else {
	                            playerManagerSelf.callbackForAdUnit.cbWhenDestroy(null, true, playerManagerSelf.options);
	                        }
	                    }
	                    else {
	                        if (isError && message) {
	                            if (timeout) {
	                                code = VAST_ERROR_TIMEOUT;
	                            }
	                            playerManagerSelf.callbackForAdUnit.cbWhenDestroy({
	                                type: ERROR_TYPE_VAST,
	                                code: code,
	                                message: message
	                            }, null, playerManagerSelf.options);
	                        } else {
	                            playerManagerSelf.callbackForAdUnit.cbWhenDestroy(null, null, playerManagerSelf.options);
	                        }
	                    }
	                }
	            };

	            if (playerManagerSelf.options.disableCollapseForDelay && playerManagerSelf.options.disableCollapseForDelay > 0) {
	                setTimeout(performSkip, playerManagerSelf.options.disableCollapseForDelay);
	            } else {
	                performSkip();
	            }
	        } catch (ex) {
	            error("failed to destroy/notify by " + ex);
	        }

	    },

	    /**
	     * return Video Object it self
	     * @returns {*}
	     */
	    getVideoObject: function () {
	        return this.adVideoPlayer;
	    },

	    handleFlashPlay: function () {
	        var playerManager = this;
	        var fnAfterAdLoaded = function () {
	            playerManager.resizeVideo(playerManager.aspectRatio);
	            debug("flash player is ready to play");
	            if (playerManager.callbackForAdUnit.cbWhenReady) {
	                playerManager.callbackForAdUnit.cbWhenReady(playerManager);
	            }
	        };
	        if (playerManager.isChrome) {
	            playerManager.setChromeSize();//for Chrome limitations
	            setTimeout(fnAfterAdLoaded, 100);
	        }
	        else {
	            fnAfterAdLoaded();
	        }
	    },

	    handlePlayerNotification: function (dataObj) {

	//        debug(dataObj);
	        if (dataObj.name !== 'video_time') {
	            debug("Got notification from player = " + dataObj.name);
	        }
	        //define method in self object
	        //debug(dataObj);
	        var playerManager = this;

	        var eventHandler = {
	            "flash_is_respondble": function () {
	                if (playerManager.flashBlockerTimeout) {
	                    clearTimeout(playerManager.flashBlockerTimeout);
	                    playerManager.flashBlockerTimeout = null;
	                }
	                debug("Flash is respondble");
	                return;
	            },
	            "canplay": function () {
	                if (playerManager.flashBlockerTimeout) {
	                    clearTimeout(playerManager.flashBlockerTimeout);
	                    playerManager.flashBlockerTimeout = null;
	                    debug("Flash is respondble");
	                }
	                if (playerManager.options.hasOwnProperty('overlayPlayer')) {
	                    try {
	                        playerManager.adVideoPlayer.setDOMPlayerIdAndSize(playerManager.adVideoPlayer.id,
	                            playerManager.options.width, playerManager.options.height);
	                    }
	                    catch (ex) {
	                        debug("Failed to execute setDOMPlayerIdAndSize(...) on Flash Player");
	                    }
	                }
	                if (playerManager.options.vpaid) {
	                    try {
	                        var strCompanions = playerManager.adVideoPlayer.getCompanionsXml();
	                        if (strCompanions && strCompanions.length > 0) {
	                            dataObj.companionAds = strCompanions;
	                        }
	                    }
	                    catch (err) {
	                    }
	                }
	                if (playerManager.options.vpaid && playerManager.options.delayExpandUntilVPAIDImpression) {
	                    //playerManager.adVideoPlayer.play();//VID-1549
	                    playerManager.actualPlayByVideoJS();
	                } else {
	                    playerManager.handleFlashPlay();
	                }
	            },
	            "video_failed": function () {
	                if (playerManager.flashBlockerTimeout) {
	                    clearTimeout(playerManager.flashBlockerTimeout);
	                    playerManager.flashBlockerTimeout = null;
	                    debug("Flash is respondble");
	                }
	                // 'destroyWithoutSkip(true)' will dispatch 'error' event by itself
	                playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VIDEO_FAILED, null, VAST_ERROR_VIDEOFAILED);
	            },
	            "video_timeout": function () {
	                playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VIDEO_FAILED, true, VAST_ERROR_TIMEOUT);
	            },
	            "video_bitrate": function () {
	                var bandWidth = dataObj.bandwidth;
	                debug("bandwidth from flash : " + bandWidth);
	                //TODO expose bandwitdh
	            },
	            "video_impression": function () {

	            },
	            "video_mute": function () {
	                if (dataObj.hasOwnProperty('value') && !dataObj.value) {
	                    dataObj.name = 'video_unmute';
	                }
	                if (dataObj.hasOwnProperty('value')) {
	                    playerManager.isMuted = dataObj.value;
	                }
	            },
	            "video_click": function () {
	                if (dataObj.hasOwnProperty('playerHandles')) {
	                    if (dataObj.playerHandles) {
	                        // the player handles vpaid creative click event
	                        if (dataObj.hasOwnProperty('url') && dataObj.url.length > 0) {
	                            playerManager.click(dataObj.url);
	                        }
	                        else {
	                            playerManager.click();
	                        }
	                    }
	                    else {
	                        // creative handles this event. we need only notify ad about click
	                        playerManager.dispatchEventToAdunit({"name": "ad-click", "trackClick": true});
	                    }
	                }
	                else {
	                    // it is not a vpaid creative click
	                    playerManager.click();
	                }
	            },
	            "video_complete": function () {
	                playerManager.isCompleted = true;
	                if (!playerManager.options.disableCollapse.enabled) {
	                    playerManager.destroyWithoutSkip();
	                }
	            },
	            "video_fullscreen": function () {
	                if (playerManager.isFullscreen) {
	                    setTimeout(function () {
	                        playerManager.isFullscreen = !playerManager.isFullscreen;
	                    }, 1000);//this delay must be required for supressing mouseout event when exit fullscreen

	                } else {
	                    playerManager.isFullscreen = !playerManager.isFullscreen;
	                }

	            },
	            "quartile_event": function () {

	            },
	            "video_pause": function () {
	            },
	            "video_start": function () {
	                if (!playerManager.isDoneInitialPlay && playerManager.options.initialPlayback !== 'auto') {
	                    playerManager.play();
	                }
	            },
	            "video_time": function () {

	            },
	            "video_resume": function () {
	            },
	            "video_stopped": function () {
	                playerManager.destroyWithoutSkip();
	            },
	            "video_skipped": function () {
	                //click skip
	                playerManager.destroy();
	            },
	            "video_ratio": function () {
	                //playerManager.aspectRatio = dataObj.ratio;
	            },
	            "video_heightOffset": function () {
	                playerManager.heightOffset = dataObj.heightOffset;
	                //playerManager.options.height = playerManager.options.height + dataObj.heightOffset;
	                //test
	            },
	            "video_paused_by_user": function () {
	                playerManager.explicitPause();
	            },
	            "video_resumed_by_user": function () {
	                //playerManager.explicitPlay();

	                //change logic for VID-2504
	                debug("received video_resumed_by_user from Flash");
	                if (playerManager.requiredForFlashVpaid()) {
	                    if (playerManager.isVpaidFlashVideoPlaying === false) {
	                        debug("call explicitPlay by video_Resumed_by_user event");
	                        playerManager.explicitPlay();
	                    } else {
	                        debug("do nothing because of isVpaidFlashVideoPlaying:true");
	                    }
	                } else {
	                    playerManager.explicitPlay();
	                }
	            },
	            "video_progress": function () {
	                if (dataObj && dataObj.offset) {
	                    playerManager.dispatchEventToAdunit({"name": dataObj.offset}, function () {
	                        debug("handle video_progress by flash : " + dataObj.offset);
	                    });
	                    return;
	                }
	            }
	        };

	        if (!playerManager.isDoneInitialPlay && dataObj.name === "video_mute") {
	            // ignore some implicit event(s) before done initial play
	            return;
	        }

	        //invoke eventHandler by dataObj.name
	        var invoker = eventHandler[dataObj.name];
	        if (invoker && invoker !== undefined) {
	            invoker();
	        }

	        if (dataObj.name !== "video_pause" && dataObj.name !== "video_resume" &&
	            dataObj.name !== "video_impression" && dataObj.name !== "video_start" &&
	            dataObj.name !== "video_failed" && dataObj.name !== "video_timeout") {

	            this.dispatchEventToAdunit(dataObj);
	        }

	        if ((dataObj.name === "video_impression" || dataObj.name === "video_start") && playerManager.options.vpaid) {
	            this.dispatchEventToAdunit(dataObj);
	        }
	    },
	    handleOverlayNotification: function (dataObj) {
	        //define method in self object
	        debug("Got overlay notification from player = " + dataObj.name);
	        var playerManager = this;

	        var eventHandler = {
	            "leaveFullscreen": function () {
	                if (playerManager.options.hasOwnProperty('playerNotification')) {
	                    playerManager.options.playerNotification('leaveFullscreen');
	                }
	            }
	        };

	        //invoke eventHandler by dataObj.name
	        var invoker = eventHandler[dataObj.name];
	        if (invoker && invoker !== undefined) {
	            invoker();
	        }
	    },

	    requiredForFlashVpaid: function () {
	        return (this.decidePlayer(this.options.requiredPlayer) === "flash" && this.options.vpaid === true);
	    },

	    notifyVpaidEvent: function (eventName) {
	        var playerManager = this;

	        //for VID-2504
	        if (playerManager.requiredForFlashVpaid()) {
	            if (eventName === "AdPaused") {
	                debug("received VPAID AdPaused from Flash");
	                playerManager.isVpaidFlashVideoPlaying = false;
	                playerManager.isPlayingVideo = false;
	                debug("set isVpaidFlashVideoPlaying = false");
	                debug("set isPlayingVideo = false");
	            }

	            if (eventName === "AdPlaying") {
	                debug("received VPAID AdPlaying from Flash");
	                playerManager.isVpaidFlashVideoPlaying = true;
	                playerManager.isPlayingVideo = true;
	                debug("set isVpaidFlashVideoPlaying = true");
	                debug("set isPlayingVideo = true");
	            }
	        }

	        //for VID-1549
	        if (playerManager.decidePlayer(playerManager.options.requiredPlayer) === "flash" && playerManager.options.delayExpandUntilVPAIDImpression) {
	            if (eventName === "AdVideoStart") {
	                playerManager.adVideoPlayer.pause();
	            }
	            if (eventName === "AdImpression") {
	                playerManager.gotAdImpressionForFlash = true;
	            }
	            if (eventName === "AdStarted") {
	                playerManager.gotAdStartedForFlash = true;
	            }
	            if (playerManager.gotAdImpressionForFlash && playerManager.gotAdStartedForFlash) {
	                //this should be one time action when we got both impression and adStarted in order to resize video
	                playerManager.handleFlashPlay();//allow to expand
	                playerManager.gotAdImpressionForFlash = false;
	                playerManager.gotAdStartedForFlash = false;
	            }
	        }


	        //for VID-1551
	        if (playerManager.options.delayExpandUntilVPAIDImpression && playerManager.delayEventHandler.isSuppress && EVENTS_HAVE_TO_FILTER_OUT.indexOf(eventName) >= 0) {
	            return;
	        }

	        if(eventName === "AdVolumeChange"){
	            var isHtml5 = (this.decidePlayer(this.options.requiredPlayer) === 'html5');
	            if (isHtml5) {//for html5
	                var isAudioMuted = playerManager.adVideoPlayer.player().muted();
	                var volume = playerManager.adVideoPlayer.player().volume();
	                if (!isAudioMuted) {
	                    if (volume > 0) {
	                        debug("set VPAID AdVolumeChange video_unmute");
	                        this.dispatchEventToAdunit({"name": "video_unmute"});
	                    }
	                } else if(isAudioMuted) {
	                    debug("set VPAID AdVolumeChange video_mute");
	                    this.dispatchEventToAdunit({"name": "video_mute"});
	                }
	            }
	        }

	        if (EVENTS_RESTRICTED_SUPPRESSING.indexOf(eventName) >= 0 || EVENTS_RESTRICTED_SUPPRESSING.indexOf("vpaid." + eventName) >= 0) {
	            //don't suppress, trigger immidiately
	            playerManager.notifyVpaidEvent_internal(eventName);
	        } else {
	            playerManager.delayEventHandler.push(function () {
	                playerManager.notifyVpaidEvent_internal(eventName);
	            });
	        }
	    },

	    notifyVpaidEvent_internal: function (eventName) {
	        if (this.options.cbNotification) {
	            this.options.cbNotification('VPAID', eventName, this.options.targetId);
	        }
	        if (this.options.cbApnVastPlayer) {
	            this.options.cbApnVastPlayer(eventName);
	        }
	    },

	    setChromeSize: function () {
	        this.adVideoPlayer.width = "0px";
	        this.adVideoPlayer.height = "0px";
	        this.adVideoPlayer.style.width = "0px";
	        this.adVideoPlayer.style.height = "0px";
	        this.options.targetElement.style.visibility = "visible";
	    },

	    click: function (urlFromCreative, needToTrack) {

	        if (!this.isDoneInitialPlay) {
	            this.play();//play the video by clicking play button
	            return;
	        }

	        if (this.isIosInlineRequired() === false) {//iOS will pause the video when window.open completed by blur a window, so don't need to be invoked here for VID-2074
	            this.pause();
	            this.toggleWindowFocus = false;//this will make sure to have clear status of focus because at somecase, document.hasFocus() can have true when we do open.window() even the focus is already on the new window.
	        }

	        /**
	         * ad-click
	         */
	        //Do not track clickThru if landing url was not found.
	        var trackClick = false;
	        // For Pricecheck we need to open the clickthrough url with mraid, so send a callback
	        // with name and url if the option 'useCustomOpenForClickthrough' is true
	        if (this.options.useCustomOpenForClickthrough) {
	            var clickthroughURL = this.options.clickUrls[0];
	            if (urlFromCreative) {
	                clickthroughURL = urlFromCreative;
	            }
	            trackClick = true;
	            this.dispatchEventToAdunit({"name": "video_click_open_url", "url": clickthroughURL});
	        }
	        else if (urlFromCreative) {
	            trackClick = true;
	            window.open(urlFromCreative);
	        }
	        else if (this.options.clickUrls[0]) {
	            trackClick = true;
	            var url = this.options.clickUrls[0];
	            window.open(url);
	        }

	        if (typeof needToTrack === "undefined" || needToTrack === true) {
	            this.dispatchEventToAdunit({"name": "ad-click", "trackClick": trackClick});
	        }


	    },

	    getRapamsAndExtensions: function () {
	        var extensions = (this.options.extensions && this.options.extensions.length > 0) ? '<Extensions>' + this.options.extensions + '</Extensions>' : '';
	        return {adParameters: this.options.adParameters, extensions: extensions};
	    },

	    handleViewability: function (object_, checkEventToStartViewability, isHtml5) {

	        var isEnabledViewability = this.options && this.options.viewability && this.options.viewability.config;
	        var eventName = (object_ && object_.name) ? object_.name : null;

	        //for fullscreen VIDLA-263
	        if (eventName === "fullscreenchange" || eventName === "video_fullscreen") {
	            eventName = (this.isFullscreen) ? "fullscreen" : "exitFullscreen";
	        }

	        if (!isHtml5 && eventName === "video_duration") {
	            this.isAlreadyStart = true;
	        }


	        //initialize library and invoke first event like "expand" or "video_start"
	        var initializeViewabilityLibrary = function () {


	            //start viewability initalization
	            var duration;
	            if (isHtml5) {//for html5
	                duration = this.adVideoPlayer && this.adVideoPlayer.player && typeof(this.adVideoPlayer.player) === "function" && this.adVideoPlayer.player().duration();
	            } else {//for flash
	                duration = object_.duration;
	            }

	            //VIDLA-568 Update Core Player Logic to support delayed start of viewability library until duration
	            if (!duration || duration === undefined || duration <= 0) {
	                duration = -2;//-2 means unknown duration on vpaid sepc
	            }

	            //find failsafe value by this order (use vast duratio, -2)
	            if (duration === -2) {//VIDLA-619
	                if (this.options && this.options.data && this.options.data.vastDurationMsec) {
	                    duration = this.options.data.vastDurationMsec / 1000;
	                    if (!duration || duration === null || duration <= 0) {
	                        duration = -2;//-2 means unknown duration on vpaid sepc
	                    }
	                } else {
	                    duration = -2;
	                }
	            }

	            var width = this.options.width;
	            var height = this.options.height;
	            this.viewabilityTracking.init(this.options, duration, width, height, checkEventToStartViewability);

	            //invoke initial event
	            if (isHtml5) {
	                // checkEventToStartViewability will be (this.options.vpaid) ? "video_start" : "loadstart";
	                if (this.options.expandable) {//fix VIDLA-1340 - usually expandable adunit expects to have "expand", but for a case if it's already expanded like mediated placement the code wais "video_start"
	                    if (this.options.vpaid === true && eventName === "video_start") {
	                        this.viewabilityTracking.invokeEvent("expand");
	                        //this.viewabilityTracking.invokeEvent("video_start");
	                    }
	                    if (this.options.vpaid === false && eventName === "loadstart") {
	                        this.viewabilityTracking.invokeEvent("expand");
	                        //this.viewabilityTracking.invokeEvent("video_start");
	                    }
	                    this.viewabilityTracking.invokeEvent(eventName);
	                } else {
	                    // VIDLA-1480 (MOBILE - we have to delay to start viewabilty until click happened for click-to-play placements in Overlay Player)
	                    if (this.options.overlayPlayer && Utils.isMobile() && this.options.delayStartViewability) {
	                        return;
	                    }
	                    this.viewabilityTracking.invokeEvent(eventName);
	                }
	            } else {
	                //a decision from VIDLA-568 for Flash
	                if (this.isAlreadyStart) {
	                    if (this.options.expandable) {//invoke expand only for expandable ad-unit like Outstream
	                        this.viewabilityTracking.invokeEvent("expand");
	                    }
	                    this.viewabilityTracking.invokeEvent("video_start");
	                }
	            }

	        };

	        //invoke event
	        var invokeEventToViewabilityLibrary = function () {
	            //handle viewability after initialization of viewability library
	            if (this.viewabilityTracking && this.viewabilityTracking.isReady) {
	                if (isHtml5 === false && eventName === "expand" && this.options.expandable) {
	                    return;//avoid a problem that caused by unexpected video_start by flash before expanding of outstream
	                } else {
	                    if (eventName === 'force_start_viewability' && this.options.delayStartViewability) {
	                        this.options.delayStartViewability = false;		// make sure we do not force to start viewability twice
	                        this.viewabilityTracking.invokeEvent('video_start');
	                    }
	                    else {
	                        this.viewabilityTracking.invokeEvent(eventName);
	                    }
	                }
	            }
	        };

	        if (eventName && isEnabledViewability) {
	            // VIDLA-1469 (block tracking events for viewability when those events are blocked for regular tracking)
	            var blockEvent = this.blockTrackingUserActivity &&
	                (eventName === "video_resume" || eventName === "video_pause" || eventName === "video_mute" || eventName === "video_unmute");
	            if (!blockEvent) {
	                if (eventName === checkEventToStartViewability) {//only at the time we got "expandStart" can have proper duration and final width,height for outstream, for other ad-unit this will use `loadstart` by a logic
	                    initializeViewabilityLibrary.apply(this);
	                } else {
	                    invokeEventToViewabilityLibrary.apply(this);
	                }
	            }
	        }
	    },

	    findPathForViewability: function (object_) {

	        var isHtml5 = (this.decidePlayer(this.options.requiredPlayer) === 'html5');
	        var checkEventToStartViewability;

	        if (isHtml5) {//for html5

	            if (this.options.expandable && (typeof(this.options.isExpanded) === "undefined" || this.options.isExpanded === false)) {
	                checkEventToStartViewability = "expand";//event from Outstream, if it's expandable adunit viewability intialization will be done by this expand event
	            } else {
	                //checkEventToStartViewability = (this.options.vpaid) ? "video_start" : "loadstart";//event from core-video framework. if it's not expandable adunit or mediated type viewaiblity will be inialized by "video_start" or "loadstart" based on type of ad (vast or vpaid)
	                checkEventToStartViewability = "video_start";	// VIDLA-1343 - use video_start to init viewability for all not Outstream products
	            }

	            if (object_ && object_.name && object_.name === checkEventToStartViewability) {//avoiding double invoke
	                if (this.isDoneFirstLoadStart) {
	                    return;
	                } else {
	                    this.isDoneFirstLoadStart = true;
	                }
	            }
	            this.handleViewability(object_, checkEventToStartViewability, isHtml5);

	        } else {//for flash
	            checkEventToStartViewability = "video_duration";//by VIDLA-619

	            if (object_ && object_.name === "video_start") {
	                return;//do nothing if it's video_start, video_duration will consider as video_start because only video_duration can have duration of video and Flash player promised it will be triggered after video_start
	            }

	            if (object_ && object_.name && object_.name === checkEventToStartViewability) {//avoiding double invoke
	                if (this.isDoneFirstLoadStart) {
	                    //do nothing
	                } else {
	                    this.isDoneFirstLoadStart = true;
	                    this.handleViewability(object_, checkEventToStartViewability, isHtml5);//for initialize
	                }
	            } else {
	                this.handleViewability(object_, checkEventToStartViewability, isHtml5);
	            }

	        }
	    },
	    dispatchEventToAdunit: function (object_, cb) {

	        var playerManager = this;
	        if (object_.name === "video_start") {
	            // when using flash player iframeVideoWrapper is a blank object, so check for contentDocument field in it before trying to use it (VIDLA-2245)
	            if (playerManager.iframeVideoWrapper.contentDocument) {
	                //set background with options.playerSkin.videoBackground
	                var divForVideo = playerManager.iframeVideoWrapper.contentDocument.getElementById(playerManager.divIdForVideo);
	                var video = playerManager.iframeVideoWrapper.contentDocument.getElementById(playerManager.videoId);

	                divForVideo.style.background = playerManager.options.playerSkin.videoBackgroundColor;
	                video.style.background = playerManager.options.playerSkin.videoBackgroundColor;
	            }
	        }



	        if (object_.name === "video_complete") {
	            if (object_.obj === undefined) {
	                object_.obj = {};
	            }
	            object_.obj.videoAdPending = this.options.disableCollapse.replay;
	        }

	        //VIDLA-574
	        //Flash fullscreen has to have some latency to get a exact fullscreen status during switching it
	        if (object_.name === "video_fullscreen" && this.decidePlayer(this.options.requiredPlayer) === 'flash') {
	            setTimeout(function () {
	                //copy object to make it read only in order to avoid conflict situation
	                var eventForFullscren = {
	                    "name": object_.name,
	                    "user": object_.user,
	                    "value": object_.value,
	                };
	                playerManager.findPathForViewability(eventForFullscren);
	            }, 1500);//delay to have exact fullscreen status which will be set by playerManager
	        } else {
	            this.findPathForViewability(object_);
	        }

	        if ((this.startedReplay === true || this.isEnded) && this.options.disableCollapse.replay === true) {
	            if (this.startedReplay === false && object_.name === "rewind") {
	            } else if (object_.name === "video_complete" && typeof cb === "function") {
	                cb();
	                return;
	            } else if (object_.name !== "ad-click" && object_.name.indexOf("IconClick") === -1) {
	                this.callbackForAdUnit.cbForHandlingDispatchedEvent(object_, true);
	                return;
	            }
	        }

	        if (object_.name === "video_skip" && unique.pushAndCheck(this.options.targetElement.id + "_dispatchEventToAdunit", object_.name) === false) {
	            return;//the unique.pushAndCheck will check if the value is unique, through this apprach unnecassary second "video-skip" will be ignored.
	        }

	        if (object_.name === "video_complete" && this.isVideoCompleteInjected === true && this.options.disableCollapse.replay === false) {
	            //do nothing
	        } else {

	            if (object_ && object_.name !== "video_time") {
	                debug("(push)" + object_.name);
	            }

	            this.delayEventHandler.push(function () {
	                playerManager.dispatchEventToAdunit_internal(object_, cb);
	            });
	            if (object_.name === "video_complete") {
	                this.isVideoCompleteInjected = true;
	            }
	        }

	    },

	    /**
	     * dispatchEventToAdunit_internal
	     * @param object_ : kind of events
	     * @param cb : this callback will be invoked after handled all trackings and events
	     */
	    dispatchEventToAdunit_internal: function (object_, cb) {

	        //debug("dispatchEventToAdunit : " + object_.name);

	        // if video is completed all vast event firing will be ignored,
	        // except video_complete, video_skip and ad-click event, make sure we notify ad unit about video completion.
	        if (this.isCompleted && !(object_.name === "video_complete" || object_.name === "ad-click" || object_.name === "video_skip") && !this.startedReplay) {
	            return;
	        }

	        var playerManager = this;
	        if (object_ && object_.name !== "video_time") {
	            debug("invoke callback : " + JSON.stringify(object_));
	        }

	        if (this.options.hasOwnProperty('overlayPlayer') && this.options.hiddenControls) {
	            if ((object_.name === "firstplay" && !this.options.vpaid) ||
	                (object_.name === "video_impression" && this.options.vpaid)) {
	                // VIDLA-40/1145 (show control bar in Overlay Player on Android/iOS for click-to-play/mouse-over when ad started)
	                if (Utils.isMobile() && (this.options.initialPlayback === 'click' || this.options.initialPlayback === 'mouseover')) {
	                    this.adVideoPlayer.controlBar.el_.style.removeProperty('display');
	                    delete this.options.hiddenControls;
	                }
	                // VIDLA-1145 (show control bar in Overlay Player on iOS 9 for autoplay when ad started)
	                else if (AutoplayHandler.isIOS() && AutoplayHandler.iOSversion()[0] < 10 && this.options.initialPlayback === 'auto') {
	                    this.adVideoPlayer.controlBar.el_.style.removeProperty('display');
	                    delete this.options.hiddenControls;
	                }
	            }

	            if (object_.name === "video_resume" && this.options.vpaid && Utils.isMobile()) {
	                // VIDLA-1188 show control bar only after AdStarted event for mobile devices in Overlay Player
	                this.adVideoPlayer.controlBar.el_.style.removeProperty('display');
	                delete this.options.hiddenControls;
	            }
	        }

	        if (this.callbackForAdUnit.cbForHandlingDispatchedEvent && object_.name !== "video_time") {
	            // debug("dispatchEventToAdunit : " + object_.name);

	            if (object_.name === "video_pause") {
	                this.isPlayingVideo = false;
	            }

	            if (object_.name === "video_play" || object_.name === "video_start" || object_.name === "firstplay") {
	                this.isPlayingVideo = true;
	                this.isDoneInitialPlay = true;
	            }

	            //fullscreen has to have some latency to get a exact fullscreen status during switching it
	            if (object_.name === "video_fullscreen") {
	                setTimeout(function () {
	                    object_.fullscreenStatus = (playerManager.isFullscreen ? "enter" : "exit");
	                    playerManager.callbackForAdUnit.cbForHandlingDispatchedEvent(object_);
	                }, 1500);
	                return;
	            }


	            if (typeof(cb) === "function") {
	                cb();//invoke callback if exists
	            }

	            var blockEvent = this.blockTrackingUserActivity &&
	                (object_.name === "video_resume" || object_.name === "video_pause" || object_.name === "video_mute" || object_.name === "video_unmute");
	            if (!blockEvent) {
	                this.callbackForAdUnit.cbForHandlingDispatchedEvent(object_);
	            }
	        }

	        //VIDLA-1399 Outstream/Overlay Player/Viewability- 'stop' view ability tracker fired twice when skip the Ad for JS and FLASH VPAID creatives
	        if (this.options.vpaid === true && object_.name === "video_skip") {
	            this.isSkipped = true;
	        }
	    },

	    resizeVideo: function (aspectRatio, shouldConsiderHeightOfDevice, cb) {
	        VideoSizeHandler.resizeVideo(aspectRatio, shouldConsiderHeightOfDevice, this, cb);
	    },

	    resizeVideoForSideStream: function (width, height, cb) {
	        VideoSizeHandler.resizeVideoForSideStream(this, width, height, cb);
	    },

	    isIosInlineRequired: function () {
	        return this.autoplayHandler.isIosInlineRequired(this.options.enableInlineVideoForIos);
	    },

	    resizePlayer: function (width, height) {
	        VideoSizeHandler.resizePlayer(width, height, this);
	    },

	    getFinalSize: function () {
	        return VideoSizeHandler.getFinalSize(this);
	    },

	    setVastAttribute: function (duration) {
	        var _options = this.options;
	        var _videoDuration;

	        if (duration) {
	            _videoDuration = duration;
	        } else {
	            _videoDuration = (this.adVideoPlayer && this.adVideoPlayer.player) ? this.adVideoPlayer.player().duration() : 0;
	        }

	        _options.data.durationMsec = (_videoDuration !== null) ? Math.round(_videoDuration * 1000) : 0;//flash will have zero here

	        //convert skipOffset to milliseconds
	        var _msec = this.Utils.getMsecTime(_options.data.skipOffset, _options.data.durationMsec);
	        if (_options.data.skipOffset && _msec >= 0) {
	            _options.data.isVastVideoSkippable = true;
	            _options.data.skipOffsetMsec = _msec;
	        } else {
	            _options.data.skipOffsetMsec = null;
	        }

	        //convert progress event to milli seconds
	        var vastProgressEvent = _options.data.vastProgressEvent;
	        if (vastProgressEvent && typeof(vastProgressEvent) === "object") {

	            for (var _event in vastProgressEvent) {
	                var _offsetMsec = (this.Utils.getMsecTime(_event.replace(/progress_/g, ""), _options.data.durationMsec));
	                vastProgressEvent[_event] = _offsetMsec;
	            }
	        }


	    },

	    disableTrackingUserActivity: function (value) {
	        this.blockTrackingUserActivity = value;
	        // VIDLA-1455 - iOS never showing button after hide(), change button visiblity by changing opacity
	        if (this.adVideoPlayer && this.adVideoPlayer.bigPlayButton) {
	            this.adVideoPlayer.bigPlayButton.el_.style.opacity = value === true ? 0 : 1;
	        }
	    },

	    delayEventsTracking: function (delay, events) {
	        if (this.callbackForAdUnit.cbDelayEventsTracking) {
	            this.callbackForAdUnit.cbDelayEventsTracking(delay, events);
	        }
	    },

	    notifyOverlayPlayerVideoPaused: function () {
	        if (this.options.tmpActiveListener && this.options.cbApnVastPlayer) {
	            this.options.cbApnVastPlayer('apn-video-paused-by-device');
	        }
	    },

	    // VIDLA-1605. For mobile devices ad video could be paused by device when another video (main content video for overlay player) is playing.
	    // We have to notify overlay player about this situation.
	    // boolCheck parameters activates/deactivates 'paused-by-device' checking functionality.
	    // Overlay player calls this function only for mobile devices.
	    checkWhenVideoPausedByDevice: function (boolCheck) {
	        if (this.options.overlayPlayer && this.options.cbApnVastPlayer && this.iframeVideoWrapper && this.iframeVideoWrapper.contentDocument) {
	            // try to get video element
	            var videoEl = null;
	            if (typeof(this.videoObjectId) === 'string') {
	                videoEl = this.iframeVideoWrapper.contentDocument.getElementById(this.videoObjectId);
	            }
	            else {
	                // for js vpaid videoObjectId is empty object. Try to found video element by tag name with not empty source.
	                var videos = this.iframeVideoWrapper.contentDocument.getElementsByTagName('VIDEO');
	                if (videos && videos.length > 0) {
	                    for (var i = 0; i < videos.length; i++) {
	                        if (videos[i].src && videos[i].src.length > 0) {
	                            videoEl = videos[i];
	                            break;
	                        }
	                    }
	                }
	            }
	            if (videoEl) {
	                if (boolCheck) {
	                    // use this temp flag because removeEventListener sometimes does not remove listener ?!?!
	                    this.options.tmpActiveListener = true;
	                    videoEl.addEventListener('pause', this.notifyOverlayPlayerVideoPaused.bind(this));
	                }
	                else {
	                    delete this.options.tmpActiveListener;
	                    videoEl.removeEventListener('pause', this.notifyOverlayPlayerVideoPaused.bind(this));
	                }
	                return true;	// video element exists
	            }
	        }
	        return true;	// video element does not exist
	    },

	    forceStartViewability: function () {
	        this.findPathForViewability({name: 'force_start_viewability'});
	    },

	    log: debug,
	    debug: debug,

	    test: function (func, obj) {//for tdd
	        var options = this.options;
	        if (options && options.test && options.test[func] && typeof(options.test[func]) === "function") {

	            //moved from outside because we don't need to define this function variables when it doesn't need to test
	            var _fail = function (msg) {
	                console.debug("%c" + msg, "background: red; color: white");
	            };
	            var _succeed = function (msg) {
	                console.debug("%c" + msg, "background: green; color: white");
	            };

	            try {
	                var assert = function (condition, message) {
	                    if (!condition) {
	                        message = message + " failed" || "Assertion failed";
	                        _fail("Unit Test [" + func + "] : " + message);
	                    } else {
	                        message = message + " Succeeded" || "Succeeded";
	                        _succeed("Unit Test [" + func + "] : " + message);
	                    }
	                };
	                var log = function (msg) {
	                    console.debug("%cUnit Test Log : [" + func + "] : " + msg, "background: gray; color: white");
	                };

	                options.test[func](obj, assert, log);
	            } catch (ex) {
	                _fail("unit test failed due to : " + ex);
	            }
	        }
	    }

	};

	module.exports = adVideoPlayerManager;
	window[externalNameOfVideoPlayer] = adVideoPlayerManager;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/* jshint ignore:start */
	/**
	 * @fileoverview Main function src.
	 */

	// HTML5 Shiv. Must be in <head> to support older browsers.
	document.createElement('video');
	document.createElement('audio');
	document.createElement('track');

	/**
	 * Doubles as the main function for users to create a player instance and also
	 * the main library object.
	 *
	 * **ALIASES** videojs, _V_ (deprecated)
	 *
	 * The `vjs` function can be used to initialize or retrieve a player.
	 *
	 *     var myPlayer = vjs('my_video_id');
	 *
	 * @param  {String|Element} id      Video element or video element ID
	 * @param  {Object=} options        Optional options object for config/settings
	 * @param  {Function=} ready        Optional ready callback
	 * @return {vjs.Player}             A player instance
	 * @namespace
	 */
	var global_options;//for having proper pre-generate iframe id
	var vjs = function(id, options, ready){
	  global_options = options;
	  var tag; // Element of ID

	  // Allow for element or ID to be passed in
	  // String ID
	  if (typeof id === 'string') {

	    // Adjust for jQuery ID syntax
	    if (id.indexOf('#') === 0) {
	      id = id.slice(1);
	    }

	    // If a player instance has already been created for this ID return it.
	    if (vjs.players[id]) {

	      // If options or ready funtion are passed, warn
	      if (options) {
	        vjs.log.warn ('Player "' + id + '" is already initialised. Options will not be applied.');
	      }

	      if (ready) {
	        vjs.players[id].ready(ready);
	      }

	      return vjs.players[id];

	    // Otherwise get element for ID
	    } else {
	      tag = vjs.el(id);
	    }

	  // ID is a media element
	  } else {
	    tag = id;
	  }

	  // Check for a useable element
	  if (!tag || !tag.nodeName) { // re: nodeName, could be a box div also
	    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns
	  }

	  // Element may have a player attr referring to an already created player instance.
	  // If not, set up a new player and return the instance.
	  return tag['player'] || new vjs.Player(tag, options, ready);
	};

	// Extended name, also available externally, window.videojs
	var videojs = window['videojs_apn'] = vjs;

	// CDN Version. Used to target right flash swf.
	vjs.CDN_VERSION = 'GENERATED_CDN_VSN';
	vjs.ACCESS_PROTOCOL = ('https:' == document.location.protocol ? 'https://' : 'http://');

	/**
	* Full player version
	* @type {string}
	*/
	vjs['VERSION'] = 'GENERATED_FULL_VSN';

	/**
	 * Global Player instance options, surfaced from vjs.Player.prototype.options_
	 * vjs.options = vjs.Player.prototype.options_
	 * All options should use string keys so they avoid
	 * renaming by closure compiler
	 * @type {Object}
	 */
	vjs.options = {
	  // Default order of fallback technology
	  'techOrder': ['html5','flash'],
	  // techOrder: ['flash','html5'],

	  'html5': {},
	  'flash': {},

	  // Default of web browser is 300x150. Should rely on source width/height.
	  'width': 300,
	  'height': 150,
	  // defaultVolume: 0.85,
	  'defaultVolume': 0.00, // The freakin seaguls are driving me crazy!

	  // default playback rates
	  'playbackRates': [],
	  // Add playback rate selection by adding rates
	  // 'playbackRates': [0.5, 1, 1.5, 2],

	  // default inactivity timeout
	  'inactivityTimeout': 2000,

	  // Included control sets
	  'children': {
	    'mediaLoader': {},
	    'posterImage': {},
	    'loadingSpinner': {},
	    'textTrackDisplay': {},
	    'bigPlayButton': {},
	    'controlBar': {},
	    'errorDisplay': {},
	    'textTrackSettings': {}
	  },

	  'language': document.getElementsByTagName('html')[0].getAttribute('lang') || navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',

	  // locales and their language translations
	  'languages': {},

	  // Default message to show when a video cannot be played.
	  'notSupportedMessage': 'No compatible source was found for this video.'
	};

	// Set CDN Version of swf
	// The added (+) blocks the replace from changing this GENERATED_CDN_VSN string
	if (vjs.CDN_VERSION !== 'GENERATED'+'_CDN_VSN') {
	  videojs.options['flash']['swf'] = vjs.ACCESS_PROTOCOL + 'vjs.zencdn.net/'+vjs.CDN_VERSION+'/video-js.swf';
	}

	/**
	 * Utility function for adding languages to the default options. Useful for
	 * amending multiple language support at runtime.
	 *
	 * Example: vjs.addLanguage('es', {'Hello':'Hola'});
	 *
	 * @param  {String} code The language code or dictionary property
	 * @param  {Object} data The data values to be translated
	 * @return {Object} The resulting global languages dictionary object
	 */
	vjs.addLanguage = function(code, data){
	  if(vjs.options['languages'][code] !== undefined) {
	    vjs.options['languages'][code] = vjs.util.mergeOptions(vjs.options['languages'][code], data);
	  } else {
	    vjs.options['languages'][code] = data;
	  }
	  return vjs.options['languages'];
	};

	/**
	 * Global player list
	 * @type {Object}
	 */
	vjs.players = {};

	/*!
	 * Custom Universal Module Definition (UMD)
	 *
	 * Video.js will never be a non-browser lib so we can simplify UMD a bunch and
	 * still support requirejs and browserify. This also needs to be closure
	 * compiler compatible, so string keys are used.
	 */
	if ("function" === 'function' && __webpack_require__(5)['amd']) {
	  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){ return videojs; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	// checking that module is an object too because of umdjs/umd#35
	} else if (true) {
	  module['exports'] = videojs;
	}

	/**
	 * Core Object/Class for objects that use inheritance + constructors
	 *
	 * To create a class that can be subclassed itself, extend the CoreObject class.
	 *
	 *     var Animal = CoreObject.extend();
	 *     var Horse = Animal.extend();
	 *
	 * The constructor can be defined through the init property of an object argument.
	 *
	 *     var Animal = CoreObject.extend({
	 *       init: function(name, sound){
	 *         this.name = name;
	 *       }
	 *     });
	 *
	 * Other methods and properties can be added the same way, or directly to the
	 * prototype.
	 *
	 *    var Animal = CoreObject.extend({
	 *       init: function(name){
	 *         this.name = name;
	 *       },
	 *       getName: function(){
	 *         return this.name;
	 *       },
	 *       sound: '...'
	 *    });
	 *
	 *    Animal.prototype.makeSound = function(){
	 *      alert(this.sound);
	 *    };
	 *
	 * To create an instance of a class, use the create method.
	 *
	 *    var fluffy = Animal.create('Fluffy');
	 *    fluffy.getName(); // -> Fluffy
	 *
	 * Methods and properties can be overridden in subclasses.
	 *
	 *     var Horse = Animal.extend({
	 *       sound: 'Neighhhhh!'
	 *     });
	 *
	 *     var horsey = Horse.create('Horsey');
	 *     horsey.getName(); // -> Horsey
	 *     horsey.makeSound(); // -> Alert: Neighhhhh!
	 *
	 * @class
	 * @constructor
	 */
	vjs.CoreObject = vjs['CoreObject'] = function(){};
	// Manually exporting vjs['CoreObject'] here for Closure Compiler
	// because of the use of the extend/create class methods
	// If we didn't do this, those functions would get flattened to something like
	// `a = ...` and `this.prototype` would refer to the global object instead of
	// CoreObject

	/**
	 * Create a new object that inherits from this Object
	 *
	 *     var Animal = CoreObject.extend();
	 *     var Horse = Animal.extend();
	 *
	 * @param {Object} props Functions and properties to be applied to the
	 *                       new object's prototype
	 * @return {vjs.CoreObject} An object that inherits from CoreObject
	 * @this {*}
	 */
	vjs.CoreObject.extend = function(props){
	  var init, subObj;

	  props = props || {};
	  // Set up the constructor using the supplied init method
	  // or using the init of the parent object
	  // Make sure to check the unobfuscated version for external libs
	  init = props['init'] || props.init || this.prototype['init'] || this.prototype.init || function(){};
	  // In Resig's simple class inheritance (previously used) the constructor
	  //  is a function that calls `this.init.apply(arguments)`
	  // However that would prevent us from using `ParentObject.call(this);`
	  //  in a Child constructor because the `this` in `this.init`
	  //  would still refer to the Child and cause an infinite loop.
	  // We would instead have to do
	  //    `ParentObject.prototype.init.apply(this, arguments);`
	  //  Bleh. We're not creating a _super() function, so it's good to keep
	  //  the parent constructor reference simple.
	  subObj = function(){
	    init.apply(this, arguments);
	  };

	  // Inherit from this object's prototype
	  subObj.prototype = vjs.obj.create(this.prototype);
	  // Reset the constructor property for subObj otherwise
	  // instances of subObj would have the constructor of the parent Object
	  subObj.prototype.constructor = subObj;

	  // Make the class extendable
	  subObj.extend = vjs.CoreObject.extend;
	  // Make a function for creating instances
	  subObj.create = vjs.CoreObject.create;

	  // Extend subObj's prototype with functions and other properties from props
	  for (var name in props) {
	    if (props.hasOwnProperty(name)) {
	      subObj.prototype[name] = props[name];
	    }
	  }

	  return subObj;
	};

	/**
	 * Create a new instance of this Object class
	 *
	 *     var myAnimal = Animal.create();
	 *
	 * @return {vjs.CoreObject} An instance of a CoreObject subclass
	 * @this {*}
	 */
	vjs.CoreObject.create = function(){
	  // Create a new object that inherits from this object's prototype
	  var inst = vjs.obj.create(this.prototype);

	  // Apply this constructor function to the new object
	  this.apply(inst, arguments);

	  // Return the new object
	  return inst;
	};

	/**
	 * @fileoverview Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
	 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
	 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
	 * robust as jquery's, so there's probably some differences.
	 */

	/**
	 * Add an event listener to element
	 * It stores the handler function in a separate cache object
	 * and adds a generic handler to the element's event,
	 * along with a unique id (guid) to the element.
	 * @param  {Element|Object}   elem Element or object to bind listeners to
	 * @param  {String|Array}   type Type of event to bind to.
	 * @param  {Function} fn   Event listener.
	 * @private
	 */
	vjs.on = function(elem, type, fn){
	  if (vjs.obj.isArray(type)) {
	    return _handleMultipleEvents(vjs.on, elem, type, fn);
	  }

	  var data = vjs.getData(elem);

	  // We need a place to store all our handler data
	  if (!data.handlers) data.handlers = {};

	  if (!data.handlers[type]) data.handlers[type] = [];

	  if (!fn.guid) fn.guid = vjs.guid++;

	  data.handlers[type].push(fn);

	  if (!data.dispatcher) {
	    data.disabled = false;

	    data.dispatcher = function (event){

	      if (data.disabled) return;
	      event = vjs.fixEvent(event);

	      var handlers = data.handlers[event.type];

	      if (handlers) {
	        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
	        var handlersCopy = handlers.slice(0);

	        for (var m = 0, n = handlersCopy.length; m < n; m++) {
	          if (event.isImmediatePropagationStopped()) {
	            break;
	          } else {
	            handlersCopy[m].call(elem, event);
	          }
	        }
	      }
	    };
	  }

	  if (data.handlers[type].length == 1) {
	    if (elem.addEventListener) {
	      elem.addEventListener(type, data.dispatcher, false);
	    } else if (elem.attachEvent) {
	      elem.attachEvent('on' + type, data.dispatcher);
	    }
	  }
	};

	/**
	 * Removes event listeners from an element
	 * @param  {Element|Object}   elem Object to remove listeners from
	 * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.
	 * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.
	 * @private
	 */
	vjs.off = function(elem, type, fn) {
	  // Don't want to add a cache object through getData if not needed
	  if (!vjs.hasData(elem)) return;

	  var data = vjs.getData(elem);

	  // If no events exist, nothing to unbind
	  if (!data.handlers) { return; }

	  if (vjs.obj.isArray(type)) {
	    return _handleMultipleEvents(vjs.off, elem, type, fn);
	  }

	  // Utility function
	  var removeType = function(t){
	     data.handlers[t] = [];
	     vjs.cleanUpEvents(elem,t);
	  };

	  // Are we removing all bound events?
	  if (!type) {
	    for (var t in data.handlers) removeType(t);
	    return;
	  }

	  var handlers = data.handlers[type];

	  // If no handlers exist, nothing to unbind
	  if (!handlers) return;

	  // If no listener was provided, remove all listeners for type
	  if (!fn) {
	    removeType(type);
	    return;
	  }

	  // We're only removing a single handler
	  if (fn.guid) {
	    for (var n = 0; n < handlers.length; n++) {
	      if (handlers[n].guid === fn.guid) {
	        handlers.splice(n--, 1);
	      }
	    }
	  }

	  vjs.cleanUpEvents(elem, type);
	};

	/**
	 * Clean up the listener cache and dispatchers
	 * @param  {Element|Object} elem Element to clean up
	 * @param  {String} type Type of event to clean up
	 * @private
	 */
	vjs.cleanUpEvents = function(elem, type) {
	  var data = vjs.getData(elem);

	  // Remove the events of a particular type if there are none left
	  if (data.handlers[type].length === 0) {
	    delete data.handlers[type];
	    // data.handlers[type] = null;
	    // Setting to null was causing an error with data.handlers

	    // Remove the meta-handler from the element
	    if (elem.removeEventListener) {
	      elem.removeEventListener(type, data.dispatcher, false);
	    } else if (elem.detachEvent) {
	      elem.detachEvent('on' + type, data.dispatcher);
	    }
	  }

	  // Remove the events object if there are no types left
	  if (vjs.isEmpty(data.handlers)) {
	    delete data.handlers;
	    delete data.dispatcher;
	    delete data.disabled;

	    // data.handlers = null;
	    // data.dispatcher = null;
	    // data.disabled = null;
	  }

	  // Finally remove the expando if there is no data left
	  if (vjs.isEmpty(data)) {
	    vjs.removeData(elem);
	  }
	};

	/**
	 * Fix a native event to have standard property values
	 * @param  {Object} event Event object to fix
	 * @return {Object}
	 * @private
	 */
	vjs.fixEvent = function(event) {

	  function returnTrue() { return true; }
	  function returnFalse() { return false; }

	  // Test if fixing up is needed
	  // Used to check if !event.stopPropagation instead of isPropagationStopped
	  // But native events return true for stopPropagation, but don't have
	  // other expected methods like isPropagationStopped. Seems to be a problem
	  // with the Javascript Ninja code. So we're just overriding all events now.
	  if (!event || !event.isPropagationStopped) {
	    var old = event || window.event;

	    event = {};
	    // Clone the old object so that we can modify the values event = {};
	    // IE8 Doesn't like when you mess with native event properties
	    // Firefox returns false for event.hasOwnProperty('type') and other props
	    //  which makes copying more difficult.
	    // TODO: Probably best to create a whitelist of event props
	    for (var key in old) {
	      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
	      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
	      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation') {
	        // Chrome 32+ warns if you try to copy deprecated returnValue, but
	        // we still want to if preventDefault isn't supported (IE8).
	        if (!(key == 'returnValue' && old.preventDefault)) {
	          event[key] = old[key];
	        }
	      }
	    }

	    // The event occurred on this element
	    if (!event.target) {
	      event.target = event.srcElement || document;
	    }

	    // Handle which other element the event is related to
	    event.relatedTarget = event.fromElement === event.target ?
	      event.toElement :
	      event.fromElement;

	    // Stop the default browser action
	    event.preventDefault = function () {
	      if (old.preventDefault) {
	        old.preventDefault();
	      }
	      event.returnValue = false;
	      event.isDefaultPrevented = returnTrue;
	      event.defaultPrevented = true;
	    };

	    event.isDefaultPrevented = returnFalse;
	    event.defaultPrevented = false;

	    // Stop the event from bubbling
	    event.stopPropagation = function () {
	      if (old.stopPropagation) {
	        old.stopPropagation();
	      }
	      event.cancelBubble = true;
	      event.isPropagationStopped = returnTrue;
	    };

	    event.isPropagationStopped = returnFalse;

	    // Stop the event from bubbling and executing other handlers
	    event.stopImmediatePropagation = function () {
	      if (old.stopImmediatePropagation) {
	        old.stopImmediatePropagation();
	      }
	      event.isImmediatePropagationStopped = returnTrue;
	      event.stopPropagation();
	    };

	    event.isImmediatePropagationStopped = returnFalse;

	    // Handle mouse position
	    if (event.clientX != null) {
	      var doc = document.documentElement, body = document.body;

	      event.pageX = event.clientX +
	        (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
	        (doc && doc.clientLeft || body && body.clientLeft || 0);
	      event.pageY = event.clientY +
	        (doc && doc.scrollTop || body && body.scrollTop || 0) -
	        (doc && doc.clientTop || body && body.clientTop || 0);
	    }

	    // Handle key presses
	    event.which = event.charCode || event.keyCode;

	    // Fix button for mouse clicks:
	    // 0 == left; 1 == middle; 2 == right
	    if (event.button != null) {
	      event.button = (event.button & 1 ? 0 :
	        (event.button & 4 ? 1 :
	          (event.button & 2 ? 2 : 0)));
	    }
	  }

	  // Returns fixed-up instance
	  return event;
	};

	/**
	 * Trigger an event for an element
	 * @param  {Element|Object}      elem  Element to trigger an event on
	 * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute
	 * @private
	 */
	vjs.trigger = function(elem, event) {
	  // Fetches element data and a reference to the parent (for bubbling).
	  // Don't want to add a data object to cache for every parent,
	  // so checking hasData first.
	  var elemData = (vjs.hasData(elem)) ? vjs.getData(elem) : {};
	  var parent = elem.parentNode || elem.ownerDocument;
	      // type = event.type || event,
	      // handler;

	  // If an event name was passed as a string, creates an event out of it
	  if (typeof event === 'string') {
	    event = { type:event, target:elem };
	  }
	  // Normalizes the event properties.
	  event = vjs.fixEvent(event);

	  // If the passed element has a dispatcher, executes the established handlers.
	  if (elemData.dispatcher) {
	    elemData.dispatcher.call(elem, event);
	  }

	  // Unless explicitly stopped or the event does not bubble (e.g. media events)
	    // recursively calls this function to bubble the event up the DOM.
	    if (parent && !event.isPropagationStopped() && event.bubbles !== false) {
	    vjs.trigger(parent, event);

	  // If at the top of the DOM, triggers the default action unless disabled.
	  } else if (!parent && !event.defaultPrevented) {
	    var targetData = vjs.getData(event.target);

	    // Checks if the target has a default action for this event.
	    if (event.target[event.type]) {
	      // Temporarily disables event dispatching on the target as we have already executed the handler.
	      targetData.disabled = true;
	      // Executes the default action.
	      if (typeof event.target[event.type] === 'function') {
	        event.target[event.type]();
	      }
	      // Re-enables event dispatching.
	      targetData.disabled = false;
	    }
	  }

	  // Inform the triggerer if the default was prevented by returning false
	  return !event.defaultPrevented;
	  /* Original version of js ninja events wasn't complete.
	   * We've since updated to the latest version, but keeping this around
	   * for now just in case.
	   */
	  // // Added in addition to book. Book code was broke.
	  // event = typeof event === 'object' ?
	  //   event[vjs.expando] ?
	  //     event :
	  //     new vjs.Event(type, event) :
	  //   new vjs.Event(type);

	  // event.type = type;
	  // if (handler) {
	  //   handler.call(elem, event);
	  // }

	  // // Clean up the event in case it is being reused
	  // event.result = undefined;
	  // event.target = elem;
	};

	/**
	 * Trigger a listener only once for an event
	 * @param  {Element|Object}   elem Element or object to
	 * @param  {String|Array}   type
	 * @param  {Function} fn
	 * @private
	 */
	vjs.one = function(elem, type, fn) {
	  if (vjs.obj.isArray(type)) {
	    return _handleMultipleEvents(vjs.one, elem, type, fn);
	  }
	  var func = function(){
	    vjs.off(elem, type, func);
	    fn.apply(this, arguments);
	  };
	  // copy the guid to the new function so it can removed using the original function's ID
	  func.guid = fn.guid = fn.guid || vjs.guid++;
	  vjs.on(elem, type, func);
	};

	/**
	 * Loops through an array of event types and calls the requested method for each type.
	 * @param  {Function} fn   The event method we want to use.
	 * @param  {Element|Object} elem Element or object to bind listeners to
	 * @param  {String}   type Type of event to bind to.
	 * @param  {Function} callback   Event listener.
	 * @private
	 */
	function _handleMultipleEvents(fn, elem, type, callback) {
	  vjs.arr.forEach(type, function(type) {
	    fn(elem, type, callback); //Call the event method for each one of the types
	  });
	}

	var hasOwnProp = Object.prototype.hasOwnProperty;

	/**
	 * Creates an element and applies properties.
	 * @param  {String=} tagName    Name of tag to be created.
	 * @param  {Object=} properties Element properties to be applied.
	 * @return {Element}
	 * @private
	 */
	vjs.createEl = function(tagName, properties){
	  var el;

	  tagName = tagName || 'div';
	  properties = properties || {};

	  el = document.createElement(tagName);

	  vjs.obj.each(properties, function(propName, val){
	    // Not remembering why we were checking for dash
	    // but using setAttribute means you have to use getAttribute

	    // The check for dash checks for the aria-* attributes, like aria-label, aria-valuemin.
	    // The additional check for "role" is because the default method for adding attributes does not
	    // add the attribute "role". My guess is because it's not a valid attribute in some namespaces, although
	    // browsers handle the attribute just fine. The W3C allows for aria-* attributes to be used in pre-HTML5 docs.
	    // http://www.w3.org/TR/wai-aria-primer/#ariahtml. Using setAttribute gets around this problem.
	    if (propName.indexOf('aria-') !== -1 || propName == 'role') {
	     el.setAttribute(propName, val);
	    } else {
	     el[propName] = val;
	    }
	  });

	  return el;
	};

	/**
	 * Uppercase the first letter of a string
	 * @param  {String} string String to be uppercased
	 * @return {String}
	 * @private
	 */
	vjs.capitalize = function(string){
	  return string.charAt(0).toUpperCase() + string.slice(1);
	};

	/**
	 * Object functions container
	 * @type {Object}
	 * @private
	 */
	vjs.obj = {};

	/**
	 * Object.create shim for prototypal inheritance
	 *
	 * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
	 *
	 * @function
	 * @param  {Object}   obj Object to use as prototype
	 * @private
	 */
	vjs.obj.create = Object.create || function(obj){
	  //Create a new function called 'F' which is just an empty object.
	  function F() {}

	  //the prototype of the 'F' function should point to the
	  //parameter of the anonymous function.
	  F.prototype = obj;

	  //create a new constructor function based off of the 'F' function.
	  return new F();
	};

	/**
	 * Loop through each property in an object and call a function
	 * whose arguments are (key,value)
	 * @param  {Object}   obj Object of properties
	 * @param  {Function} fn  Function to be called on each property.
	 * @this {*}
	 * @private
	 */
	vjs.obj.each = function(obj, fn, context){
	  for (var key in obj) {
	    if (hasOwnProp.call(obj, key)) {
	      fn.call(context || this, key, obj[key]);
	    }
	  }
	};

	/**
	 * Merge two objects together and return the original.
	 * @param  {Object} obj1
	 * @param  {Object} obj2
	 * @return {Object}
	 * @private
	 */
	vjs.obj.merge = function(obj1, obj2){
	  if (!obj2) { return obj1; }
	  for (var key in obj2){
	    if (hasOwnProp.call(obj2, key)) {
	      obj1[key] = obj2[key];
	    }
	  }
	  return obj1;
	};

	/**
	 * Merge two objects, and merge any properties that are objects
	 * instead of just overwriting one. Uses to merge options hashes
	 * where deeper default settings are important.
	 * @param  {Object} obj1 Object to override
	 * @param  {Object} obj2 Overriding object
	 * @return {Object}      New object. Obj1 and Obj2 will be untouched.
	 * @private
	 */
	vjs.obj.deepMerge = function(obj1, obj2){
	  var key, val1, val2;

	  // make a copy of obj1 so we're not overwriting original values.
	  // like prototype.options_ and all sub options objects
	  obj1 = vjs.obj.copy(obj1);

	  for (key in obj2){
	    if (hasOwnProp.call(obj2, key)) {
	      val1 = obj1[key];
	      val2 = obj2[key];

	      // Check if both properties are pure objects and do a deep merge if so
	      if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
	        obj1[key] = vjs.obj.deepMerge(val1, val2);
	      } else {
	        obj1[key] = obj2[key];
	      }
	    }
	  }
	  return obj1;
	};

	/**
	 * Make a copy of the supplied object
	 * @param  {Object} obj Object to copy
	 * @return {Object}     Copy of object
	 * @private
	 */
	vjs.obj.copy = function(obj){
	  return vjs.obj.merge({}, obj);
	};

	/**
	 * Check if an object is plain, and not a dom node or any object sub-instance
	 * @param  {Object} obj Object to check
	 * @return {Boolean}     True if plain, false otherwise
	 * @private
	 */
	vjs.obj.isPlain = function(obj){
	  return !!obj
	    && typeof obj === 'object'
	    && obj.toString() === '[object Object]'
	    && obj.constructor === Object;
	};

	/**
	 * Check if an object is Array
	*  Since instanceof Array will not work on arrays created in another frame we need to use Array.isArray, but since IE8 does not support Array.isArray we need this shim
	 * @param  {Object} obj Object to check
	 * @return {Boolean}     True if plain, false otherwise
	 * @private
	 */
	vjs.obj.isArray = Array.isArray || function(arr) {
	  return Object.prototype.toString.call(arr) === '[object Array]';
	};

	/**
	 * Check to see whether the input is NaN or not.
	 * NaN is the only JavaScript construct that isn't equal to itself
	 * @param {Number} num Number to check
	 * @return {Boolean} True if NaN, false otherwise
	 * @private
	 */
	vjs.isNaN = function(num) {
	  return num !== num;
	};

	/**
	 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
	   It also stores a unique id on the function so it can be easily removed from events
	 * @param  {*}   context The object to bind as scope
	 * @param  {Function} fn      The function to be bound to a scope
	 * @param  {Number=}   uid     An optional unique ID for the function to be set
	 * @return {Function}
	 * @private
	 */
	vjs.bind = function(context, fn, uid) {
	  // Make sure the function has a unique ID
	  if (!fn.guid) { fn.guid = vjs.guid++; }

	  // Create the new function that changes the context
	  var ret = function() {
	    return fn.apply(context, arguments);
	  };

	  // Allow for the ability to individualize this function
	  // Needed in the case where multiple objects might share the same prototype
	  // IF both items add an event listener with the same function, then you try to remove just one
	  // it will remove both because they both have the same guid.
	  // when using this, you need to use the bind method when you remove the listener as well.
	  // currently used in text tracks
	  ret.guid = (uid) ? uid + '_' + fn.guid : fn.guid;

	  return ret;
	};

	/**
	 * Element Data Store. Allows for binding data to an element without putting it directly on the element.
	 * Ex. Event listeners are stored here.
	 * (also from jsninja.com, slightly modified and updated for closure compiler)
	 * @type {Object}
	 * @private
	 */
	vjs.cache = {};

	/**
	 * Unique ID for an element or function
	 * @type {Number}
	 * @private
	 */
	vjs.guid = 1;

	/**
	 * Unique attribute name to store an element's guid in
	 * @type {String}
	 * @constant
	 * @private
	 */
	vjs.expando = 'vdata' + (new Date()).getTime();

	/**
	 * Returns the cache object where data for an element is stored
	 * @param  {Element} el Element to store data for.
	 * @return {Object}
	 * @private
	 */
	vjs.getData = function(el){
	  var id = el[vjs.expando];
	  if (!id) {
	    id = el[vjs.expando] = vjs.guid++;
	  }
	  if (!vjs.cache[id]) {
	    vjs.cache[id] = {};
	  }
	  return vjs.cache[id];
	};

	/**
	 * Returns the cache object where data for an element is stored
	 * @param  {Element} el Element to store data for.
	 * @return {Object}
	 * @private
	 */
	vjs.hasData = function(el){
	  var id = el[vjs.expando];
	  return !(!id || vjs.isEmpty(vjs.cache[id]));
	};

	/**
	 * Delete data for the element from the cache and the guid attr from getElementById
	 * @param  {Element} el Remove data for an element
	 * @private
	 */
	vjs.removeData = function(el){
	  var id = el[vjs.expando];
	  if (!id) { return; }
	  // Remove all stored data
	  // Changed to = null
	  // http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/
	  // vjs.cache[id] = null;
	  delete vjs.cache[id];

	  // Remove the expando property from the DOM node
	  try {
	    delete el[vjs.expando];
	  } catch(e) {
	    if (el.removeAttribute) {
	      el.removeAttribute(vjs.expando);
	    } else {
	      // IE doesn't appear to support removeAttribute on the document element
	      el[vjs.expando] = null;
	    }
	  }
	};

	/**
	 * Check if an object is empty
	 * @param  {Object}  obj The object to check for emptiness
	 * @return {Boolean}
	 * @private
	 */
	vjs.isEmpty = function(obj) {
	  for (var prop in obj) {
	    // Inlude null properties as empty.
	    if (obj[prop] !== null) {
	      return false;
	    }
	  }
	  return true;
	};

	/**
	 * Check if an element has a CSS class
	 * @param {Element} element Element to check
	 * @param {String} classToCheck Classname to check
	 * @private
	 */
	vjs.hasClass = function(element, classToCheck){
	  try{
	    if(element){
	      return ((' ' + element.className + ' ').indexOf(' ' + classToCheck + ' ') !== -1);
	    } else{
	       vjs.log('Error in hasClass, element does not exist');
	    }
	  } catch(e){
	    vjs.log('Exception in hasClass', e);
	  }
	};


	/**
	 * Add a CSS class name to an element
	 * @param {Element} element    Element to add class name to
	 * @param {String} classToAdd Classname to add
	 * @private
	 */
	vjs.addClass = function(element, classToAdd){
	  try{
	    if (element && !vjs.hasClass(element, classToAdd)) {
	      element.className = element.className === '' ? classToAdd : element.className + ' ' + classToAdd;
	    } else {
	      vjs.log('Error in addClass, class or element doesn\'t exist');
	    }
	  } catch(e){
	     vjs.log('Exception in addClass', e);
	  }
	};

	/**
	 * Remove a CSS class name from an element
	 * @param {Element} element    Element to remove from class name
	 * @param {String} classToAdd Classname to remove
	 * @private
	 */
	vjs.removeClass = function(element, classToRemove){
	  var classNames, i;

	  if (!vjs.hasClass(element, classToRemove)) {return;}

	  classNames = element.className.split(' ');

	  // no arr.indexOf in ie8, and we don't want to add a big shim
	  for (i = classNames.length - 1; i >= 0; i--) {
	    if (classNames[i] === classToRemove) {
	      classNames.splice(i,1);
	    }
	  }

	  element.className = classNames.join(' ');
	};

	/**
	 * Element for testing browser HTML5 video capabilities
	 * @type {Element}
	 * @constant
	 * @private
	 */
	vjs.TEST_VID = vjs.createEl('video');
	(function() {
	  var track = document.createElement('track');
	  track.kind = 'captions';
	  track.srclang = 'en';
	  track.label = 'English';
	  vjs.TEST_VID.appendChild(track);
	})();

	/**
	 * Useragent for browser testing.
	 * @type {String}
	 * @constant
	 * @private
	 */
	vjs.USER_AGENT = navigator.userAgent;

	/**
	 * Device is an iPhone
	 * @type {Boolean}
	 * @constant
	 * @private
	 */
	vjs.IS_IPHONE = (/iPhone/i).test(vjs.USER_AGENT);
	vjs.IS_IPAD = (/iPad/i).test(vjs.USER_AGENT);
	vjs.IS_IPOD = (/iPod/i).test(vjs.USER_AGENT);
	vjs.IS_IOS = vjs.IS_IPHONE || vjs.IS_IPAD || vjs.IS_IPOD;

	vjs.IOS_VERSION = (function(){
	  var match = vjs.USER_AGENT.match(/OS (\d+)_/i);
	  if (match && match[1]) { return match[1]; }
	})();

	vjs.IS_ANDROID = (/Android/i).test(vjs.USER_AGENT);
	vjs.ANDROID_VERSION = (function() {
	  // This matches Android Major.Minor.Patch versions
	  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
	  var match = vjs.USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i),
	    major,
	    minor;

	  if (!match) {
	    return null;
	  }

	  major = match[1] && parseFloat(match[1]);
	  minor = match[2] && parseFloat(match[2]);

	  if (major && minor) {
	    return parseFloat(match[1] + '.' + match[2]);
	  } else if (major) {
	    return major;
	  } else {
	    return null;
	  }
	})();
	// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
	vjs.IS_OLD_ANDROID = vjs.IS_ANDROID && (/webkit/i).test(vjs.USER_AGENT) && vjs.ANDROID_VERSION < 2.3;

	vjs.IS_FIREFOX = (/Firefox/i).test(vjs.USER_AGENT);
	vjs.IS_CHROME = (/Chrome/i).test(vjs.USER_AGENT);
	vjs.IS_IE8 = (/MSIE\s8\.0/).test(vjs.USER_AGENT);

	vjs.TOUCH_ENABLED = !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch);
	vjs.BACKGROUND_SIZE_SUPPORTED = 'backgroundSize' in vjs.TEST_VID.style;

	/**
	 * Apply attributes to an HTML element.
	 * @param  {Element} el         Target element.
	 * @param  {Object=} attributes Element attributes to be applied.
	 * @private
	 */
	vjs.setElementAttributes = function(el, attributes){
	  vjs.obj.each(attributes, function(attrName, attrValue) {
	    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
	      el.removeAttribute(attrName);
	    } else {
	      el.setAttribute(attrName, (attrValue === true ? '' : attrValue));
	    }
	  });
	};

	/**
	 * Get an element's attribute values, as defined on the HTML tag
	 * Attributes are not the same as properties. They're defined on the tag
	 * or with setAttribute (which shouldn't be used with HTML)
	 * This will return true or false for boolean attributes.
	 * @param  {Element} tag Element from which to get tag attributes
	 * @return {Object}
	 * @private
	 */
	vjs.getElementAttributes = function(tag){
	  var obj, knownBooleans, attrs, attrName, attrVal;

	  obj = {};

	  // known boolean attributes
	  // we can check for matching boolean properties, but older browsers
	  // won't know about HTML5 boolean attributes that we still read from
	  knownBooleans = ','+'autoplay,controls,loop,muted,default'+',';

	  if (tag && tag.attributes && tag.attributes.length > 0) {
	    attrs = tag.attributes;

	    for (var i = attrs.length - 1; i >= 0; i--) {
	      attrName = attrs[i].name;
	      attrVal = attrs[i].value;

	      // check for known booleans
	      // the matching element property will return a value for typeof
	      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(','+attrName+',') !== -1) {
	        // the value of an included boolean attribute is typically an empty
	        // string ('') which would equal false if we just check for a false value.
	        // we also don't want support bad code like autoplay='false'
	        attrVal = (attrVal !== null) ? true : false;
	      }

	      obj[attrName] = attrVal;
	    }
	  }

	  return obj;
	};

	/**
	 * Get the computed style value for an element
	 * From http://robertnyman.com/2006/04/24/get-the-rendered-style-of-an-element/
	 * @param  {Element} el        Element to get style value for
	 * @param  {String} strCssRule Style name
	 * @return {String}            Style value
	 * @private
	 */
	vjs.getComputedDimension = function(el, strCssRule){
	  var strValue = '';
	  if(document.defaultView && document.defaultView.getComputedStyle){
	    strValue = document.defaultView.getComputedStyle(el, '').getPropertyValue(strCssRule);

	  } else if(el.currentStyle){
	    // IE8 Width/Height support
	    strValue = el['client'+strCssRule.substr(0,1).toUpperCase() + strCssRule.substr(1)] + 'px';
	  }
	  return strValue;
	};

	/**
	 * Insert an element as the first child node of another
	 * @param  {Element} child   Element to insert
	 * @param  {[type]} parent Element to insert child into
	 * @private
	 */
	vjs.insertFirst = function(child, parent){
	  if (parent.firstChild) {
	    parent.insertBefore(child, parent.firstChild);
	  } else {
	    parent.appendChild(child);
	  }
	};

	/**
	 * Object to hold browser support information
	 * @type {Object}
	 * @private
	 */
	vjs.browser = {};

	/**
	 * Shorthand for document.getElementById()
	 * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.
	 * @param  {String} id  Element ID
	 * @return {Element}    Element with supplied ID
	 * @private
	 */
	vjs.el = function(id){
	  if (id.indexOf('#') === 0) {
	    id = id.slice(1);
	  }

	  return document.getElementById(id);
	};

	/**
	 * Format seconds as a time string, H:MM:SS or M:SS
	 * Supplying a guide (in seconds) will force a number of leading zeros
	 * to cover the length of the guide
	 * @param  {Number} seconds Number of seconds to be turned into a string
	 * @param  {Number} guide   Number (in seconds) to model the string after
	 * @return {String}         Time formatted as H:MM:SS or M:SS
	 * @private
	 */
	vjs.formatTime = function(seconds, guide) {
	  // Default to using seconds as guide
	  guide = guide || seconds;
	  var s = Math.floor(seconds % 60),
	      m = Math.floor(seconds / 60 % 60),
	      h = Math.floor(seconds / 3600),
	      gm = Math.floor(guide / 60 % 60),
	      gh = Math.floor(guide / 3600);

	  // handle invalid times
	  if (isNaN(seconds) || seconds === Infinity) {
	    // '-' is false for all relational operators (e.g. <, >=) so this setting
	    // will add the minimum number of fields specified by the guide
	    h = m = s = '-';
	  }

	  // Check if we need to show hours
	  h = (h > 0 || gh > 0) ? h + ':' : '';

	  // If hours are showing, we may need to add a leading zero.
	  // Always show at least one digit of minutes.
	  m = (((h || gm >= 10) && m < 10) ? '0' + m : m) + ':';

	  // Check if leading zero is need for seconds
	  s = (s < 10) ? '0' + s : s;

	  return h + m + s;
	};

	// Attempt to block the ability to select text while dragging controls
	vjs.blockTextSelection = function(){
	  document.body.focus();
	  document.onselectstart = function () { return false; };
	};
	// Turn off text selection blocking
	vjs.unblockTextSelection = function(){ document.onselectstart = function () { return true; }; };

	/**
	 * Trim whitespace from the ends of a string.
	 * @param  {String} string String to trim
	 * @return {String}        Trimmed string
	 * @private
	 */
	vjs.trim = function(str){
	  return (str+'').replace(/^\s+|\s+$/g, '');
	};

	/**
	 * Should round off a number to a decimal place
	 * @param  {Number} num Number to round
	 * @param  {Number} dec Number of decimal places to round to
	 * @return {Number}     Rounded number
	 * @private
	 */
	vjs.round = function(num, dec) {
	  if (!dec) { dec = 0; }
	  return Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);
	};

	/**
	 * Should create a fake TimeRange object
	 * Mimics an HTML5 time range instance, which has functions that
	 * return the start and end times for a range
	 * TimeRanges are returned by the buffered() method
	 * @param  {Number} start Start time in seconds
	 * @param  {Number} end   End time in seconds
	 * @return {Object}       Fake TimeRange object
	 * @private
	 */
	vjs.createTimeRange = function(start, end){
	  if (start === undefined && end === undefined) {
	    return {
	      length: 0,
	      start: function() {
	        throw new Error('This TimeRanges object is empty');
	      },
	      end: function() {
	        throw new Error('This TimeRanges object is empty');
	      }
	    };
	  }

	  return {
	    length: 1,
	    start: function() { return start; },
	    end: function() { return end; }
	  };
	};

	/**
	 * Add to local storage (may removable)
	 * @private
	 */
	vjs.setLocalStorage = function(key, value){
	  try {
	    // IE was throwing errors referencing the var anywhere without this
	    var localStorage = window.localStorage || false;
	    if (!localStorage) { return; }
	    localStorage[key] = value;
	  } catch(e) {
	    if (e.code == 22 || e.code == 1014) { // Webkit == 22 / Firefox == 1014
	      vjs.log('LocalStorage Full (VideoJS)', e);
	    } else {
	      if (e.code == 18) {
	        vjs.log('LocalStorage not allowed (VideoJS)', e);
	      } else {
	        vjs.log('LocalStorage Error (VideoJS)', e);
	      }
	    }
	  }
	};

	/**
	 * Get absolute version of relative URL. Used to tell flash correct URL.
	 * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
	 * @param  {String} url URL to make absolute
	 * @return {String}     Absolute URL
	 * @private
	 */
	vjs.getAbsoluteURL = function(url){

	  // Check if absolute URL
	  if (!url.match(/^https?:\/\//)) {
	    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
	    url = vjs.createEl('div', {
	      innerHTML: '<a href="'+url+'">x</a>'
	    }).firstChild.href;
	  }

	  return url;
	};


	/**
	 * Resolve and parse the elements of a URL
	 * @param  {String} url The url to parse
	 * @return {Object}     An object of url details
	 */
	vjs.parseUrl = function(url) {
	  var div, a, addToBody, props, details;

	  props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

	  // add the url to an anchor and let the browser parse the URL
	  a = vjs.createEl('a', { href: url });

	  // IE8 (and 9?) Fix
	  // ie8 doesn't parse the URL correctly until the anchor is actually
	  // added to the body, and an innerHTML is needed to trigger the parsing
	  addToBody = (a.host === '' && a.protocol !== 'file:');
	  if (addToBody) {
	    div = vjs.createEl('div');
	    div.innerHTML = '<a href="'+url+'"></a>';
	    a = div.firstChild;
	    // prevent the div from affecting layout
	    div.setAttribute('style', 'display:none; position:absolute;');
	    document.body.appendChild(div);
	  }

	  // Copy the specific URL properties to a new object
	  // This is also needed for IE8 because the anchor loses its
	  // properties when it's removed from the dom
	  details = {};
	  for (var i = 0; i < props.length; i++) {
	    details[props[i]] = a[props[i]];
	  }

	  // IE9 adds the port to the host property unlike everyone else. If
	  // a port identifier is added for standard ports, strip it.
	  if (details.protocol === 'http:') {
	    details.host = details.host.replace(/:80$/, '');
	  }
	  if (details.protocol === 'https:') {
	    details.host = details.host.replace(/:443$/, '');
	  }

	  if (addToBody) {
	    document.body.removeChild(div);
	  }

	  return details;
	};

	/**
	 * Log messages to the console and history based on the type of message
	 *
	 * @param  {String} type The type of message, or `null` for `log`
	 * @param  {[type]} args The args to be passed to the log
	 * @private
	 */
	function _logType(type, args){

	    return;//TODO minthe to block all video.js log

	  var argsArray, noop, console;

	  // convert args to an array to get array functions
	  argsArray = Array.prototype.slice.call(args);
	  // if there's no console then don't try to output messages
	  // they will still be stored in vjs.log.history
	  // Was setting these once outside of this function, but containing them
	  // in the function makes it easier to test cases where console doesn't exist
	  noop = function(){};
	  console = window['console'] || {
	    'log': noop,
	    'warn': noop,
	    'error': noop
	  };

	  if (type) {
	    // add the type to the front of the message
	    argsArray.unshift(type.toUpperCase()+':');
	  } else {
	    // default to log with no prefix
	    type = 'log';
	  }

	  // add to history
	  vjs.log.history.push(argsArray);

	  // add console prefix after adding to history
	  argsArray.unshift('VIDEOJS:');

	  // call appropriate log function
	  if (console[type].apply) {
	    console[type].apply(console, argsArray);
	  } else {
	    // ie8 doesn't allow error.apply, but it will just join() the array anyway
	    console[type](argsArray.join(' '));
	  }
	}

	/**
	 * Log plain debug messages
	 */
	vjs.log = function(){
	  _logType(null, arguments);
	};

	/**
	 * Keep a history of log messages
	 * @type {Array}
	 */
	vjs.log.history = [];

	/**
	 * Log error messages
	 */
	vjs.log.error = function(){
	  _logType('error', arguments);
	};

	/**
	 * Log warning messages
	 */
	vjs.log.warn = function(){
	  _logType('warn', arguments);
	};

	// Offset Left
	// getBoundingClientRect technique from John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/
	vjs.findPosition = function(el) {
	  var box, docEl, body, clientLeft, scrollLeft, left, clientTop, scrollTop, top;

	  if (el.getBoundingClientRect && el.parentNode) {
	    box = el.getBoundingClientRect();
	  }

	  if (!box) {
	    return {
	      left: 0,
	      top: 0
	    };
	  }

	  docEl = document.documentElement;
	  body = document.body;

	  clientLeft = docEl.clientLeft || body.clientLeft || 0;
	  scrollLeft = window.pageXOffset || body.scrollLeft;
	  left = box.left + scrollLeft - clientLeft;

	  clientTop = docEl.clientTop || body.clientTop || 0;
	  scrollTop = window.pageYOffset || body.scrollTop;
	  top = box.top + scrollTop - clientTop;

	  // Android sometimes returns slightly off decimal values, so need to round
	  return {
	    left: vjs.round(left),
	    top: vjs.round(top)
	  };
	};

	/**
	 * Array functions container
	 * @type {Object}
	 * @private
	 */
	vjs.arr = {};

	/*
	 * Loops through an array and runs a function for each item inside it.
	 * @param  {Array}    array       The array
	 * @param  {Function} callback    The function to be run for each item
	 * @param  {*}        thisArg     The `this` binding of callback
	 * @returns {Array}               The array
	 * @private
	 */
	vjs.arr.forEach = function(array, callback, thisArg) {
	  if (vjs.obj.isArray(array) && callback instanceof Function) {
	    for (var i = 0, len = array.length; i < len; ++i) {
	      callback.call(thisArg || vjs, array[i], i, array);
	    }
	  }

	  return array;
	};

	/**
	 * Utility functions namespace
	 * @namespace
	 * @type {Object}
	 */
	vjs.util = {};

	/**
	 * Merge two options objects, recursively merging any plain object properties as
	 * well.  Previously `deepMerge`
	 *
	 * @param  {Object} obj1 Object to override values in
	 * @param  {Object} obj2 Overriding object
	 * @return {Object}      New object -- obj1 and obj2 will be untouched
	 */
	vjs.util.mergeOptions = function(obj1, obj2){
	  var key, val1, val2;

	  // make a copy of obj1 so we're not overwriting original values.
	  // like prototype.options_ and all sub options objects
	  obj1 = vjs.obj.copy(obj1);

	  for (key in obj2){
	    if (obj2.hasOwnProperty(key)) {
	      val1 = obj1[key];
	      val2 = obj2[key];

	      // Check if both properties are pure objects and do a deep merge if so
	      if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
	        obj1[key] = vjs.util.mergeOptions(val1, val2);
	      } else {
	        obj1[key] = obj2[key];
	      }
	    }
	  }
	  return obj1;
	};
	vjs.EventEmitter = function() {
	};

	vjs.EventEmitter.prototype.allowedEvents_ = {
	};

	vjs.EventEmitter.prototype.on = function(type, fn) {
	  // Remove the addEventListener alias before calling vjs.on
	  // so we don't get into an infinite type loop
	  var ael = this.addEventListener;
	  this.addEventListener = Function.prototype;
	  vjs.on(this, type, fn);
	  this.addEventListener = ael;
	};
	vjs.EventEmitter.prototype.addEventListener = vjs.EventEmitter.prototype.on;

	vjs.EventEmitter.prototype.off = function(type, fn) {
	  vjs.off(this, type, fn);
	};
	vjs.EventEmitter.prototype.removeEventListener = vjs.EventEmitter.prototype.off;

	vjs.EventEmitter.prototype.one = function(type, fn) {
	  vjs.one(this, type, fn);
	};

	vjs.EventEmitter.prototype.trigger = function(event) {
	  var type = event.type || event;

	  if (typeof event === 'string') {
	    event = {
	      type: type
	    };
	  }
	  event = vjs.fixEvent(event);

	  if (this.allowedEvents_[type] && this['on' + type]) {
	    this['on' + type](event);
	  }

	  vjs.trigger(this, event);
	};
	// The standard DOM EventTarget.dispatchEvent() is aliased to trigger()
	vjs.EventEmitter.prototype.dispatchEvent = vjs.EventEmitter.prototype.trigger;

	/**
	 * @fileoverview Player Component - Base class for all UI objects
	 *
	 */

	/**
	 * Base UI Component class
	 *
	 * Components are embeddable UI objects that are represented by both a
	 * javascript object and an element in the DOM. They can be children of other
	 * components, and can have many children themselves.
	 *
	 *     // adding a button to the player
	 *     var button = player.addChild('button');
	 *     button.el(); // -> button element
	 *
	 *     <div class="video-js">
	 *       <div class="vjs-button">Button</div>
	 *     </div>
	 *
	 * Components are also event emitters.
	 *
	 *     button.on('click', function(){
	 *       console.log('Button Clicked!');
	 *     });
	 *
	 *     button.trigger('customevent');
	 *
	 * @param {Object} player  Main Player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 * @extends vjs.CoreObject
	 */
	vjs.Component = vjs.CoreObject.extend({
	  /**
	   * the constructor function for the class
	   *
	   * @constructor
	   */
	  init: function(player, options, ready){
	    this.player_ = player;

	    // Make a copy of prototype.options_ to protect against overriding global defaults
	    this.options_ = vjs.obj.copy(this.options_);

	    // Updated options with supplied options
	    options = this.options(options);

	    // Get ID from options or options element if one is supplied
	    this.id_ = options['id'] || (options['el'] && options['el']['id']);

	    // If there was no ID from the options, generate one
	    if (!this.id_) {
	      // Don't require the player ID function in the case of mock players
	      this.id_ = ((player.id && player.id()) || 'no_player') + '_component_' + vjs.guid++;
	    }

	    this.name_ = options['name'] || null;

	    // Create element if one wasn't provided in options
	    this.el_ = options['el'] || this.createEl();

	    this.children_ = [];
	    this.childIndex_ = {};
	    this.childNameIndex_ = {};

	    // Add any child components in options
	    this.initChildren();

	    this.ready(ready);
	    // Don't want to trigger ready here or it will before init is actually
	    // finished for all children that run this constructor

	    if (options.reportTouchActivity !== false) {
	      this.enableTouchActivity();
	    }
	  }
	});

	/**
	 * Dispose of the component and all child components
	 */
	vjs.Component.prototype.dispose = function(){
	  this.trigger({ type: 'dispose', 'bubbles': false });

	  // Dispose all children.
	  if (this.children_) {
	    for (var i = this.children_.length - 1; i >= 0; i--) {
	      if (this.children_[i].dispose) {
	        this.children_[i].dispose();
	      }
	    }
	  }

	  // Delete child references
	  this.children_ = null;
	  this.childIndex_ = null;
	  this.childNameIndex_ = null;

	  // Remove all event listeners.
	  this.off();

	  // Remove element from DOM
	  if (this.el_.parentNode) {
	    this.el_.parentNode.removeChild(this.el_);
	  }

	  vjs.removeData(this.el_);
	  this.el_ = null;
	};

	/**
	 * Reference to main player instance
	 *
	 * @type {vjs.Player}
	 * @private
	 */
	vjs.Component.prototype.player_ = true;

	/**
	 * Return the component's player
	 *
	 * @return {vjs.Player}
	 */
	vjs.Component.prototype.player = function(){
	  return this.player_;
	};

	/**
	 * The component's options object
	 *
	 * @type {Object}
	 * @private
	 */
	vjs.Component.prototype.options_;

	/**
	 * Deep merge of options objects
	 *
	 * Whenever a property is an object on both options objects
	 * the two properties will be merged using vjs.obj.deepMerge.
	 *
	 * This is used for merging options for child components. We
	 * want it to be easy to override individual options on a child
	 * component without having to rewrite all the other default options.
	 *
	 *     Parent.prototype.options_ = {
	 *       children: {
	 *         'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },
	 *         'childTwo': {},
	 *         'childThree': {}
	 *       }
	 *     }
	 *     newOptions = {
	 *       children: {
	 *         'childOne': { 'foo': 'baz', 'abc': '123' }
	 *         'childTwo': null,
	 *         'childFour': {}
	 *       }
	 *     }
	 *
	 *     this.options(newOptions);
	 *
	 * RESULT
	 *
	 *     {
	 *       children: {
	 *         'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },
	 *         'childTwo': null, // Disabled. Won't be initialized.
	 *         'childThree': {},
	 *         'childFour': {}
	 *       }
	 *     }
	 *
	 * @param  {Object} obj Object of new option values
	 * @return {Object}     A NEW object of this.options_ and obj merged
	 */
	vjs.Component.prototype.options = function(obj){
	  if (obj === undefined) return this.options_;

	  return this.options_ = vjs.util.mergeOptions(this.options_, obj);
	};

	/**
	 * The DOM element for the component
	 *
	 * @type {Element}
	 * @private
	 */
	vjs.Component.prototype.el_;

	/**
	 * Create the component's DOM element
	 *
	 * @param  {String=} tagName  Element's node type. e.g. 'div'
	 * @param  {Object=} attributes An object of element attributes that should be set on the element
	 * @return {Element}
	 */
	vjs.Component.prototype.createEl = function(tagName, attributes){
	  return vjs.createEl(tagName, attributes);
	};

	vjs.Component.prototype.localize = function(string){
	  var lang = this.player_.language(),
	      languages = this.player_.languages();
	  if (languages && languages[lang] && languages[lang][string]) {
	    return languages[lang][string];
	  }
	  return string;
	};

	/**
	 * Get the component's DOM element
	 *
	 *     var domEl = myComponent.el();
	 *
	 * @return {Element}
	 */
	vjs.Component.prototype.el = function(){
	  return this.el_;
	};

	/**
	 * An optional element where, if defined, children will be inserted instead of
	 * directly in `el_`
	 *
	 * @type {Element}
	 * @private
	 */
	vjs.Component.prototype.contentEl_;

	/**
	 * Return the component's DOM element for embedding content.
	 * Will either be el_ or a new element defined in createEl.
	 *
	 * @return {Element}
	 */
	vjs.Component.prototype.contentEl = function(){
	  return this.contentEl_ || this.el_;
	};

	/**
	 * The ID for the component
	 *
	 * @type {String}
	 * @private
	 */
	vjs.Component.prototype.id_;

	/**
	 * Get the component's ID
	 *
	 *     var id = myComponent.id();
	 *
	 * @return {String}
	 */
	vjs.Component.prototype.id = function(){
	  return this.id_;
	};

	/**
	 * The name for the component. Often used to reference the component.
	 *
	 * @type {String}
	 * @private
	 */
	vjs.Component.prototype.name_;

	/**
	 * Get the component's name. The name is often used to reference the component.
	 *
	 *     var name = myComponent.name();
	 *
	 * @return {String}
	 */
	vjs.Component.prototype.name = function(){
	  return this.name_;
	};

	/**
	 * Array of child components
	 *
	 * @type {Array}
	 * @private
	 */
	vjs.Component.prototype.children_;

	/**
	 * Get an array of all child components
	 *
	 *     var kids = myComponent.children();
	 *
	 * @return {Array} The children
	 */
	vjs.Component.prototype.children = function(){
	  return this.children_;
	};

	/**
	 * Object of child components by ID
	 *
	 * @type {Object}
	 * @private
	 */
	vjs.Component.prototype.childIndex_;

	/**
	 * Returns a child component with the provided ID
	 *
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.getChildById = function(id){
	  return this.childIndex_[id];
	};

	/**
	 * Object of child components by name
	 *
	 * @type {Object}
	 * @private
	 */
	vjs.Component.prototype.childNameIndex_;

	/**
	 * Returns a child component with the provided name
	 *
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.getChild = function(name){
	  return this.childNameIndex_[name];
	};

	/**
	 * Adds a child component inside this component
	 *
	 *     myComponent.el();
	 *     // -> <div class='my-component'></div>
	 *     myComonent.children();
	 *     // [empty array]
	 *
	 *     var myButton = myComponent.addChild('MyButton');
	 *     // -> <div class='my-component'><div class="my-button">myButton<div></div>
	 *     // -> myButton === myComonent.children()[0];
	 *
	 * Pass in options for child constructors and options for children of the child
	 *
	 *     var myButton = myComponent.addChild('MyButton', {
	 *       text: 'Press Me',
	 *       children: {
	 *         buttonChildExample: {
	 *           buttonChildOption: true
	 *         }
	 *       }
	 *     });
	 *
	 * @param {String|vjs.Component} child The class name or instance of a child to add
	 * @param {Object=} options Options, including options to be passed to children of the child.
	 * @return {vjs.Component} The child component (created by this process if a string was used)
	 * @suppress {accessControls|checkRegExp|checkTypes|checkVars|const|constantProperty|deprecated|duplicate|es5Strict|fileoverviewTags|globalThis|invalidCasts|missingProperties|nonStandardJsDocs|strictModuleDepCheck|undefinedNames|undefinedVars|unknownDefines|uselessCode|visibility}
	 */
	vjs.Component.prototype.addChild = function(child, options){
	  var component, componentClass, componentName;

	  // If child is a string, create new component with options
	  if (typeof child === 'string') {
	    componentName = child;

	    // Make sure options is at least an empty object to protect against errors
	    options = options || {};

	    // If no componentClass in options, assume componentClass is the name lowercased
	    // (e.g. playButton)
	    componentClass = options['componentClass'] || vjs.capitalize(componentName);

	    // Set name through options
	    options['name'] = componentName;

	    // Create a new object & element for this controls set
	    // If there's no .player_, this is a player
	    // Closure Compiler throws an 'incomplete alias' warning if we use the vjs variable directly.
	    // Every class should be exported, so this should never be a problem here.
	    component = new window['videojs_apn'][componentClass](this.player_ || this, options);

	  // child is a component instance
	  } else {
	    component = child;
	  }

	  this.children_.push(component);

	  if (typeof component.id === 'function') {
	    this.childIndex_[component.id()] = component;
	  }

	  // If a name wasn't used to create the component, check if we can use the
	  // name function of the component
	  componentName = componentName || (component.name && component.name());

	  if (componentName) {
	    this.childNameIndex_[componentName] = component;
	  }

	  // Add the UI object's element to the container div (box)
	  // Having an element is not required
	  if (typeof component['el'] === 'function' && component['el']()) {
	    this.contentEl().appendChild(component['el']());
	  }

	  // Return so it can stored on parent object if desired.
	  return component;
	};

	/**
	 * Remove a child component from this component's list of children, and the
	 * child component's element from this component's element
	 *
	 * @param  {vjs.Component} component Component to remove
	 */
	vjs.Component.prototype.removeChild = function(component){
	  if (typeof component === 'string') {
	    component = this.getChild(component);
	  }

	  if (!component || !this.children_) return;

	  var childFound = false;
	  for (var i = this.children_.length - 1; i >= 0; i--) {
	    if (this.children_[i] === component) {
	      childFound = true;
	      this.children_.splice(i,1);
	      break;
	    }
	  }

	  if (!childFound) return;

	  this.childIndex_[component.id()] = null;
	  this.childNameIndex_[component.name()] = null;

	  var compEl = component.el();
	  if (compEl && compEl.parentNode === this.contentEl()) {
	    this.contentEl().removeChild(component.el());
	  }
	};

	/**
	 * Add and initialize default child components from options
	 *
	 *     // when an instance of MyComponent is created, all children in options
	 *     // will be added to the instance by their name strings and options
	 *     MyComponent.prototype.options_.children = {
	 *       myChildComponent: {
	 *         myChildOption: true
	 *       }
	 *     }
	 *
	 *     // Or when creating the component
	 *     var myComp = new MyComponent(player, {
	 *       children: {
	 *         myChildComponent: {
	 *           myChildOption: true
	 *         }
	 *       }
	 *     });
	 *
	 * The children option can also be an Array of child names or
	 * child options objects (that also include a 'name' key).
	 *
	 *     var myComp = new MyComponent(player, {
	 *       children: [
	 *         'button',
	 *         {
	 *           name: 'button',
	 *           someOtherOption: true
	 *         }
	 *       ]
	 *     });
	 *
	 */
	vjs.Component.prototype.initChildren = function(){
	  var parent, parentOptions, children, child, name, opts, handleAdd;

	  parent = this;
	  parentOptions = parent.options();
	  children = parentOptions['children'];

	  if (children) {
	    handleAdd = function(name, opts){
	      // Allow options for children to be set at the parent options
	      // e.g. videojs(id, { controlBar: false });
	      // instead of videojs(id, { children: { controlBar: false });
	      if (parentOptions[name] !== undefined) {
	        opts = parentOptions[name];
	      }

	      // Allow for disabling default components
	      // e.g. vjs.options['children']['posterImage'] = false
	      if (opts === false) return;

	      // Create and add the child component.
	      // Add a direct reference to the child by name on the parent instance.
	      // If two of the same component are used, different names should be supplied
	      // for each
	      parent[name] = parent.addChild(name, opts);
	    };

	    // Allow for an array of children details to passed in the options
	    if (vjs.obj.isArray(children)) {
	      for (var i = 0; i < children.length; i++) {
	        child = children[i];

	        if (typeof child == 'string') {
	          // ['myComponent']
	          name = child;
	          opts = {};
	        } else {
	          // [{ name: 'myComponent', otherOption: true }]
	          name = child.name;
	          opts = child;
	        }

	        handleAdd(name, opts);
	      }
	    } else {
	      vjs.obj.each(children, handleAdd);
	    }
	  }
	};

	/**
	 * Allows sub components to stack CSS class names
	 *
	 * @return {String} The constructed class name
	 */
	vjs.Component.prototype.buildCSSClass = function(){
	    // Child classes can include a function that does:
	    // return 'CLASS NAME' + this._super();
	    return '';
	};

	/* Events
	============================================================================= */

	/**
	 * Add an event listener to this component's element
	 *
	 *     var myFunc = function(){
	 *       var myComponent = this;
	 *       // Do something when the event is fired
	 *     };
	 *
	 *     myComponent.on('eventType', myFunc);
	 *
	 * The context of myFunc will be myComponent unless previously bound.
	 *
	 * Alternatively, you can add a listener to another element or component.
	 *
	 *     myComponent.on(otherElement, 'eventName', myFunc);
	 *     myComponent.on(otherComponent, 'eventName', myFunc);
	 *
	 * The benefit of using this over `vjs.on(otherElement, 'eventName', myFunc)`
	 * and `otherComponent.on('eventName', myFunc)` is that this way the listeners
	 * will be automatically cleaned up when either component is disposed.
	 * It will also bind myComponent as the context of myFunc.
	 *
	 * **NOTE**: When using this on elements in the page other than window
	 * and document (both permanent), if you remove the element from the DOM
	 * you need to call `vjs.trigger(el, 'dispose')` on it to clean up
	 * references to it and allow the browser to garbage collect it.
	 *
	 * @param  {String|vjs.Component} first   The event type or other component
	 * @param  {Function|String}      second  The event handler or event type
	 * @param  {Function}             third   The event handler
	 * @return {vjs.Component}        self
	 */
	vjs.Component.prototype.on = function(first, second, third){
	  var target, type, fn, removeOnDispose, cleanRemover, thisComponent;

	  if (typeof first === 'string' || vjs.obj.isArray(first)) {
	    vjs.on(this.el_, first, vjs.bind(this, second));

	  // Targeting another component or element
	  } else {
	    target = first;
	    type = second;
	    fn = vjs.bind(this, third);
	    thisComponent = this;

	    // When this component is disposed, remove the listener from the other component
	    removeOnDispose = function(){
	      thisComponent.off(target, type, fn);
	    };
	    // Use the same function ID so we can remove it later it using the ID
	    // of the original listener
	    removeOnDispose.guid = fn.guid;
	    this.on('dispose', removeOnDispose);

	    // If the other component is disposed first we need to clean the reference
	    // to the other component in this component's removeOnDispose listener
	    // Otherwise we create a memory leak.
	    cleanRemover = function(){
	      thisComponent.off('dispose', removeOnDispose);
	    };
	    // Add the same function ID so we can easily remove it later
	    cleanRemover.guid = fn.guid;

	    // Check if this is a DOM node
	    if (first.nodeName) {
	      // Add the listener to the other element
	      vjs.on(target, type, fn);
	      vjs.on(target, 'dispose', cleanRemover);

	    // Should be a component
	    // Not using `instanceof vjs.Component` because it makes mock players difficult
	    } else if (typeof first.on === 'function') {
	      // Add the listener to the other component
	      target.on(type, fn);
	      target.on('dispose', cleanRemover);
	    }
	  }

	  return this;
	};

	/**
	 * Remove an event listener from this component's element
	 *
	 *     myComponent.off('eventType', myFunc);
	 *
	 * If myFunc is excluded, ALL listeners for the event type will be removed.
	 * If eventType is excluded, ALL listeners will be removed from the component.
	 *
	 * Alternatively you can use `off` to remove listeners that were added to other
	 * elements or components using `myComponent.on(otherComponent...`.
	 * In this case both the event type and listener function are REQUIRED.
	 *
	 *     myComponent.off(otherElement, 'eventType', myFunc);
	 *     myComponent.off(otherComponent, 'eventType', myFunc);
	 *
	 * @param  {String=|vjs.Component}  first  The event type or other component
	 * @param  {Function=|String}       second The listener function or event type
	 * @param  {Function=}              third  The listener for other component
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.off = function(first, second, third){
	  var target, otherComponent, type, fn, otherEl;

	  if (!first || typeof first === 'string' || vjs.obj.isArray(first)) {
	    vjs.off(this.el_, first, second);
	  } else {
	    target = first;
	    type = second;
	    // Ensure there's at least a guid, even if the function hasn't been used
	    fn = vjs.bind(this, third);

	    // Remove the dispose listener on this component,
	    // which was given the same guid as the event listener
	    this.off('dispose', fn);

	    if (first.nodeName) {
	      // Remove the listener
	      vjs.off(target, type, fn);
	      // Remove the listener for cleaning the dispose listener
	      vjs.off(target, 'dispose', fn);
	    } else {
	      target.off(type, fn);
	      target.off('dispose', fn);
	    }
	  }

	  return this;
	};

	/**
	 * Add an event listener to be triggered only once and then removed
	 *
	 *     myComponent.one('eventName', myFunc);
	 *
	 * Alternatively you can add a listener to another element or component
	 * that will be triggered only once.
	 *
	 *     myComponent.one(otherElement, 'eventName', myFunc);
	 *     myComponent.one(otherComponent, 'eventName', myFunc);
	 *
	 * @param  {String|vjs.Component}  first   The event type or other component
	 * @param  {Function|String}       second  The listener function or event type
	 * @param  {Function=}             third   The listener function for other component
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.one = function(first, second, third) {
	  var target, type, fn, thisComponent, newFunc;

	  if (typeof first === 'string' || vjs.obj.isArray(first)) {
	    vjs.one(this.el_, first, vjs.bind(this, second));
	  } else {
	    target = first;
	    type = second;
	    fn = vjs.bind(this, third);
	    thisComponent = this;

	    newFunc = function(){
	      thisComponent.off(target, type, newFunc);
	      fn.apply(this, arguments);
	    };
	    // Keep the same function ID so we can remove it later
	    newFunc.guid = fn.guid;

	    this.on(target, type, newFunc);
	  }

	  return this;
	};

	/**
	 * Trigger an event on an element
	 *
	 *     myComponent.trigger('eventName');
	 *     myComponent.trigger({'type':'eventName'});
	 *
	 * @param  {Event|Object|String} event  A string (the type) or an event object with a type attribute
	 * @return {vjs.Component}       self
	 */
	vjs.Component.prototype.trigger = function(event){
	  vjs.trigger(this.el_, event);
	  return this;
	};

	/* Ready
	================================================================================ */
	/**
	 * Is the component loaded
	 * This can mean different things depending on the component.
	 *
	 * @private
	 * @type {Boolean}
	 */
	vjs.Component.prototype.isReady_;

	/**
	 * Trigger ready as soon as initialization is finished
	 *
	 * Allows for delaying ready. Override on a sub class prototype.
	 * If you set this.isReadyOnInitFinish_ it will affect all components.
	 * Specially used when waiting for the Flash player to asynchronously load.
	 *
	 * @type {Boolean}
	 * @private
	 */
	vjs.Component.prototype.isReadyOnInitFinish_ = true;

	/**
	 * List of ready listeners
	 *
	 * @type {Array}
	 * @private
	 */
	vjs.Component.prototype.readyQueue_;

	/**
	 * Bind a listener to the component's ready state
	 *
	 * Different from event listeners in that if the ready event has already happened
	 * it will trigger the function immediately.
	 *
	 * @param  {Function} fn Ready listener
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.ready = function(fn){
	  if (fn) {
	    if (this.isReady_) {
	      fn.call(this);
	    } else {
	      if (this.readyQueue_ === undefined) {
	        this.readyQueue_ = [];
	      }
	      this.readyQueue_.push(fn);
	    }
	  }
	  return this;
	};

	/**
	 * Trigger the ready listeners
	 *
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.triggerReady = function(){
	  this.isReady_ = true;

	  var readyQueue = this.readyQueue_;

	  if (readyQueue && readyQueue.length > 0) {

	    for (var i = 0, j = readyQueue.length; i < j; i++) {
	      readyQueue[i].call(this);
	    }

	    // Reset Ready Queue
	    this.readyQueue_ = [];

	    // Allow for using event listeners also, in case you want to do something everytime a source is ready.
	    this.trigger('ready');
	  }
	};

	/* Display
	============================================================================= */

	/**
	 * Check if a component's element has a CSS class name
	 *
	 * @param {String} classToCheck Classname to check
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.hasClass = function(classToCheck){
	  return vjs.hasClass(this.el_, classToCheck);
	};

	/**
	 * Add a CSS class name to the component's element
	 *
	 * @param {String} classToAdd Classname to add
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.addClass = function(classToAdd){
	  vjs.addClass(this.el_, classToAdd);
	  return this;
	};

	/**
	 * Remove a CSS class name from the component's element
	 *
	 * @param {String} classToRemove Classname to remove
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.removeClass = function(classToRemove){
	  vjs.removeClass(this.el_, classToRemove);
	  return this;
	};

	/**
	 * Show the component element if hidden
	 *
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.show = function(){
	  this.removeClass('vjs-hidden');
	  return this;
	};

	/**
	 * Hide the component element if currently showing
	 *
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.hide = function(){
	  this.addClass('vjs-hidden');
	  return this;
	};

	/**
	 * Lock an item in its visible state
	 * To be used with fadeIn/fadeOut.
	 *
	 * @return {vjs.Component}
	 * @private
	 */
	vjs.Component.prototype.lockShowing = function(){
	  this.addClass('vjs-lock-showing');
	  return this;
	};

	/**
	 * Unlock an item to be hidden
	 * To be used with fadeIn/fadeOut.
	 *
	 * @return {vjs.Component}
	 * @private
	 */
	vjs.Component.prototype.unlockShowing = function(){
	  this.removeClass('vjs-lock-showing');
	  return this;
	};

	/**
	 * Disable component by making it unshowable
	 *
	 * Currently private because we're moving towards more css-based states.
	 * @private
	 */
	vjs.Component.prototype.disable = function(){
	  this.hide();
	  this.show = function(){};
	};

	/**
	 * Set or get the width of the component (CSS values)
	 *
	 * Setting the video tag dimension values only works with values in pixels.
	 * Percent values will not work.
	 * Some percents can be used, but width()/height() will return the number + %,
	 * not the actual computed width/height.
	 *
	 * @param  {Number|String=} num   Optional width number
	 * @param  {Boolean} skipListeners Skip the 'resize' event trigger
	 * @return {vjs.Component} This component, when setting the width
	 * @return {Number|String} The width, when getting
	 */
	vjs.Component.prototype.width = function(num, skipListeners){
	  return this.dimension('width', num, skipListeners);
	};

	/**
	 * Get or set the height of the component (CSS values)
	 *
	 * Setting the video tag dimension values only works with values in pixels.
	 * Percent values will not work.
	 * Some percents can be used, but width()/height() will return the number + %,
	 * not the actual computed width/height.
	 *
	 * @param  {Number|String=} num     New component height
	 * @param  {Boolean=} skipListeners Skip the resize event trigger
	 * @return {vjs.Component} This component, when setting the height
	 * @return {Number|String} The height, when getting
	 */
	vjs.Component.prototype.height = function(num, skipListeners){
	  return this.dimension('height', num, skipListeners);
	};

	/**
	 * Set both width and height at the same time
	 *
	 * @param  {Number|String} width
	 * @param  {Number|String} height
	 * @return {vjs.Component} The component
	 */
	vjs.Component.prototype.dimensions = function(width, height){
	  // Skip resize listeners on width for optimization
	  return this.width(width, true).height(height);
	};

	/**
	 * Get or set width or height
	 *
	 * This is the shared code for the width() and height() methods.
	 * All for an integer, integer + 'px' or integer + '%';
	 *
	 * Known issue: Hidden elements officially have a width of 0. We're defaulting
	 * to the style.width value and falling back to computedStyle which has the
	 * hidden element issue. Info, but probably not an efficient fix:
	 * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/
	 *
	 * @param  {String} widthOrHeight  'width' or 'height'
	 * @param  {Number|String=} num     New dimension
	 * @param  {Boolean=} skipListeners Skip resize event trigger
	 * @return {vjs.Component} The component if a dimension was set
	 * @return {Number|String} The dimension if nothing was set
	 * @private
	 */
	vjs.Component.prototype.dimension = function(widthOrHeight, num, skipListeners){
	  if (num !== undefined) {
	    if (num === null || vjs.isNaN(num)) {
	      num = 0;
	    }

	    // Check if using css width/height (% or px) and adjust
	    if ((''+num).indexOf('%') !== -1 || (''+num).indexOf('px') !== -1) {
	      this.el_.style[widthOrHeight] = num;
	    } else if (num === 'auto') {
	      this.el_.style[widthOrHeight] = '';
	    } else {
	      this.el_.style[widthOrHeight] = num+'px';
	    }

	    // skipListeners allows us to avoid triggering the resize event when setting both width and height
	    if (!skipListeners) { this.trigger('resize'); }

	    // Return component
	    return this;
	  }

	  // Not setting a value, so getting it
	  // Make sure element exists
	  if (!this.el_) return 0;

	  // Get dimension value from style
	  var val = this.el_.style[widthOrHeight];
	  var pxIndex = val.indexOf('px');
	  if (pxIndex !== -1) {
	    // Return the pixel value with no 'px'
	    return parseInt(val.slice(0,pxIndex), 10);

	  // No px so using % or no style was set, so falling back to offsetWidth/height
	  // If component has display:none, offset will return 0
	  // TODO: handle display:none and no dimension style using px
	  } else {

	    return parseInt(this.el_['offset'+vjs.capitalize(widthOrHeight)], 10);

	    // ComputedStyle version.
	    // Only difference is if the element is hidden it will return
	    // the percent value (e.g. '100%'')
	    // instead of zero like offsetWidth returns.
	    // var val = vjs.getComputedStyleValue(this.el_, widthOrHeight);
	    // var pxIndex = val.indexOf('px');

	    // if (pxIndex !== -1) {
	    //   return val.slice(0, pxIndex);
	    // } else {
	    //   return val;
	    // }
	  }
	};

	/**
	 * Fired when the width and/or height of the component changes
	 * @event resize
	 */
	vjs.Component.prototype.onResize;

	/**
	 * Emit 'tap' events when touch events are supported
	 *
	 * This is used to support toggling the controls through a tap on the video.
	 *
	 * We're requiring them to be enabled because otherwise every component would
	 * have this extra overhead unnecessarily, on mobile devices where extra
	 * overhead is especially bad.
	 * @private
	 */
	vjs.Component.prototype.emitTapEvents = function(){
	  var touchStart, firstTouch, touchTime, couldBeTap, noTap,
	      xdiff, ydiff, touchDistance, tapMovementThreshold, touchTimeThreshold;

	  // Track the start time so we can determine how long the touch lasted
	  touchStart = 0;
	  firstTouch = null;

	  // Maximum movement allowed during a touch event to still be considered a tap
	  // Other popular libs use anywhere from 2 (hammer.js) to 15, so 10 seems like a nice, round number.
	  tapMovementThreshold = 10;

	  // The maximum length a touch can be while still being considered a tap
	  touchTimeThreshold = 200;

	  this.on('touchstart', function(event) {
	    // If more than one finger, don't consider treating this as a click
	    if (event.touches.length === 1) {
	      firstTouch = vjs.obj.copy(event.touches[0]);
	      // Record start time so we can detect a tap vs. "touch and hold"
	      touchStart = new Date().getTime();
	      // Reset couldBeTap tracking
	      couldBeTap = true;
	    }
	  });

	  this.on('touchmove', function(event) {
	    // If more than one finger, don't consider treating this as a click
	    if (event.touches.length > 1) {
	      couldBeTap = false;
	    } else if (firstTouch) {
	      // Some devices will throw touchmoves for all but the slightest of taps.
	      // So, if we moved only a small distance, this could still be a tap
	      xdiff = event.touches[0].pageX - firstTouch.pageX;
	      ydiff = event.touches[0].pageY - firstTouch.pageY;
	      touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
	      if (touchDistance > tapMovementThreshold) {
	        couldBeTap = false;
	      }
	    }
	  });

	  noTap = function(){
	    couldBeTap = false;
	  };
	  // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
	  this.on('touchleave', noTap);
	  this.on('touchcancel', noTap);

	  // When the touch ends, measure how long it took and trigger the appropriate
	  // event
	  this.on('touchend', function(event) {
	    firstTouch = null;
	    // Proceed only if the touchmove/leave/cancel event didn't happen
	    if (couldBeTap === true) {
	      // Measure how long the touch lasted
	      touchTime = new Date().getTime() - touchStart;
	      // Make sure the touch was less than the threshold to be considered a tap
	      if (touchTime < touchTimeThreshold) {
	        event.preventDefault(); // Don't let browser turn this into a click
	        this.trigger('tap');
	        // It may be good to copy the touchend event object and change the
	        // type to tap, if the other event properties aren't exact after
	        // vjs.fixEvent runs (e.g. event.target)
	      }
	    }
	  });
	};

	/**
	 * Report user touch activity when touch events occur
	 *
	 * User activity is used to determine when controls should show/hide. It's
	 * relatively simple when it comes to mouse events, because any mouse event
	 * should show the controls. So we capture mouse events that bubble up to the
	 * player and report activity when that happens.
	 *
	 * With touch events it isn't as easy. We can't rely on touch events at the
	 * player level, because a tap (touchstart + touchend) on the video itself on
	 * mobile devices is meant to turn controls off (and on). User activity is
	 * checked asynchronously, so what could happen is a tap event on the video
	 * turns the controls off, then the touchend event bubbles up to the player,
	 * which if it reported user activity, would turn the controls right back on.
	 * (We also don't want to completely block touch events from bubbling up)
	 *
	 * Also a touchmove, touch+hold, and anything other than a tap is not supposed
	 * to turn the controls back on on a mobile device.
	 *
	 * Here we're setting the default component behavior to report user activity
	 * whenever touch events happen, and this can be turned off by components that
	 * want touch events to act differently.
	 */
	vjs.Component.prototype.enableTouchActivity = function() {
	  var report, touchHolding, touchEnd;

	  // Don't continue if the root player doesn't support reporting user activity
	  if (!this.player().reportUserActivity) {
	    return;
	  }

	  // listener for reporting that the user is active
	  report = vjs.bind(this.player(), this.player().reportUserActivity);

	  this.on('touchstart', function() {
	    report();
	    // For as long as the they are touching the device or have their mouse down,
	    // we consider them active even if they're not moving their finger or mouse.
	    // So we want to continue to update that they are active
	    this.clearInterval(touchHolding);
	    // report at the same interval as activityCheck
	    touchHolding = this.setInterval(report, 250);
	  });

	  touchEnd = function(event) {
	    report();
	    // stop the interval that maintains activity if the touch is holding
	    this.clearInterval(touchHolding);
	  };

	  this.on('touchmove', report);
	  this.on('touchend', touchEnd);
	  this.on('touchcancel', touchEnd);
	};

	/**
	 * Creates timeout and sets up disposal automatically.
	 * @param {Function} fn The function to run after the timeout.
	 * @param {Number} timeout Number of ms to delay before executing specified function.
	 * @return {Number} Returns the timeout ID
	 */
	vjs.Component.prototype.setTimeout = function(fn, timeout) {
	  fn = vjs.bind(this, fn);

	  // window.setTimeout would be preferable here, but due to some bizarre issue with Sinon and/or Phantomjs, we can't.
	  var timeoutId = setTimeout(fn, timeout);

	  var disposeFn = function() {
	    this.clearTimeout(timeoutId);
	  };

	  disposeFn.guid = 'vjs-timeout-'+ timeoutId;

	  this.on('dispose', disposeFn);

	  return timeoutId;
	};


	/**
	 * Clears a timeout and removes the associated dispose listener
	 * @param {Number} timeoutId The id of the timeout to clear
	 * @return {Number} Returns the timeout ID
	 */
	vjs.Component.prototype.clearTimeout = function(timeoutId) {
	  clearTimeout(timeoutId);

	  var disposeFn = function(){};
	  disposeFn.guid = 'vjs-timeout-'+ timeoutId;

	  this.off('dispose', disposeFn);

	  return timeoutId;
	};

	/**
	 * Creates an interval and sets up disposal automatically.
	 * @param {Function} fn The function to run every N seconds.
	 * @param {Number} interval Number of ms to delay before executing specified function.
	 * @return {Number} Returns the interval ID
	 */
	vjs.Component.prototype.setInterval = function(fn, interval) {
	  fn = vjs.bind(this, fn);

	  var intervalId = setInterval(fn, interval);

	  var disposeFn = function() {
	    this.clearInterval(intervalId);
	  };

	  disposeFn.guid = 'vjs-interval-'+ intervalId;

	  this.on('dispose', disposeFn);

	  return intervalId;
	};

	/**
	 * Clears an interval and removes the associated dispose listener
	 * @param {Number} intervalId The id of the interval to clear
	 * @return {Number} Returns the interval ID
	 */
	vjs.Component.prototype.clearInterval = function(intervalId) {
	  clearInterval(intervalId);

	  var disposeFn = function(){};
	  disposeFn.guid = 'vjs-interval-'+ intervalId;

	  this.off('dispose', disposeFn);

	  return intervalId;
	};

	/* Button - Base class for all buttons
	================================================================================ */
	/**
	 * Base class for all buttons
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.Button = vjs.Component.extend({
	  /**
	   * @constructor
	   * @inheritDoc
	   */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    this.emitTapEvents();

	    this.on('tap', this.onClick);
	    this.on('click', this.onClick);
	    this.on('focus', this.onFocus);
	    this.on('blur', this.onBlur);
	  }
	});

	vjs.Button.prototype.createEl = function(type, props){
	  var el;

	  // Add standard Aria and Tabindex info
	  props = vjs.obj.merge({
	    className: this.buildCSSClass(),
	    'role': 'button',
	    'aria-live': 'polite', // let the screen reader user know that the text of the button may change
	    tabIndex: 0
	  }, props);

	  el = vjs.Component.prototype.createEl.call(this, type, props);

	  // if innerHTML hasn't been overridden (bigPlayButton), add content elements
	  if (!props.innerHTML) {
	    this.contentEl_ = vjs.createEl('div', {
	      className: 'vjs-control-content'
	    });

	    this.controlText_ = vjs.createEl('span', {
	      className: 'vjs-control-text',
	      innerHTML: this.localize(this.buttonText) || 'Need Text'
	    });

	    this.contentEl_.appendChild(this.controlText_);
	    el.appendChild(this.contentEl_);
	  }

	  return el;
	};

	vjs.Button.prototype.buildCSSClass = function(){
	  // TODO: Change vjs-control to vjs-button?
	  return 'vjs-control ' + vjs.Component.prototype.buildCSSClass.call(this);
	};

	  // Click - Override with specific functionality for button
	vjs.Button.prototype.onClick = function(){};

	  // Focus - Add keyboard functionality to element
	vjs.Button.prototype.onFocus = function(){
	  vjs.on(document, 'keydown', vjs.bind(this, this.onKeyPress));
	};

	  // KeyPress (document level) - Trigger click when keys are pressed
	vjs.Button.prototype.onKeyPress = function(event){
	  // Check for space bar (32) or enter (13) keys
	  if (event.which == 32 || event.which == 13) {
	    event.preventDefault();
	    this.onClick();
	  }
	};

	// Blur - Remove keyboard triggers
	vjs.Button.prototype.onBlur = function(){
	  vjs.off(document, 'keydown', vjs.bind(this, this.onKeyPress));
	};

	/* Slider
	================================================================================ */
	/**
	 * The base functionality for sliders like the volume bar and seek bar
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.Slider = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    // Set property names to bar and handle to match with the child Slider class is looking for
	    this.bar = this.getChild(this.options_['barName']);
	    this.handle = this.getChild(this.options_['handleName']);

	    this.on('mousedown', this.onMouseDown);
	    this.on('touchstart', this.onMouseDown);
	    this.on('focus', this.onFocus);
	    this.on('blur', this.onBlur);
	    this.on('click', this.onClick);

	    this.on(player, 'controlsvisible', this.update);
	    this.on(player, this.playerEvent, this.update);
	  }
	});

	vjs.Slider.prototype.createEl = function(type, props) {
	  props = props || {};
	  // Add the slider element class to all sub classes
	  props.className = props.className + ' vjs-slider';
	  props = vjs.obj.merge({
	    'role': 'slider',
	    'aria-valuenow': 0,
	    'aria-valuemin': 0,
	    'aria-valuemax': 100,
	    tabIndex: 0
	  }, props);

	  return vjs.Component.prototype.createEl.call(this, type, props);
	};

	vjs.Slider.prototype.onMouseDown = function(event){
	  event.preventDefault();
	  vjs.blockTextSelection();
	  this.addClass('vjs-sliding');

	  this.on(document, 'mousemove', this.onMouseMove);
	  this.on(document, 'mouseup', this.onMouseUp);
	  this.on(document, 'touchmove', this.onMouseMove);
	  this.on(document, 'touchend', this.onMouseUp);

	  this.onMouseMove(event);
	};

	// To be overridden by a subclass
	vjs.Slider.prototype.onMouseMove = function(){};

	vjs.Slider.prototype.onMouseUp = function() {
	  vjs.unblockTextSelection();
	  this.removeClass('vjs-sliding');

	  this.off(document, 'mousemove', this.onMouseMove);
	  this.off(document, 'mouseup', this.onMouseUp);
	  this.off(document, 'touchmove', this.onMouseMove);
	  this.off(document, 'touchend', this.onMouseUp);

	  this.update();
	};

	vjs.Slider.prototype.update = function(){
	  // In VolumeBar init we have a setTimeout for update that pops and update to the end of the
	  // execution stack. The player is destroyed before then update will cause an error
	  if (!this.el_) return;

	  // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.
	  // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.
	  // var progress =  (this.player_.scrubbing) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();

	  var barProgress,
	      progress = this.getPercent(),
	      handle = this.handle,
	      bar = this.bar;

	  // Protect against no duration and other division issues
	  if (typeof progress !== 'number' ||
	      progress !== progress ||
	      progress < 0 ||
	      progress === Infinity) {
	        progress = 0;
	  }

	  barProgress = progress;

	  // If there is a handle, we need to account for the handle in our calculation for progress bar
	  // so that it doesn't fall short of or extend past the handle.
	  if (handle) {

	    var box = this.el_,
	        boxWidth = box.offsetWidth,

	        handleWidth = handle.el().offsetWidth,

	        // The width of the handle in percent of the containing box
	        // In IE, widths may not be ready yet causing NaN
	        handlePercent = (handleWidth) ? handleWidth / boxWidth : 0,

	        // Get the adjusted size of the box, considering that the handle's center never touches the left or right side.
	        // There is a margin of half the handle's width on both sides.
	        boxAdjustedPercent = 1 - handlePercent,

	        // Adjust the progress that we'll use to set widths to the new adjusted box width
	        adjustedProgress = progress * boxAdjustedPercent;

	    // The bar does reach the left side, so we need to account for this in the bar's width
	    barProgress = adjustedProgress + (handlePercent / 2);

	    // Move the handle from the left based on the adjected progress
	    handle.el().style.left = vjs.round(adjustedProgress * 100, 2) + '%';
	  }

	  // Set the new bar width
	  if (bar) {
	    bar.el().style.width = vjs.round(barProgress * 100, 2) + '%';
	  }
	};

	vjs.Slider.prototype.calculateDistance = function(event){
	  var el, box, boxX, boxY, boxW, boxH, handle, pageX, pageY;

	  el = this.el_;
	  box = vjs.findPosition(el);
	  boxW = boxH = el.offsetWidth;
	  handle = this.handle;

	  if (this.options()['vertical']) {
	    boxY = box.top;

	    if (event.changedTouches) {
	      pageY = event.changedTouches[0].pageY;
	    } else {
	      pageY = event.pageY;
	    }

	    if (handle) {
	      var handleH = handle.el().offsetHeight;
	      // Adjusted X and Width, so handle doesn't go outside the bar
	      boxY = boxY + (handleH / 2);
	      boxH = boxH - handleH;
	    }

	    // Percent that the click is through the adjusted area
	    return Math.max(0, Math.min(1, ((boxY - pageY) + boxH) / boxH));

	  } else {
	    boxX = box.left;

	    if (event.changedTouches) {
	      pageX = event.changedTouches[0].pageX;
	    } else {
	      pageX = event.pageX;
	    }

	    if (handle) {
	      var handleW = handle.el().offsetWidth;

	      // Adjusted X and Width, so handle doesn't go outside the bar
	      boxX = boxX + (handleW / 2);
	      boxW = boxW - handleW;
	    }

	    // Percent that the click is through the adjusted area
	    return Math.max(0, Math.min(1, (pageX - boxX) / boxW));
	  }
	};

	vjs.Slider.prototype.onFocus = function(){
	  this.on(document, 'keydown', this.onKeyPress);
	};

	vjs.Slider.prototype.onKeyPress = function(event){
	  if (event.which == 37 || event.which == 40) { // Left and Down Arrows
	    event.preventDefault();
	    this.stepBack();
	  } else if (event.which == 38 || event.which == 39) { // Up and Right Arrows
	    event.preventDefault();
	    this.stepForward();
	  }
	};

	vjs.Slider.prototype.onBlur = function(){
	  this.off(document, 'keydown', this.onKeyPress);
	};

	/**
	 * Listener for click events on slider, used to prevent clicks
	 *   from bubbling up to parent elements like button menus.
	 * @param  {Object} event Event object
	 */
	vjs.Slider.prototype.onClick = function(event){
	  event.stopImmediatePropagation();
	  event.preventDefault();
	};

	/**
	 * SeekBar Behavior includes play progress bar, and seek handle
	 * Needed so it can determine seek position based on handle position/size
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.SliderHandle = vjs.Component.extend();

	/**
	 * Default value of the slider
	 *
	 * @type {Number}
	 * @private
	 */
	vjs.SliderHandle.prototype.defaultValue = 0;

	/** @inheritDoc */
	vjs.SliderHandle.prototype.createEl = function(type, props) {
	  props = props || {};
	  // Add the slider element class to all sub classes
	  props.className = props.className + ' vjs-slider-handle';
	  props = vjs.obj.merge({
	    innerHTML: '<span class="vjs-control-text">'+this.defaultValue+'</span>'
	  }, props);

	  return vjs.Component.prototype.createEl.call(this, 'div', props);
	};

	/* Menu
	================================================================================ */
	/**
	 * The Menu component is used to build pop up menus, including subtitle and
	 * captions selection menus.
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.Menu = vjs.Component.extend();
	   
	/**
	 * Add a menu item to the menu
	 * @param {Object|String} component Component or component type to add
	 */
	vjs.Menu.prototype.addItem = function(component){
	  this.addChild(component);
	  component.on('click', vjs.bind(this, function(){
	    this.unlockShowing();
	  }));
	};

	/** @inheritDoc */
	vjs.Menu.prototype.createEl = function(){
	  var contentElType = this.options().contentElType || 'ul';
	  this.contentEl_ = vjs.createEl(contentElType, {
	    className: 'vjs-menu-content'
	  });
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	    append: this.contentEl_,
	    className: 'vjs-menu'
	  });
	  el.appendChild(this.contentEl_);

	  // Prevent clicks from bubbling up. Needed for Menu Buttons,
	  // where a click on the parent is significant
	  vjs.on(el, 'click', function(event){
	    event.preventDefault();
	    event.stopImmediatePropagation();
	  });

	  return el;
	};

	/**
	 * The component for a menu item. `<li>`
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.MenuItem = vjs.Button.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);
	    this.selected(options['selected']);
	  }
	});

	/** @inheritDoc */
	vjs.MenuItem.prototype.createEl = function(type, props){
	  return vjs.Button.prototype.createEl.call(this, 'li', vjs.obj.merge({
	    className: 'vjs-menu-item',
	    innerHTML: this.localize(this.options_['label'])
	  }, props));
	};

	/**
	 * Handle a click on the menu item, and set it to selected
	 */
	vjs.MenuItem.prototype.onClick = function(){
	  this.selected(true);
	};

	/**
	 * Set this menu item as selected or not
	 * @param  {Boolean} selected
	 */
	vjs.MenuItem.prototype.selected = function(selected){
	  if (selected) {
	    this.addClass('vjs-selected');
	    this.el_.setAttribute('aria-selected',true);
	  } else {
	    this.removeClass('vjs-selected');
	    this.el_.setAttribute('aria-selected',false);
	  }
	};


	/**
	 * A button class with a popup menu
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.MenuButton = vjs.Button.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);

	    this.update();

	    this.on('keydown', this.onKeyPress);
	    this.el_.setAttribute('aria-haspopup', true);
	    this.el_.setAttribute('role', 'button');
	  }
	});

	vjs.MenuButton.prototype.update = function() {
	  var menu = this.createMenu();

	  if (this.menu) {
	    this.removeChild(this.menu);
	  }

	  this.menu = menu;
	  this.addChild(menu);

	  if (this.items && this.items.length === 0) {
	    this.hide();
	  } else if (this.items && this.items.length > 1) {
	    this.show();
	  }
	};

	/**
	 * Track the state of the menu button
	 * @type {Boolean}
	 * @private
	 */
	vjs.MenuButton.prototype.buttonPressed_ = false;

	vjs.MenuButton.prototype.createMenu = function(){
	  var menu = new vjs.Menu(this.player_);

	  // Add a title list item to the top
	  if (this.options().title) {
	    menu.contentEl().appendChild(vjs.createEl('li', {
	      className: 'vjs-menu-title',
	      innerHTML: vjs.capitalize(this.options().title),
	      tabindex: -1
	    }));
	  }

	  this.items = this['createItems']();

	  if (this.items) {
	    // Add menu items to the menu
	    for (var i = 0; i < this.items.length; i++) {
	      menu.addItem(this.items[i]);
	    }
	  }

	  return menu;
	};

	/**
	 * Create the list of menu items. Specific to each subclass.
	 */
	vjs.MenuButton.prototype.createItems = function(){};

	/** @inheritDoc */
	vjs.MenuButton.prototype.buildCSSClass = function(){
	  return this.className + ' vjs-menu-button ' + vjs.Button.prototype.buildCSSClass.call(this);
	};

	// Focus - Add keyboard functionality to element
	// This function is not needed anymore. Instead, the keyboard functionality is handled by
	// treating the button as triggering a submenu. When the button is pressed, the submenu
	// appears. Pressing the button again makes the submenu disappear.
	vjs.MenuButton.prototype.onFocus = function(){};
	// Can't turn off list display that we turned on with focus, because list would go away.
	vjs.MenuButton.prototype.onBlur = function(){};

	vjs.MenuButton.prototype.onClick = function(){
	  // When you click the button it adds focus, which will show the menu indefinitely.
	  // So we'll remove focus when the mouse leaves the button.
	  // Focus is needed for tab navigation.
	  this.one('mouseout', vjs.bind(this, function(){
	    this.menu.unlockShowing();
	    this.el_.blur();
	  }));
	  if (this.buttonPressed_){
	    this.unpressButton();
	  } else {
	    this.pressButton();
	  }
	};

	vjs.MenuButton.prototype.onKeyPress = function(event){

	  // Check for space bar (32) or enter (13) keys
	  if (event.which == 32 || event.which == 13) {
	    if (this.buttonPressed_){
	      this.unpressButton();
	    } else {
	      this.pressButton();
	    }
	    event.preventDefault();
	  // Check for escape (27) key
	  } else if (event.which == 27){
	    if (this.buttonPressed_){
	      this.unpressButton();
	    }
	    event.preventDefault();
	  }
	};

	vjs.MenuButton.prototype.pressButton = function(){
	  this.buttonPressed_ = true;
	  this.menu.lockShowing();
	  this.el_.setAttribute('aria-pressed', true);
	  if (this.items && this.items.length > 0) {
	    this.items[0].el().focus(); // set the focus to the title of the submenu
	  }
	};

	vjs.MenuButton.prototype.unpressButton = function(){
	  this.buttonPressed_ = false;
	  this.menu.unlockShowing();
	  this.el_.setAttribute('aria-pressed', false);
	};

	/**
	 * Custom MediaError to mimic the HTML5 MediaError
	 * @param {Number} code The media error code
	 */
	vjs.MediaError = function(code){
	  
	  if (typeof code === 'number') {
	    this.code = code;
	  } else if (typeof code === 'string') {
	    // default code is zero, so this is a custom error
	    this.message = code;
	  } else if (typeof code === 'object') { // object
	    vjs.obj.merge(this, code);
	  }

	  if (!this.message) {
	    //this.message = vjs.MediaError.defaultMessages[this.code] || '';
	    this.message = '';//VID-1444
	  }
	};

	/**
	 * The error code that refers two one of the defined
	 * MediaError types
	 * @type {Number}
	 */
	vjs.MediaError.prototype.code = 0;

	/**
	 * An optional message to be shown with the error.
	 * Message is not part of the HTML5 video spec
	 * but allows for more informative custom errors.
	 * @type {String}
	 */
	vjs.MediaError.prototype.message = '';

	/**
	 * An optional status code that can be set by plugins
	 * to allow even more detail about the error.
	 * For example the HLS plugin might provide the specific
	 * HTTP status code that was returned when the error
	 * occurred, then allowing a custom error overlay
	 * to display more information.
	 * @type {[type]}
	 */
	vjs.MediaError.prototype.status = null;

	vjs.MediaError.errorTypes = [
	  'MEDIA_ERR_CUSTOM',            // = 0
	  'MEDIA_ERR_ABORTED',           // = 1
	  'MEDIA_ERR_NETWORK',           // = 2
	  'MEDIA_ERR_DECODE',            // = 3
	  'MEDIA_ERR_SRC_NOT_SUPPORTED', // = 4
	  'MEDIA_ERR_ENCRYPTED'          // = 5
	];

	vjs.MediaError.defaultMessages = {
	  1: 'You aborted the video playback',
	  2: 'A network error caused the video download to fail part-way.',
	  3: 'The video playback was aborted due to a corruption problem or because the video used features your browser did not support.',
	  4: 'The video could not be loaded, either because the server or network failed or because the format is not supported.',
	  5: 'The video is encrypted and we do not have the keys to decrypt it.'
	};

	// Add types as properties on MediaError
	// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
	for (var errNum = 0; errNum < vjs.MediaError.errorTypes.length; errNum++) {
	  vjs.MediaError[vjs.MediaError.errorTypes[errNum]] = errNum;
	  // values should be accessible on both the class and instance
	  vjs.MediaError.prototype[vjs.MediaError.errorTypes[errNum]] = errNum;
	}

	(function(){
	  var apiMap, specApi, browserApi, i;

	  /**
	   * Store the browser-specific methods for the fullscreen API
	   * @type {Object|undefined}
	   * @private
	   */
	  vjs.browser.fullscreenAPI;

	  // browser API methods
	  // map approach from Screenful.js - https://github.com/sindresorhus/screenfull.js
	  apiMap = [
	    // Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html
	    [
	      'requestFullscreen',
	      'exitFullscreen',
	      'fullscreenElement',
	      'fullscreenEnabled',
	      'fullscreenchange',
	      'fullscreenerror'
	    ],
	    // WebKit
	    [
	      'webkitRequestFullscreen',
	      'webkitExitFullscreen',
	      'webkitFullscreenElement',
	      'webkitFullscreenEnabled',
	      'webkitfullscreenchange',
	      'webkitfullscreenerror'
	    ],
	    // Old WebKit (Safari 5.1)
	    [
	      'webkitRequestFullScreen',
	      'webkitCancelFullScreen',
	      'webkitCurrentFullScreenElement',
	      'webkitCancelFullScreen',
	      'webkitfullscreenchange',
	      'webkitfullscreenerror'
	    ],
	    // Mozilla
	    [
	      'mozRequestFullScreen',
	      'mozCancelFullScreen',
	      'mozFullScreenElement',
	      'mozFullScreenEnabled',
	      'mozfullscreenchange',
	      'mozfullscreenerror'
	    ],
	    // Microsoft
	    [
	      'msRequestFullscreen',
	      'msExitFullscreen',
	      'msFullscreenElement',
	      'msFullscreenEnabled',
	      'MSFullscreenChange',
	      'MSFullscreenError'
	    ]
	  ];

	  specApi = apiMap[0];

	  // determine the supported set of functions
	  for (i=0; i<apiMap.length; i++) {
	    // check for exitFullscreen function
	    if (apiMap[i][1] in document) {
	      browserApi = apiMap[i];
	      break;
	    }
	  }

	  // map the browser API names to the spec API names
	  // or leave vjs.browser.fullscreenAPI undefined
	  if (browserApi) {
	    vjs.browser.fullscreenAPI = {};

	    for (i=0; i<browserApi.length; i++) {
	      vjs.browser.fullscreenAPI[specApi[i]] = browserApi[i];
	    }
	  }

	})();

	/**
	 * An instance of the `vjs.Player` class is created when any of the Video.js setup methods are used to initialize a video.
	 *
	 * ```js
	 * var myPlayer = videojs('example_video_1');
	 * ```
	 *
	 * In the following example, the `data-setup` attribute tells the Video.js library to create a player instance when the library is ready.
	 *
	 * ```html
	 * <video id="example_video_1" data-setup='{}' controls>
	 *   <source src="my-source.mp4" type="video/mp4">
	 * </video>
	 * ```
	 *
	 * After an instance has been created it can be accessed globally using `Video('example_video_1')`.
	 *
	 * @class
	 * @extends vjs.Component
	 */
	vjs.Player = vjs.Component.extend({

	  /**
	   * player's constructor function
	   *
	   * @constructs
	   * @method init
	   * @param {Element} tag        The original video tag used for configuring options
	   * @param {Object=} options    Player options
	   * @param {Function=} ready    Ready callback function
	   */
	  init: function(tag, options, ready){
	    this.tag = tag; // Store the original tag used to set options

	    // Make sure tag ID exists
	    tag.id = tag.id || 'vjs_video_' + vjs.guid++;

	    // Store the tag attributes used to restore html5 element
	    this.tagAttributes = tag && vjs.getElementAttributes(tag);

	    // Set Options
	    // The options argument overrides options set in the video tag
	    // which overrides globally set options.
	    // This latter part coincides with the load order
	    // (tag must exist before Player)
	    options = vjs.obj.merge(this.getTagSettings(tag), options);

	    // Update Current Language
	    this.language_ = options['language'] || vjs.options['language'];

	    // Update Supported Languages
	    this.languages_ = options['languages'] || vjs.options['languages'];

	    // Cache for video property values.
	    this.cache_ = {};

	    // Set poster
	    this.poster_ = options['poster'] || '';

	    // Set controls
	    this.controls_ = !!options['controls'];
	    // Original tag settings stored in options
	    // now remove immediately so native controls don't flash.
	    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
	    tag.controls = false;

	    // we don't want the player to report touch activity on itself
	    // see enableTouchActivity in Component
	    options.reportTouchActivity = false;

	    // Set isAudio based on whether or not an audio tag was used
	    this.isAudio(this.tag.nodeName.toLowerCase() === 'audio');

	    // Run base component initializing with new options.
	    // Builds the element through createEl()
	    // Inits and embeds any child components in opts
	    vjs.Component.call(this, this, options, ready);

	    // Update controls className. Can't do this when the controls are initially
	    // set because the element doesn't exist yet.
	    if (this.controls()) {
	      this.addClass('vjs-controls-enabled');
	    } else {
	      this.addClass('vjs-controls-disabled');
	    }

	    if (this.isAudio()) {
	      this.addClass('vjs-audio');
	    }

	    this.addClass('vjs-big-play-centered');

	    // TODO: Make this smarter. Toggle user state between touching/mousing
	    // using events, since devices can have both touch and mouse events.
	    // if (vjs.TOUCH_ENABLED) {
	    //   this.addClass('vjs-touch-enabled');
	    // }

	    // Make player easily findable by ID
	    vjs.players[this.id_] = this;

	    if (options['plugins']) {
	      vjs.obj.each(options['plugins'], function(key, val){
	        this[key](val);
	      }, this);
	    }

	    //Ref: VIDLA-1106 Enable the activity tracker for JS VPAID
	    this.listenForUserActivity();

	  }
	});

	/**
	 * The player's stored language code
	 *
	 * @type {String}
	 * @private
	 */
	vjs.Player.prototype.language_;

	/**
	 * The player's language code
	 * @param  {String} languageCode  The locale string
	 * @return {String}             The locale string when getting
	 * @return {vjs.Player}         self, when setting
	 */
	vjs.Player.prototype.language = function (languageCode) {
	  if (languageCode === undefined) {
	    return this.language_;
	  }

	  this.language_ = languageCode;
	  return this;
	};

	/**
	 * The player's override for Volume controls
	 * @return {Boolean}             The volume override
	 */
	vjs.Player.prototype.getMuteSettingsForIOS10 = function () {
	  //VID-2810 Override the video-js volume logic for IOS 10 and above which allow the set up of the volume
	  return vjs.IS_IOS && this.options_['enableNativeInline'] && (parseInt(vjs.IOS_VERSION) > 9);

	};

	/**
	 * The player's stored language dictionary
	 *
	 * @type {Object}
	 * @private
	 */
	vjs.Player.prototype.languages_;

	vjs.Player.prototype.languages = function(){
	  return this.languages_;
	};

	/**
	 * Player instance options, surfaced using vjs.options
	 * vjs.options = vjs.Player.prototype.options_
	 * Make changes in vjs.options, not here.
	 * All options should use string keys so they avoid
	 * renaming by closure compiler
	 * @type {Object}
	 * @private
	 */
	vjs.Player.prototype.options_ = vjs.options;

	/**
	 * Destroys the video player and does any necessary cleanup
	 *
	 *     myPlayer.dispose();
	 *
	 * This is especially helpful if you are dynamically adding and removing videos
	 * to/from the DOM.
	 */
	vjs.Player.prototype.dispose = function(){
	  this.trigger('dispose');
	  // prevent dispose from being called twice
	  this.off('dispose');

	  // Kill reference to this player
	  vjs.players[this.id_] = null;
	  if (this.tag && this.tag['player']) { this.tag['player'] = null; }
	  if (this.el_ && this.el_['player']) { this.el_['player'] = null; }

	  if (this.tech) { this.tech.dispose(); }

	  // Component dispose
	  vjs.Component.prototype.dispose.call(this);
	};

	vjs.Player.prototype.getTagSettings = function(tag){
	  var tagOptions,
	      dataSetup,
	      options = {
	        'sources': [],
	        'tracks': []
	      };

	  tagOptions = vjs.getElementAttributes(tag);
	  dataSetup = tagOptions['data-setup'];

	  // Check if data-setup attr exists.
	  if (dataSetup !== null){
	    // Parse options JSON
	    // If empty string, make it a parsable json object.
	    vjs.obj.merge(tagOptions, vjs.JSON.parse(dataSetup || '{}'));
	  }

	  vjs.obj.merge(options, tagOptions);

	  // Get tag children settings
	  if (tag.hasChildNodes()) {
	    var children, child, childName, i, j;

	    children = tag.childNodes;

	    for (i=0,j=children.length; i<j; i++) {
	      child = children[i];
	      // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
	      childName = child.nodeName.toLowerCase();
	      if (childName === 'source') {
	        options['sources'].push(vjs.getElementAttributes(child));
	      } else if (childName === 'track') {
	        options['tracks'].push(vjs.getElementAttributes(child));
	      }
	    }
	  }

	  return options;
	};

	vjs.Player.prototype.createEl = function(){
	  var
	    el = this.el_ = vjs.Component.prototype.createEl.call(this, 'div'),
	    tag = this.tag,
	    attrs;

	  // Remove width/height attrs from tag so CSS can make it 100% width/height
	  tag.removeAttribute('width');
	  tag.removeAttribute('height');

	  // Copy over all the attributes from the tag, including ID and class
	  // ID will now reference player box, not the video tag
	  attrs = vjs.getElementAttributes(tag);
	  vjs.obj.each(attrs, function(attr) {
	    // workaround so we don't totally break IE7
	    // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
	    if (attr == 'class') {
	      el.className = attrs[attr];
	    } else {
	      el.setAttribute(attr, attrs[attr]);
	    }
	  });

	  // Update tag id/class for use as HTML5 playback tech
	  // Might think we should do this after embedding in container so .vjs-tech class
	  // doesn't flash 100% width/height, but class only applies with .video-js parent
	  tag.id += '_html5_api';
	  tag.className = 'vjs-tech';

	  // Make player findable on elements
	  tag['player'] = el['player'] = this;
	  // Default state of video is paused
	  this.addClass('vjs-paused');

	  // Make box use width/height of tag, or rely on default implementation
	  // Enforce with CSS since width/height attrs don't work on divs
	  this.width(this.options_['width'], true); // (true) Skip resize listener on load
	  this.height(this.options_['height'], true);

	  // vjs.insertFirst seems to cause the networkState to flicker from 3 to 2, so
	  // keep track of the original for later so we can know if the source originally failed
	  tag.initNetworkState_ = tag.networkState;

	  // Wrap video tag in div (el/box) container
	  if (tag.parentNode) {
	    tag.parentNode.insertBefore(el, tag);
	  }
	  vjs.insertFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.

	  // The event listeners need to be added before the children are added
	  // in the component init because the tech (loaded with mediaLoader) may
	  // fire events, like loadstart, that these events need to capture.
	  // Long term it might be better to expose a way to do this in component.init
	  // like component.initEventListeners() that runs between el creation and
	  // adding children
	  this.el_ = el;
	  this.on('loadstart', this.onLoadStart);
	  this.on('waiting', this.onWaiting);
	  this.on(['canplay', 'canplaythrough', 'playing', 'ended'], this.onWaitEnd);
	  this.on('seeking', this.onSeeking);
	  this.on('seeked', this.onSeeked);
	  this.on('ended', this.onEnded);
	  this.on('play', this.onPlay);
	  this.on('firstplay', this.onFirstPlay);
	  this.on('pause', this.onPause);
	  this.on('progress', this.onProgress);
	  this.on('durationchange', this.onDurationChange);
	  this.on('fullscreenchange', this.onFullscreenChange);

	  return el;
	};

	// /* Media Technology (tech)
	// ================================================================================ */
	// Load/Create an instance of playback technology including element and API methods
	// And append playback element in player div.
	vjs.Player.prototype.loadTech = function(techName, source){

	  // Pause and remove current playback technology
	  if (this.tech) {
	    this.unloadTech();
	  }

	  // get rid of the HTML5 video tag as soon as we are using another tech
	  if (techName !== 'Html5' && this.tag) {
	    vjs.Html5.disposeMediaElement(this.tag);
	    this.tag = null;
	  }

	  this.techName = techName;

	  // Turn off API access because we're loading a new tech that might load asynchronously
	  this.isReady_ = false;

	  var techReady = function(){
	    this.player_.triggerReady();
	  };

	  // Grab tech-specific options from player options and add source and parent element to use.
	  var techOptions = vjs.obj.merge({ 'source': source, 'parentEl': this.el_ }, this.options_[techName.toLowerCase()]);

	  if (source) {
	    this.currentType_ = source.type;
	    if (source.src == this.cache_.src && this.cache_.currentTime > 0) {
	      techOptions['startTime'] = this.cache_.currentTime;
	    }

	    this.cache_.src = source.src;
	  }

	  // Initialize tech instance
	  this.tech = new window['videojs_apn'][techName](this, techOptions);

	  this.tech.ready(techReady);
	};

	vjs.Player.prototype.unloadTech = function(){
	  this.isReady_ = false;

	  this.tech.dispose();

	  this.tech = false;
	};

	// There's many issues around changing the size of a Flash (or other plugin) object.
	// First is a plugin reload issue in Firefox that has been around for 11 years: https://bugzilla.mozilla.org/show_bug.cgi?id=90268
	// Then with the new fullscreen API, Mozilla and webkit browsers will reload the flash object after going to fullscreen.
	// To get around this, we're unloading the tech, caching source and currentTime values, and reloading the tech once the plugin is resized.
	// reloadTech: function(betweenFn){
	//   vjs.log('unloadingTech')
	//   this.unloadTech();
	//   vjs.log('unloadedTech')
	//   if (betweenFn) { betweenFn.call(); }
	//   vjs.log('LoadingTech')
	//   this.loadTech(this.techName, { src: this.cache_.src })
	//   vjs.log('loadedTech')
	// },

	// /* Player event handlers (how the player reacts to certain events)
	// ================================================================================ */

	/**
	 * Fired when the user agent begins looking for media data
	 * @event loadstart
	 */
	vjs.Player.prototype.onLoadStart = function() {
	  // TODO: Update to use `emptied` event instead. See #1277.

	  this.removeClass('vjs-ended');

	  // reset the error state
	  this.error(null);

	  // If it's already playing we want to trigger a firstplay event now.
	  // The firstplay event relies on both the play and loadstart events
	  // which can happen in any order for a new source
	  if (!this.paused()) {
	    this.trigger('firstplay');
	  } else {
	    // reset the hasStarted state
	    this.hasStarted(false);
	  }
	};

	vjs.Player.prototype.hasStarted_ = false;

	vjs.Player.prototype.hasStarted = function(hasStarted){
	  if (hasStarted !== undefined) {
	    // only update if this is a new value
	    if (this.hasStarted_ !== hasStarted) {
	      this.hasStarted_ = hasStarted;
	      if (hasStarted) {
	        this.addClass('vjs-has-started');
	        // trigger the firstplay event if this newly has played
	        this.trigger('firstplay');
	      } else {
	        this.removeClass('vjs-has-started');
	      }
	    }
	    return this;
	  }
	  return this.hasStarted_;
	};

	/**
	 * Fired when the player has initial duration and dimension information
	 * @event loadedmetadata
	 */
	vjs.Player.prototype.onLoadedMetaData;

	/**
	 * Fired when the player has downloaded data at the current playback position
	 * @event loadeddata
	 */
	vjs.Player.prototype.onLoadedData;

	/**
	 * Fired when the player has finished downloading the source data
	 * @event loadedalldata
	 */
	vjs.Player.prototype.onLoadedAllData;

	/**
	 * Fired whenever the media begins or resumes playback
	 * @event play
	 */
	vjs.Player.prototype.onPlay = function(){
	  this.removeClass('vjs-ended');
	  this.removeClass('vjs-paused');
	  this.addClass('vjs-playing');

	  // hide the poster when the user hits play
	  // https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play
	  this.hasStarted(true);
	};

	/**
	 * Fired whenever the media begins waiting
	 * @event waiting
	 */
	vjs.Player.prototype.onWaiting = function(){
	  this.addClass('vjs-waiting');
	};

	/**
	 * A handler for events that signal that waiting has ended
	 * which is not consistent between browsers. See #1351
	 * @private
	 */
	vjs.Player.prototype.onWaitEnd = function(){
	  this.removeClass('vjs-waiting');
	};

	/**
	 * Fired whenever the player is jumping to a new time
	 * @event seeking
	 */
	vjs.Player.prototype.onSeeking = function(){
	  this.addClass('vjs-seeking');
	};

	/**
	 * Fired when the player has finished jumping to a new time
	 * @event seeked
	 */
	vjs.Player.prototype.onSeeked = function(){
	  this.removeClass('vjs-seeking');
	};

	/**
	 * Fired the first time a video is played
	 *
	 * Not part of the HLS spec, and we're not sure if this is the best
	 * implementation yet, so use sparingly. If you don't have a reason to
	 * prevent playback, use `myPlayer.one('play');` instead.
	 *
	 * @event firstplay
	 */
	vjs.Player.prototype.onFirstPlay = function(){
	    //If the first starttime attribute is specified
	    //then we will start at the given offset in seconds
	    if(this.options_['starttime']){
	      this.currentTime(this.options_['starttime']);
	    }

	    this.addClass('vjs-has-started');
	};

	/**
	 * Fired whenever the media has been paused
	 * @event pause
	 */
	vjs.Player.prototype.onPause = function(){
	  this.removeClass('vjs-playing');
	  this.addClass('vjs-paused');
	};

	/**
	 * Fired when the current playback position has changed
	 *
	 * During playback this is fired every 15-250 milliseconds, depending on the
	 * playback technology in use.
	 * @event timeupdate
	 */
	vjs.Player.prototype.onTimeUpdate;

	/**
	 * Fired while the user agent is downloading media data
	 * @event progress
	 */
	vjs.Player.prototype.onProgress = function(){
	  // Add custom event for when source is finished downloading.
	  if (this.bufferedPercent() == 1) {
	    this.trigger('loadedalldata');
	  }
	};

	/**
	 * Fired when the end of the media resource is reached (currentTime == duration)
	 * @event ended
	 */
	vjs.Player.prototype.onEnded = function(){
	  this.addClass('vjs-ended');
	  if (this.options_['loop']) {
	    this.currentTime(0);
	    this.play();
	  } else if (!this.paused()) {
	    this.pause();
	  }
	};

	/**
	 * Fired when the duration of the media resource is first known or changed
	 * @event durationchange
	 */
	vjs.Player.prototype.onDurationChange = function(){
	  // Allows for caching value instead of asking player each time.
	  // We need to get the techGet response and check for a value so we don't
	  // accidentally cause the stack to blow up.
	  var duration = this.techGet('duration');
	  if (duration) {
	    if (duration < 0) {
	      duration = Infinity;
	    }
	    this.duration(duration);
	    // Determine if the stream is live and propagate styles down to UI.
	    if (duration === Infinity) {
	      this.addClass('vjs-live');
	    } else {
	      this.removeClass('vjs-live');
	    }
	  }
	};

	/**
	 * Fired when the volume changes
	 * @event volumechange
	 */
	vjs.Player.prototype.onVolumeChange;

	/**
	 * Fired when the player switches in or out of fullscreen mode
	 * @event fullscreenchange
	 */
	vjs.Player.prototype.onFullscreenChange = function() {
	  if (this.isFullscreen()) {
	    this.addClass('vjs-fullscreen');
	  } else {
	    this.removeClass('vjs-fullscreen');
	  }
	};

	/**
	 * Fired when an error occurs
	 * @event error
	 */
	vjs.Player.prototype.onError;

	// /* Player API
	// ================================================================================ */

	/**
	 * Object for cached values.
	 * @private
	 */
	vjs.Player.prototype.cache_;

	vjs.Player.prototype.getCache = function(){
	  return this.cache_;
	};

	// Pass values to the playback tech
	vjs.Player.prototype.techCall = function(method, arg){
	  // If it's not ready yet, call method when it is
	  if (this.tech && !this.tech.isReady_) {
	    this.tech.ready(function(){
	      this[method](arg);
	    });

	  // Otherwise call method now
	  } else {
	    try {
	      this.tech[method](arg);
	    } catch(e) {
	      vjs.log(e);
	      throw e;
	    }
	  }
	};

	// Get calls can't wait for the tech, and sometimes don't need to.
	vjs.Player.prototype.techGet = function(method){
	  if (this.tech && this.tech.isReady_) {

	    // Flash likes to die and reload when you hide or reposition it.
	    // In these cases the object methods go away and we get errors.
	    // When that happens we'll catch the errors and inform tech that it's not ready any more.
	    try {
	      return this.tech[method]();
	    } catch(e) {
	      // When building additional tech libs, an expected method may not be defined yet
	      if (this.tech[method] === undefined) {
	        vjs.log('Video.js: ' + method + ' method not defined for '+this.techName+' playback technology.', e);
	      } else {
	        // When a method isn't available on the object it throws a TypeError
	        if (e.name == 'TypeError') {
	          vjs.log('Video.js: ' + method + ' unavailable on '+this.techName+' playback technology element.', e);
	          this.tech.isReady_ = false;
	        } else {
	          vjs.log(e);
	        }
	      }
	      throw e;
	    }
	  }

	  return;
	};

	/**
	 * start media playback
	 *
	 *     myPlayer.play();
	 *
	 * @return {vjs.Player} self
	 */
	vjs.Player.prototype.play = function(){
	  this.techCall('play');
	  return this;
	};

	/**
	 * Pause the video playback
	 *
	 *     myPlayer.pause();
	 *
	 * @return {vjs.Player} self
	 */
	vjs.Player.prototype.pause = function(){
	  this.techCall('pause');
	  this.trigger("apn-vpaid-pause");//VID-2405, VID-2406
	  return this;
	};

	/**
	 * Check if the player is paused
	 *
	 *     var isPaused = myPlayer.paused();
	 *     var isPlaying = !myPlayer.paused();
	 *
	 * @return {Boolean} false if the media is currently playing, or true otherwise
	 */
	vjs.Player.prototype.paused = function(){
	  // The initial state of paused should be true (in Safari it's actually false)
	  return (this.techGet('paused') === false) ? false : true;
	};

	/**
	 * Get or set the current time (in seconds)
	 *
	 *     // get
	 *     var whereYouAt = myPlayer.currentTime();
	 *
	 *     // set
	 *     myPlayer.currentTime(120); // 2 minutes into the video
	 *
	 * @param  {Number|String=} seconds The time to seek to
	 * @return {Number}        The time in seconds, when not setting
	 * @return {vjs.Player}    self, when the current time is set
	 */
	vjs.Player.prototype.currentTime = function(seconds){
	  if (seconds !== undefined) {

	    this.techCall('setCurrentTime', seconds);

	    return this;
	  }

	  // cache last currentTime and return. default to 0 seconds
	  //
	  // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
	  // currentTime when scrubbing, but may not provide much performance benefit afterall.
	  // Should be tested. Also something has to read the actual current time or the cache will
	  // never get updated.
	  return this.cache_.currentTime = (this.techGet('currentTime') || 0);
	};

	/**
	 * Get the length in time of the video in seconds
	 *
	 *     var lengthOfVideo = myPlayer.duration();
	 *
	 * **NOTE**: The video must have started loading before the duration can be
	 * known, and in the case of Flash, may not be known until the video starts
	 * playing.
	 *
	 * @return {Number} The duration of the video in seconds
	 */
	vjs.Player.prototype.duration = function(seconds){
	  if (seconds !== undefined) {

	    // cache the last set value for optimized scrubbing (esp. Flash)
	    this.cache_.duration = parseFloat(seconds);

	    return this;
	  }

	  if (this.cache_.duration === undefined) {
	    this.onDurationChange();
	  }

	  return this.cache_.duration || 0;
	};

	/**
	 * Calculates how much time is left.
	 *
	 *     var timeLeft = myPlayer.remainingTime();
	 *
	 * Not a native video element function, but useful
	 * @return {Number} The time remaining in seconds
	 */
	vjs.Player.prototype.remainingTime = function(){
	  return this.duration() - this.currentTime();
	};

	// http://dev.w3.org/html5/spec/video.html#dom-media-buffered
	// Buffered returns a timerange object.
	// Kind of like an array of portions of the video that have been downloaded.

	/**
	 * Get a TimeRange object with the times of the video that have been downloaded
	 *
	 * If you just want the percent of the video that's been downloaded,
	 * use bufferedPercent.
	 *
	 *     // Number of different ranges of time have been buffered. Usually 1.
	 *     numberOfRanges = bufferedTimeRange.length,
	 *
	 *     // Time in seconds when the first range starts. Usually 0.
	 *     firstRangeStart = bufferedTimeRange.start(0),
	 *
	 *     // Time in seconds when the first range ends
	 *     firstRangeEnd = bufferedTimeRange.end(0),
	 *
	 *     // Length in seconds of the first time range
	 *     firstRangeLength = firstRangeEnd - firstRangeStart;
	 *
	 * @return {Object} A mock TimeRange object (following HTML spec)
	 */
	vjs.Player.prototype.buffered = function(){
	  var buffered = this.techGet('buffered');

	  if (!buffered || !buffered.length) {
	    buffered = vjs.createTimeRange(0,0);
	  }

	  return buffered;
	};

	/**
	 * Get the percent (as a decimal) of the video that's been downloaded
	 *
	 *     var howMuchIsDownloaded = myPlayer.bufferedPercent();
	 *
	 * 0 means none, 1 means all.
	 * (This method isn't in the HTML5 spec, but it's very convenient)
	 *
	 * @return {Number} A decimal between 0 and 1 representing the percent
	 */
	vjs.Player.prototype.bufferedPercent = function(){
	  var duration = this.duration(),
	      buffered = this.buffered(),
	      bufferedDuration = 0,
	      start, end;

	  if (!duration) {
	    return 0;
	  }

	  for (var i=0; i<buffered.length; i++){
	    start = buffered.start(i);
	    end   = buffered.end(i);

	    // buffered end can be bigger than duration by a very small fraction
	    if (end > duration) {
	      end = duration;
	    }

	    bufferedDuration += end - start;
	  }

	  return bufferedDuration / duration;
	};

	/**
	 * Get the ending time of the last buffered time range
	 *
	 * This is used in the progress bar to encapsulate all time ranges.
	 * @return {Number} The end of the last buffered time range
	 */
	vjs.Player.prototype.bufferedEnd = function(){
	  var buffered = this.buffered(),
	      duration = this.duration(),
	      end = buffered.end(buffered.length-1);

	  if (end > duration) {
	    end = duration;
	  }

	  return end;
	};

	/**
	 * Get or set the current volume of the media
	 *
	 *     // get
	 *     var howLoudIsIt = myPlayer.volume();
	 *
	 *     // set
	 *     myPlayer.volume(0.5); // Set volume to half
	 *
	 * 0 is off (muted), 1.0 is all the way up, 0.5 is half way.
	 *
	 * @param  {Number} percentAsDecimal The new volume as a decimal percent
	 * @return {Number}                  The current volume, when getting
	 * @return {vjs.Player}              self, when setting
	 */
	vjs.Player.prototype.volume = function(percentAsDecimal){
	  var vol;

	  if (percentAsDecimal !== undefined) {
	    vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1
	    this.cache_.volume = vol;
	    this.techCall('setVolume', vol);
	    vjs.setLocalStorage('volume', vol);
	    return this;
	  }

	  // Default to 1 when returning current volume.
	  vol = parseFloat(this.techGet('volume'));
	  return (isNaN(vol)) ? 1 : vol;
	};


	/**
	 * Get the current muted state, or turn mute on or off
	 *
	 *     // get
	 *     var isVolumeMuted = myPlayer.muted();
	 *
	 *     // set
	 *     myPlayer.muted(true); // mute the volume
	 *
	 * @param  {Boolean=} muted True to mute, false to unmute
	 * @return {Boolean} True if mute is on, false if not, when getting
	 * @return {vjs.Player} self, when setting mute
	 */
	vjs.Player.prototype.muted = function(muted){
	    if (muted !== undefined) {
	        //for VID-2793 this mute doesn't need to be invoked if inline module enabled because the module has own mute/unmute features
	        var supressMutedForIOS = vjs.IS_IOS && this.options_['enableInlineVideoForIos'];
	        if (!supressMutedForIOS) {
	            this.techCall('setMuted', muted);
	        }
	        return this;
	    }
	    return this.techGet('muted') || false; // Default to false
	};


	// Check if current tech can support native fullscreen
	// (e.g. with built in controls like iOS, so not our flash swf)
	vjs.Player.prototype.supportsFullScreen = function(){
	  return this.techGet('supportsFullScreen') || false;
	};

	/**
	 * is the player in fullscreen
	 * @type {Boolean}
	 * @private
	 */
	vjs.Player.prototype.isFullscreen_ = false;

	/**
	 * Check if the player is in fullscreen mode
	 *
	 *     // get
	 *     var fullscreenOrNot = myPlayer.isFullscreen();
	 *
	 *     // set
	 *     myPlayer.isFullscreen(true); // tell the player it's in fullscreen
	 *
	 * NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
	 * property and instead document.fullscreenElement is used. But isFullscreen is
	 * still a valuable property for internal player workings.
	 *
	 * @param  {Boolean=} isFS Update the player's fullscreen state
	 * @return {Boolean} true if fullscreen, false if not
	 * @return {vjs.Player} self, when setting
	 */
	vjs.Player.prototype.isFullscreen = function(isFS){
	  if (isFS !== undefined) {
	    this.isFullscreen_ = !!isFS;
	    return this;
	  }
	  return this.isFullscreen_;
	};

	/**
	 * Old naming for isFullscreen()
	 * @deprecated for lowercase 's' version
	 */
	vjs.Player.prototype.isFullScreen = function(isFS){
	  vjs.log.warn('player.isFullScreen() has been deprecated, use player.isFullscreen() with a lowercase "s")');
	  return this.isFullscreen(isFS);
	};

	/**
	 * Increase the size of the video to full screen
	 *
	 *     myPlayer.requestFullscreen();
	 *
	 * In some browsers, full screen is not supported natively, so it enters
	 * "full window mode", where the video fills the browser window.
	 * In browsers and devices that support native full screen, sometimes the
	 * browser's default controls will be shown, and not the Video.js custom skin.
	 * This includes most mobile devices (iOS, Android) and older versions of
	 * Safari.
	 *
	 * @return {vjs.Player} self
	 */
	vjs.Player.prototype.requestFullscreen = function() {
	    var fsApi = vjs.browser.fullscreenAPI;

	    this.isFullscreen(true);

	    if (fsApi) {
	        // the browser supports going fullscreen at the element level so we can
	        // take the controls fullscreen as well as the video

	        // Trigger fullscreenchange event after change
	        // We have to specifically add this each time, and remove
	        // when canceling fullscreen. Otherwise if there's multiple
	        // players on a page, they would all be reacting to the same fullscreen
	        // events
	        vjs.on(document, fsApi['fullscreenchange'], vjs.bind(this, function(e) {
	            this.isFullscreen(document[fsApi.fullscreenElement]);

	            // If cancelling fullscreen, remove event listener.
	            if (this.isFullscreen() === false) {
	                vjs.off(document, fsApi['fullscreenchange'], arguments.callee);
	            }
	        }));

	        this.el_[fsApi.requestFullscreen]();

	        // Send notification of fullscreen enter and exit to HTML5 player.  2/9/2018, Mobile Engineering.
	        //   For Android: Because Marshmellow & versions below do not trigger the FSAPI change event.
	        //   For iOS: General case.
	        //
	        this.trigger('fullscreenchange');

	    } else if (this.tech.supportsFullScreen()) {
	        // Send notification of fullscreen enter and exit to HTML5 player.  2/9/2018, Mobile Engineering.
	        //   For iOS: General case.
	        //   This needs to be removed once we have a better solution from the encino team.
	        //
	        this.enterFullWindow(); 
	        this.trigger('fullscreenchange'); 

	    } else {
	        // fullscreen isn't supported so we'll just stretch the video element to
	        // fill the viewport
	        this.enterFullWindow();
	        this.trigger('fullscreenchange');
	    }

	    return this;
	};

	/**
	 * Old naming for requestFullscreen
	 * @deprecated for lower case 's' version
	 */
	vjs.Player.prototype.requestFullScreen = function () {
	    vjs.log.warn('player.requestFullScreen() has been deprecated, use player.requestFullscreen() with a lowercase "s")');
	    return this.requestFullscreen();
	};


	/**
	 * Return the video to its normal size after having been in full screen mode
	 *
	 *     myPlayer.exitFullscreen();
	 *
	 * @return {vjs.Player} self
	 */
	vjs.Player.prototype.exitFullscreen = function() {
	    var fsApi = vjs.browser.fullscreenAPI;
	    this.isFullscreen(false);

	    // Check for browser element fullscreen support
	    if (fsApi) {
	        document[fsApi.exitFullscreen]();

	        // Send notification of fullscreen enter and exit to HTML5 player.  2/9/2018, Mobile Engineering.
	        //
	        this.trigger('fullscreenchange'); 

	    } else if (this.tech.supportsFullScreen()) {
	        // Send notification of fullscreen enter and exit to HTML5 player.  2/9/2018, Mobile Engineering.
	        //   For iOS: General case.
	        //   This needs to be removed once we have a better solution from the encino team.
	        //
	        this.exitFullWindow();  
	        this.trigger('fullscreenchange'); 

	    } else {
	        this.exitFullWindow();
	        this.push('fullscreenchange');
	    }

	    return this;
	};

	/**
	 * Old naming for exitFullscreen
	 * @deprecated for exitFullscreen
	 */
	vjs.Player.prototype.cancelFullScreen = function(){
	  vjs.log.warn('player.cancelFullScreen() has been deprecated, use player.exitFullscreen()');
	  return this.exitFullscreen();
	};

	// When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.
	vjs.Player.prototype.enterFullWindow = function(){
	  this.isFullWindow = true;

	  // Storing original doc overflow value to return to when fullscreen is off
	  this.docOrigOverflow = document.documentElement.style.overflow;

	  // Add listener for esc key to exit fullscreen
	  vjs.on(document, 'keydown', vjs.bind(this, this.fullWindowOnEscKey));

	  // Hide any scroll bars
	  document.documentElement.style.overflow = 'hidden';

	  // Apply fullscreen styles
	  vjs.addClass(document.body, 'vjs-full-window');

	  this.trigger('enterFullWindow');
	};
	vjs.Player.prototype.fullWindowOnEscKey = function(event){
	  if (event.keyCode === 27) {
	    if (this.isFullscreen() === true) {
	      this.exitFullscreen();
	    } else {
	      this.exitFullWindow();
	    }
	  }
	};

	vjs.Player.prototype.exitFullWindow = function(){
	  this.isFullWindow = false;
	  vjs.off(document, 'keydown', this.fullWindowOnEscKey);

	  // Unhide scroll bars.
	  document.documentElement.style.overflow = this.docOrigOverflow;

	  // Remove fullscreen styles
	  vjs.removeClass(document.body, 'vjs-full-window');

	  // Resize the box, controller, and poster to original sizes
	  // this.positionAll();
	  this.trigger('exitFullWindow');
	};

	vjs.Player.prototype.selectSource = function(sources){
	  // Loop through each playback technology in the options order
	  for (var i=0,j=this.options_['techOrder'];i<j.length;i++) {
	    var techName = vjs.capitalize(j[i]),
	        tech = window['videojs_apn'][techName];

	    // Check if the current tech is defined before continuing
	    if (!tech) {
	      vjs.log.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
	      continue;
	    }

	    // Check if the browser supports this technology
	    if (tech.isSupported()) {
	      // Loop through each source object
	      for (var a=0,b=sources;a<b.length;a++) {
	        var source = b[a];

	        // Check if source can be played with this technology
	        if (tech['canPlaySource'](source)) {
	          return { source: source, tech: techName };
	        }
	      }
	    }
	  }

	  return false;
	};

	/**
	 * The source function updates the video source
	 *
	 * There are three types of variables you can pass as the argument.
	 *
	 * **URL String**: A URL to the the video file. Use this method if you are sure
	 * the current playback technology (HTML5/Flash) can support the source you
	 * provide. Currently only MP4 files can be used in both HTML5 and Flash.
	 *
	 *     myPlayer.src("http://www.example.com/path/to/video.mp4");
	 *
	 * **Source Object (or element):** A javascript object containing information
	 * about the source file. Use this method if you want the player to determine if
	 * it can support the file using the type information.
	 *
	 *     myPlayer.src({ type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" });
	 *
	 * **Array of Source Objects:** To provide multiple versions of the source so
	 * that it can be played using HTML5 across browsers you can use an array of
	 * source objects. Video.js will detect which version is supported and load that
	 * file.
	 *
	 *     myPlayer.src([
	 *       { type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" },
	 *       { type: "video/webm", src: "http://www.example.com/path/to/video.webm" },
	 *       { type: "video/ogg", src: "http://www.example.com/path/to/video.ogv" }
	 *     ]);
	 *
	 * @param  {String|Object|Array=} source The source URL, object, or array of sources
	 * @return {String} The current video source when getting
	 * @return {String} The player when setting
	 */
	vjs.Player.prototype.src = function(source){
	  if (source === undefined) {
	    return this.techGet('src');
	  }

	  // case: Array of source objects to choose from and pick the best to play
	  if (vjs.obj.isArray(source)) {
	    this.sourceList_(source);

	  // case: URL String (http://myvideo...)
	  } else if (typeof source === 'string') {
	    // create a source object from the string
	    this.src({ src: source });

	  // case: Source object { src: '', type: '' ... }
	  } else if (source instanceof Object) {
	    // check if the source has a type and the loaded tech cannot play the source
	    // if there's no type we'll just try the current tech
	    if (source.type && !window['videojs_apn'][this.techName]['canPlaySource'](source)) {
	      // create a source list with the current source and send through
	      // the tech loop to check for a compatible technology
	      this.sourceList_([source]);
	    } else {
	      this.cache_.src = source.src;
	      this.currentType_ = source.type || '';

	      // wait until the tech is ready to set the source
	      this.ready(function(){

	        // The setSource tech method was added with source handlers
	        // so older techs won't support it
	        // We need to check the direct prototype for the case where subclasses
	        // of the tech do not support source handlers
	        if (window['videojs_apn'][this.techName].prototype.hasOwnProperty('setSource')) {
	          this.techCall('setSource', source);
	        } else {
	          this.techCall('src', source.src);
	        }

	        if (this.options_['preload'] == 'auto') {
	          this.load();
	        }

	        if (this.options_['autoplay']) {
	          this.play();
	        }
	      });
	    }
	  }

	  return this;
	};

	/**
	 * Handle an array of source objects
	 * @param  {[type]} sources Array of source objects
	 * @private
	 */
	vjs.Player.prototype.sourceList_ = function(sources){
	  var sourceTech = this.selectSource(sources);

	  if (sourceTech) {
	    if (sourceTech.tech === this.techName) {
	      // if this technology is already loaded, set the source
	      this.src(sourceTech.source);
	    } else {
	      // load this technology with the chosen source
	      this.loadTech(sourceTech.tech, sourceTech.source);
	    }
	  } else {
	    // We need to wrap this in a timeout to give folks a chance to add error event handlers
	    this.setTimeout( function() {
	      this.error({ code: 4, message: this.localize(this.options()['notSupportedMessage']) });
	    }, 0);

	    // we could not find an appropriate tech, but let's still notify the delegate that this is it
	    // this needs a better comment about why this is needed
	    this.triggerReady();
	  }
	};

	/**
	 * Begin loading the src data.
	 * @return {vjs.Player} Returns the player
	 */
	vjs.Player.prototype.load = function(){
	  this.techCall('load');
	  return this;
	};

	/**
	 * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
	 * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
	 * @return {String} The current source
	 */
	vjs.Player.prototype.currentSrc = function(){
	  return this.techGet('currentSrc') || this.cache_.src || '';
	};

	/**
	 * Get the current source type e.g. video/mp4
	 * This can allow you rebuild the current source object so that you could load the same
	 * source and tech later
	 * @return {String} The source MIME type
	 */
	vjs.Player.prototype.currentType = function(){
	    return this.currentType_ || '';
	};

	/**
	 * Get or set the preload attribute.
	 * @return {String} The preload attribute value when getting
	 * @return {vjs.Player} Returns the player when setting
	 */
	vjs.Player.prototype.preload = function(value){
	  if (value !== undefined) {
	    this.techCall('setPreload', value);
	    this.options_['preload'] = value;
	    return this;
	  }
	  return this.techGet('preload');
	};

	/**
	 * Get or set the autoplay attribute.
	 * @return {String} The autoplay attribute value when getting
	 * @return {vjs.Player} Returns the player when setting
	 */
	vjs.Player.prototype.autoplay = function(value){
	  if (value !== undefined) {
	    this.techCall('setAutoplay', value);
	    this.options_['autoplay'] = value;
	    return this;
	  }
	  return this.techGet('autoplay', value);
	};

	/**
	 * Get or set the loop attribute on the video element.
	 * @return {String} The loop attribute value when getting
	 * @return {vjs.Player} Returns the player when setting
	 */
	vjs.Player.prototype.loop = function(value){
	  if (value !== undefined) {
	    this.techCall('setLoop', value);
	    this.options_['loop'] = value;
	    return this;
	  }
	  return this.techGet('loop');
	};

	/**
	 * the url of the poster image source
	 * @type {String}
	 * @private
	 */
	vjs.Player.prototype.poster_;

	/**
	 * get or set the poster image source url
	 *
	 * ##### EXAMPLE:
	 *
	 *     // getting
	 *     var currentPoster = myPlayer.poster();
	 *
	 *     // setting
	 *     myPlayer.poster('http://example.com/myImage.jpg');
	 *
	 * @param  {String=} [src] Poster image source URL
	 * @return {String} poster URL when getting
	 * @return {vjs.Player} self when setting
	 */
	vjs.Player.prototype.poster = function(src){
	  if (src === undefined) {
	    return this.poster_;
	  }

	  // The correct way to remove a poster is to set as an empty string
	  // other falsey values will throw errors
	  if (!src) {
	    src = '';
	  }

	  // update the internal poster variable
	  this.poster_ = src;

	  // update the tech's poster
	  this.techCall('setPoster', src);

	  // alert components that the poster has been set
	  this.trigger('posterchange');

	  return this;
	};

	/**
	 * Whether or not the controls are showing
	 * @type {Boolean}
	 * @private
	 */
	vjs.Player.prototype.controls_;

	/**
	 * Get or set whether or not the controls are showing.
	 * @param  {Boolean} controls Set controls to showing or not
	 * @return {Boolean}    Controls are showing
	 */
	vjs.Player.prototype.controls = function(bool){
	  if (bool !== undefined) {
	    bool = !!bool; // force boolean
	    // Don't trigger a change event unless it actually changed
	    if (this.controls_ !== bool) {
	      this.controls_ = bool;
	      if (bool) {
	        this.removeClass('vjs-controls-disabled');
	        this.addClass('vjs-controls-enabled');
	        this.trigger('controlsenabled');
	      } else {
	        this.removeClass('vjs-controls-enabled');
	        this.addClass('vjs-controls-disabled');
	        this.trigger('controlsdisabled');
	      }
	    }
	    return this;
	  }
	  return this.controls_;
	};

	vjs.Player.prototype.usingNativeControls_;

	/**
	 * Toggle native controls on/off. Native controls are the controls built into
	 * devices (e.g. default iPhone controls), Flash, or other techs
	 * (e.g. Vimeo Controls)
	 *
	 * **This should only be set by the current tech, because only the tech knows
	 * if it can support native controls**
	 *
	 * @param  {Boolean} bool    True signals that native controls are on
	 * @return {vjs.Player}      Returns the player
	 * @private
	 */
	vjs.Player.prototype.usingNativeControls = function(bool){
	  if (bool !== undefined) {
	    bool = !!bool; // force boolean
	    // Don't trigger a change event unless it actually changed
	    if (this.usingNativeControls_ !== bool) {
	      this.usingNativeControls_ = bool;
	      if (bool) {
	        this.addClass('vjs-using-native-controls');

	        /**
	         * player is using the native device controls
	         *
	         * @event usingnativecontrols
	         * @memberof vjs.Player
	         * @instance
	         * @private
	         */
	        this.trigger('usingnativecontrols');
	      } else {
	        this.removeClass('vjs-using-native-controls');

	        /**
	         * player is using the custom HTML controls
	         *
	         * @event usingcustomcontrols
	         * @memberof vjs.Player
	         * @instance
	         * @private
	         */
	        this.trigger('usingcustomcontrols');
	      }
	    }
	    return this;
	  }
	  return this.usingNativeControls_;
	};

	/**
	 * Store the current media error
	 * @type {Object}
	 * @private
	 */
	vjs.Player.prototype.error_ = null;

	/**
	 * Set or get the current MediaError
	 * @param  {*} err A MediaError or a String/Number to be turned into a MediaError
	 * @return {vjs.MediaError|null}     when getting
	 * @return {vjs.Player}              when setting
	 */
	vjs.Player.prototype.error = function(err){
	  if (err === undefined) {
	    return this.error_;
	  }

	  // restoring to default
	  if (err === null) {
	    this.error_ = err;
	    this.removeClass('vjs-error');
	    return this;
	  }

	  // error instance
	  if (err instanceof vjs.MediaError) {
	    this.error_ = err;
	  } else {
	    this.error_ = new vjs.MediaError(err);
	  }

	  // fire an error event on the player
	  this.trigger('error');

	  // add the vjs-error classname to the player
	  this.addClass('vjs-error');

	  // log the name of the error type and any message
	  // ie8 just logs "[object object]" if you just log the error object
	  vjs.log.error('(CODE:'+this.error_.code+' '+vjs.MediaError.errorTypes[this.error_.code]+')', this.error_.message, this.error_);

	  return this;
	};

	/**
	 * Returns whether or not the player is in the "ended" state.
	 * @return {Boolean} True if the player is in the ended state, false if not.
	 */
	vjs.Player.prototype.ended = function(){ return this.techGet('ended'); };

	/**
	 * Returns whether or not the player is in the "seeking" state.
	 * @return {Boolean} True if the player is in the seeking state, false if not.
	 */
	vjs.Player.prototype.seeking = function(){ return this.techGet('seeking'); };

	/**
	 * Returns the TimeRanges of the media that are currently available
	 * for seeking to.
	 * @return {TimeRanges} the seekable intervals of the media timeline
	 */
	vjs.Player.prototype.seekable = function(){ return this.techGet('seekable'); };

	// When the player is first initialized, trigger activity so components
	// like the control bar show themselves if needed
	vjs.Player.prototype.userActivity_ = true;
	vjs.Player.prototype.reportUserActivity = function(event){
	  this.userActivity_ = true;
	};

	vjs.Player.prototype.userActive_ = true;
	vjs.Player.prototype.userActive = function(bool){
	  if (bool !== undefined) {
	    bool = !!bool;
	    if (bool !== this.userActive_) {
	      this.userActive_ = bool;
	      if (bool) {
	        // If the user was inactive and is now active we want to reset the
	        // inactivity timer
	        this.userActivity_ = true;
	        this.removeClass('vjs-user-inactive');
	        this.addClass('vjs-user-active');
	        this.trigger('useractive');
	      } else {
	        // We're switching the state to inactive manually, so erase any other
	        // activity
	        this.userActivity_ = false;

	        // Chrome/Safari/IE have bugs where when you change the cursor it can
	        // trigger a mousemove event. This causes an issue when you're hiding
	        // the cursor when the user is inactive, and a mousemove signals user
	        // activity. Making it impossible to go into inactive mode. Specifically
	        // this happens in fullscreen when we really need to hide the cursor.
	        //
	        // When this gets resolved in ALL browsers it can be removed
	        // https://code.google.com/p/chromium/issues/detail?id=103041
	        if(this.tech) {
	          this.tech.one('mousemove', function(e){
	            e.stopPropagation();
	            e.preventDefault();
	          });
	        }

	        this.removeClass('vjs-user-active');
	        this.addClass('vjs-user-inactive');
	        this.trigger('userinactive');
	      }
	    }
	    return this;
	  }
	  return this.userActive_;
	};

	vjs.Player.prototype.listenForUserActivity = function(){
	  var onActivity, onMouseMove, onMouseDown, mouseInProgress, onMouseUp,
	      activityCheck, inactivityTimeout, lastMoveX, lastMoveY;

	  onActivity = vjs.bind(this, this.reportUserActivity);

	  onMouseMove = function(e) {
	    // #1068 - Prevent mousemove spamming
	    // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
	    if(e.screenX != lastMoveX || e.screenY != lastMoveY) {
	      lastMoveX = e.screenX;
	      lastMoveY = e.screenY;
	      onActivity();
	    }
	  };

	  onMouseDown = function() {
	    onActivity();
	    // For as long as the they are touching the device or have their mouse down,
	    // we consider them active even if they're not moving their finger or mouse.
	    // So we want to continue to update that they are active
	    this.clearInterval(mouseInProgress);
	    // Setting userActivity=true now and setting the interval to the same time
	    // as the activityCheck interval (250) should ensure we never miss the
	    // next activityCheck
	    mouseInProgress = this.setInterval(onActivity, 250);
	  };

	  onMouseUp = function(event) {
	    onActivity();
	    // Stop the interval that maintains activity if the mouse/touch is down
	    this.clearInterval(mouseInProgress);
	  };

	  // Any mouse movement will be considered user activity
	  this.on('mousedown', onMouseDown);
	  this.on('mousemove', onMouseMove);
	  this.on('mouseup', onMouseUp);

	  // Listen for keyboard navigation
	  // Shouldn't need to use inProgress interval because of key repeat
	  this.on('keydown', onActivity);
	  this.on('keyup', onActivity);

	  // Run an interval every 250 milliseconds instead of stuffing everything into
	  // the mousemove/touchmove function itself, to prevent performance degradation.
	  // `this.reportUserActivity` simply sets this.userActivity_ to true, which
	  // then gets picked up by this loop
	  // http://ejohn.org/blog/learning-from-twitter/
	  activityCheck = this.setInterval(function() {
	    // Check to see if mouse/touch activity has happened
	    if (this.userActivity_) {
	      // Reset the activity tracker
	      this.userActivity_ = false;

	      // If the user state was inactive, set the state to active
	      this.userActive(true);

	      // Clear any existing inactivity timeout to start the timer over
	      this.clearTimeout(inactivityTimeout);

	      var timeout = this.options()['inactivityTimeout'];
	      if (timeout > 0) {
	          // In <timeout> milliseconds, if no more activity has occurred the
	          // user will be considered inactive
	          inactivityTimeout = this.setTimeout(function () {
	              // Protect against the case where the inactivityTimeout can trigger just
	              // before the next user activity is picked up by the activityCheck loop
	              // causing a flicker
	              if (!this.userActivity_) {
	                  this.userActive(false);
	              }
	          }, timeout);
	      }
	    }
	  }, 250);
	};

	/**
	 * Gets or sets the current playback rate.
	 * @param  {Boolean} rate   New playback rate to set.
	 * @return {Number}         Returns the new playback rate when setting
	 * @return {Number}         Returns the current playback rate when getting
	 */
	vjs.Player.prototype.playbackRate = function(rate) {
	  if (rate !== undefined) {
	    this.techCall('setPlaybackRate', rate);
	    return this;
	  }

	  if (this.tech && this.tech['featuresPlaybackRate']) {
	    return this.techGet('playbackRate');
	  } else {
	    return 1.0;
	  }

	};

	/**
	 * Store the current audio state
	 * @type {Boolean}
	 * @private
	 */
	vjs.Player.prototype.isAudio_ = false;

	/**
	 * Gets or sets the audio flag
	 *
	 * @param  {Boolean} bool    True signals that this is an audio player.
	 * @return {Boolean}         Returns true if player is audio, false if not when getting
	 * @return {vjs.Player}      Returns the player if setting
	 * @private
	 */
	vjs.Player.prototype.isAudio = function(bool) {
	  if (bool !== undefined) {
	    this.isAudio_ = !!bool;
	    return this;
	  }

	  return this.isAudio_;
	};

	/**
	 * Returns the current state of network activity for the element, from
	 * the codes in the list below.
	 * - NETWORK_EMPTY (numeric value 0)
	 *   The element has not yet been initialised. All attributes are in
	 *   their initial states.
	 * - NETWORK_IDLE (numeric value 1)
	 *   The element's resource selection algorithm is active and has
	 *   selected a resource, but it is not actually using the network at
	 *   this time.
	 * - NETWORK_LOADING (numeric value 2)
	 *   The user agent is actively trying to download data.
	 * - NETWORK_NO_SOURCE (numeric value 3)
	 *   The element's resource selection algorithm is active, but it has
	 *   not yet found a resource to use.
	 * @return {Number} the current network activity state
	 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
	 */
	vjs.Player.prototype.networkState = function(){
	  return this.techGet('networkState');
	};

	/**
	 * Returns a value that expresses the current state of the element
	 * with respect to rendering the current playback position, from the
	 * codes in the list below.
	 * - HAVE_NOTHING (numeric value 0)
	 *   No information regarding the media resource is available.
	 * - HAVE_METADATA (numeric value 1)
	 *   Enough of the resource has been obtained that the duration of the
	 *   resource is available.
	 * - HAVE_CURRENT_DATA (numeric value 2)
	 *   Data for the immediate current playback position is available.
	 * - HAVE_FUTURE_DATA (numeric value 3)
	 *   Data for the immediate current playback position is available, as
	 *   well as enough data for the user agent to advance the current
	 *   playback position in the direction of playback.
	 * - HAVE_ENOUGH_DATA (numeric value 4)
	 *   The user agent estimates that enough data is available for
	 *   playback to proceed uninterrupted.
	 * @return {Number} the current playback rendering state
	 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
	 */
	vjs.Player.prototype.readyState = function(){
	  return this.techGet('readyState');
	};

	/**
	 * Text tracks are tracks of timed text events.
	 * Captions - text displayed over the video for the hearing impaired
	 * Subtitles - text displayed over the video for those who don't understand language in the video
	 * Chapters - text displayed in a menu allowing the user to jump to particular points (chapters) in the video
	 * Descriptions (not supported yet) - audio descriptions that are read back to the user by a screen reading device
	 */

	/**
	 * Get an array of associated text tracks. captions, subtitles, chapters, descriptions
	 * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
	 * @return {Array}           Array of track objects
	 */
	vjs.Player.prototype.textTracks = function(){
	  // cannot use techGet directly because it checks to see whether the tech is ready.
	  // Flash is unlikely to be ready in time but textTracks should still work.
	  return this.tech && this.tech['textTracks']();
	};

	vjs.Player.prototype.remoteTextTracks = function() {
	  return this.tech && this.tech['remoteTextTracks']();
	};

	/**
	 * Add a text track
	 * In addition to the W3C settings we allow adding additional info through options.
	 * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
	 * @param {String}  kind        Captions, subtitles, chapters, descriptions, or metadata
	 * @param {String=} label       Optional label
	 * @param {String=} language    Optional language
	 */
	vjs.Player.prototype.addTextTrack = function(kind, label, language) {
	  return this.tech && this.tech['addTextTrack'](kind, label, language);
	};

	vjs.Player.prototype.addRemoteTextTrack = function(options) {
	  return this.tech && this.tech['addRemoteTextTrack'](options);
	};

	vjs.Player.prototype.removeRemoteTextTrack = function(track) {
	  this.tech && this.tech['removeRemoteTextTrack'](track);
	};

	// Methods to add support for
	// initialTime: function(){ return this.techCall('initialTime'); },
	// startOffsetTime: function(){ return this.techCall('startOffsetTime'); },
	// played: function(){ return this.techCall('played'); },
	// seekable: function(){ return this.techCall('seekable'); },
	// videoTracks: function(){ return this.techCall('videoTracks'); },
	// audioTracks: function(){ return this.techCall('audioTracks'); },
	// videoWidth: function(){ return this.techCall('videoWidth'); },
	// videoHeight: function(){ return this.techCall('videoHeight'); },
	// defaultPlaybackRate: function(){ return this.techCall('defaultPlaybackRate'); },
	// mediaGroup: function(){ return this.techCall('mediaGroup'); },
	// controller: function(){ return this.techCall('controller'); },
	// defaultMuted: function(){ return this.techCall('defaultMuted'); }

	// TODO
	// currentSrcList: the array of sources including other formats and bitrates
	// playList: array of source lists in order of playback

	/**
	 * Container of main controls
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 * @extends vjs.Component
	 */
	vjs.ControlBar = vjs.Component.extend();

	vjs.ControlBar.prototype.options_ = {
	    loadEvent: 'play',
	    children: {
	        'playToggle': {},
	        'currentTimeDisplay': {},
	        'timeDivider': {},
	        'durationDisplay': {},
	        'remainingTimeDisplay': {},
	        // 'liveDisplay': {},
	        'progressControl': {},
	        'fullscreenToggle': {},
	        'volumeControl': {},
	        'muteToggle': {},
	        // 'volumeMenuButton': {},
	        'playbackRateMenuButton': {}
	        // 'subtitlesButton': {},
	        // 'captionsButton': {},
	        // 'chaptersButton': {}
	    }
	};

	vjs.ControlBar.prototype.createEl = function(){
	  return vjs.createEl('div', {
	    className: 'vjs-control-bar'
	  });
	};

	/**
	 * Displays the live indicator
	 * TODO - Future make it click to snap to live
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.LiveDisplay = vjs.Component.extend({
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	  }
	});

	vjs.LiveDisplay.prototype.createEl = function(){
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-live-controls vjs-control'
	  });

	  this.contentEl_ = vjs.createEl('div', {
	    className: 'vjs-live-display',
	    innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE'),
	    'aria-live': 'off'
	  });

	  el.appendChild(this.contentEl_);

	  return el;
	};

	/**
	 * Button to toggle between play and pause
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.PlayToggle = vjs.Button.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);

	    this.on(player, 'play', this.onPlay);
	    this.on(player, 'pause', this.onPause);
	  }
	});

	vjs.PlayToggle.prototype.buttonText = 'Play';

	vjs.PlayToggle.prototype.buildCSSClass = function(){
	  return 'vjs-play-control ' + vjs.Button.prototype.buildCSSClass.call(this);
	};

	// OnClick - Toggle between play and pause
	vjs.PlayToggle.prototype.onClick = function(){
	  //VIDLA-1252-1121 Causing double play. Play is handled in framework Player Manager via explicit or programmatic play pause.
	  /*
	  if (this.player_.paused()) {
	    this.player_.play();
	  } else {
	    this.player_.pause();
	  }
	  */
	};

	  // OnPlay - Add the vjs-playing class to the element so it can change appearance
	vjs.PlayToggle.prototype.onPlay = function(){
	  this.removeClass('vjs-paused');
	  this.addClass('vjs-playing');
	  this.el_.children[0].children[0].innerHTML = this.localize('Pause'); // change the button text to "Pause"
	};

	  // OnPause - Add the vjs-paused class to the element so it can change appearance
	vjs.PlayToggle.prototype.onPause = function(){
	  this.removeClass('vjs-playing');
	  this.addClass('vjs-paused');
	  this.el_.children[0].children[0].innerHTML = this.localize('Play'); // change the button text to "Play"
	};

	/**
	 * Displays the current time
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.CurrentTimeDisplay = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    this.on(player, 'timeupdate', this.updateContent);
	  }
	});

	vjs.CurrentTimeDisplay.prototype.createEl = function(){
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-current-time vjs-time-controls vjs-control'
	  });

	  this.contentEl_ = vjs.createEl('div', {
	    className: 'vjs-current-time-display',
	    innerHTML: '<span class="vjs-control-text">Current Time </span>' + '0:00', // label the current time for screen reader users
	    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
	  });

	  el.appendChild(this.contentEl_);
	  return el;
	};

	vjs.CurrentTimeDisplay.prototype.updateContent = function(){
	  // Allows for smooth scrubbing, when player can't keep up.
	  var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
	  this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Current Time') + '</span> ' + vjs.formatTime(time, this.player_.duration());
	};

	/**
	 * Displays the duration
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.DurationDisplay = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    // this might need to be changed to 'durationchange' instead of 'timeupdate' eventually,
	    // however the durationchange event fires before this.player_.duration() is set,
	    // so the value cannot be written out using this method.
	    // Once the order of durationchange and this.player_.duration() being set is figured out,
	    // this can be updated.
	    this.on(player, 'timeupdate', this.updateContent);
	    this.on(player, 'loadedmetadata', this.updateContent);
	  }
	});

	vjs.DurationDisplay.prototype.createEl = function(){
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-duration vjs-time-controls vjs-control'
	  });

	  this.contentEl_ = vjs.createEl('div', {
	    className: 'vjs-duration-display',
	    innerHTML: '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> ' + '0:00', // label the duration time for screen reader users
	    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
	  });

	  el.appendChild(this.contentEl_);
	  return el;
	};

	vjs.DurationDisplay.prototype.updateContent = function(){
	  var duration = this.player_.duration();
	  if (duration) {
	      this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> ' + vjs.formatTime(duration); // label the duration time for screen reader users
	  }
	};

	/**
	 * The separator between the current time and duration
	 *
	 * Can be hidden if it's not needed in the design.
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.TimeDivider = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	  }
	});

	vjs.TimeDivider.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-time-divider',
	    innerHTML: '<div><span>/</span></div>'
	  });
	};

	/**
	 * Displays the time left in the video
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.RemainingTimeDisplay = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    this.on(player, 'timeupdate', this.updateContent);
	  }
	});

	vjs.RemainingTimeDisplay.prototype.createEl = function(){
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-remaining-time vjs-time-controls vjs-control'
	  });

	  this.contentEl_ = vjs.createEl('div', {
	    className: 'vjs-remaining-time-display',
	    innerHTML: '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> ' + '-0:00', // label the remaining time for screen reader users
	    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
	  });

	  el.appendChild(this.contentEl_);
	  return el;
	};

	vjs.RemainingTimeDisplay.prototype.updateContent = function(){
	  if (this.player_.duration()) {
	    this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> ' + '-'+ vjs.formatTime(this.player_.remainingTime());
	  }

	  // Allows for smooth scrubbing, when player can't keep up.
	  // var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
	  // this.contentEl_.innerHTML = vjs.formatTime(time, this.player_.duration());
	};

	/**
	 * Toggle fullscreen video
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @extends vjs.Button
	 */
	vjs.FullscreenToggle = vjs.Button.extend({
	  /**
	   * @constructor
	   * @memberof vjs.FullscreenToggle
	   * @instance
	   */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);
	  }
	});

	vjs.FullscreenToggle.prototype.buttonText = 'Fullscreen';

	vjs.FullscreenToggle.prototype.buildCSSClass = function(){
	  return 'vjs-fullscreen-control ' + vjs.Button.prototype.buildCSSClass.call(this);
	};

	vjs.FullscreenToggle.prototype.onClick = function(){
	  if (!this.player_.isFullscreen()) {
	    this.player_.requestFullscreen();
	    this.controlText_.innerHTML = this.localize('Non-Fullscreen');
	  } else {
	    this.player_.exitFullscreen();
	    this.controlText_.innerHTML = this.localize('Fullscreen');
	  }
	};

	/**
	 * The Progress Control component contains the seek bar, load progress,
	 * and play progress
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.ProgressControl = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	  }
	});

	vjs.ProgressControl.prototype.options_ = {
	  children: {
	    'seekBar': {}
	  }
	};

	vjs.ProgressControl.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-progress-control vjs-control'
	  });
	};

	/**
	 * Seek Bar and holder for the progress bars
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.SeekBar = vjs.Slider.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Slider.call(this, player, options);
	    this.on(player, 'timeupdate', this.updateARIAAttributes);
	    player.ready(vjs.bind(this, this.updateARIAAttributes));
	  }
	});

	vjs.SeekBar.prototype.options_ = {
	  children: {
	    'loadProgressBar': {},
	    'playProgressBar': {},
	    'seekHandle': {}
	  },
	  'barName': 'playProgressBar',
	  'handleName': 'seekHandle'
	};

	vjs.SeekBar.prototype.playerEvent = 'timeupdate';

	vjs.SeekBar.prototype.createEl = function(){
	  return vjs.Slider.prototype.createEl.call(this, 'div', {
	    className: 'vjs-progress-holder',
	    'aria-label': 'video progress bar'
	  });
	};

	vjs.SeekBar.prototype.updateARIAAttributes = function(){
	    // Allows for smooth scrubbing, when player can't keep up.
	    var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
	    this.el_.setAttribute('aria-valuenow',vjs.round(this.getPercent()*100, 2)); // machine readable value of progress bar (percentage complete)
	    this.el_.setAttribute('aria-valuetext',vjs.formatTime(time, this.player_.duration())); // human readable value of progress bar (time complete)
	};

	vjs.SeekBar.prototype.getPercent = function(){
	  return this.player_.currentTime() / this.player_.duration();
	};




	//remove all Seek Bar interactivity VID-2782 
	/*
	///----- start seek bar interactivity section -----
	vjs.SeekBar.prototype.onMouseDown = function(event){
	  vjs.Slider.prototype.onMouseDown.call(this, event);

	  this.player_.scrubbing = true;
	  this.player_.addClass('vjs-scrubbing');

	  this.videoWasPlaying = !this.player_.paused();
	  this.player_.pause();
	};

	vjs.SeekBar.prototype.onMouseMove = function(event){
	  var newTime = this.calculateDistance(event) * this.player_.duration();

	  // Don't let video end while scrubbing.
	  if (newTime == this.player_.duration()) { newTime = newTime - 0.1; }

	  // Set new time (tell player to seek to new time)
	  this.player_.currentTime(newTime);
	};

	vjs.SeekBar.prototype.onMouseUp = function(event){
	  vjs.Slider.prototype.onMouseUp.call(this, event);

	  this.player_.scrubbing = false;
	  this.player_.removeClass('vjs-scrubbing');
	  if (this.videoWasPlaying) {
	    this.player_.play();
	  }
	};

	vjs.SeekBar.prototype.stepForward = function(){
	  this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users
	};

	vjs.SeekBar.prototype.stepBack = function(){  
	  this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users
	  
	};
	///----- end seek bar interactivity section -----
	*/




	/**
	 * Shows load progress
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.LoadProgressBar = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	    this.on(player, 'progress', this.update);
	  }
	});

	vjs.LoadProgressBar.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-load-progress',
	    innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
	  });
	};

	vjs.LoadProgressBar.prototype.update = function(){
	  var i, start, end, part,
	      buffered = this.player_.buffered(),
	      duration = this.player_.duration(),
	      bufferedEnd = this.player_.bufferedEnd(),
	      children = this.el_.children,
	      // get the percent width of a time compared to the total end
	      percentify = function (time, end){
	        var percent = (time / end) || 0; // no NaN
	        return (percent * 100) + '%';
	      };

	  // update the width of the progress bar
	  this.el_.style.width = percentify(bufferedEnd, duration);

	  // add child elements to represent the individual buffered time ranges
	  for (i = 0; i < buffered.length; i++) {
	    start = buffered.start(i),
	    end = buffered.end(i),
	    part = children[i];

	    if (!part) {
	      part = this.el_.appendChild(vjs.createEl());
	    }

	    // set the percent based on the width of the progress bar (bufferedEnd)
	    part.style.left = percentify(start, bufferedEnd);
	    part.style.width = percentify(end - start, bufferedEnd);
	  }

	  // remove unused buffered range elements
	  for (i = children.length; i > buffered.length; i--) {
	    this.el_.removeChild(children[i-1]);
	  }
	};

	/**
	 * Shows play progress
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.PlayProgressBar = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	  }
	});

	vjs.PlayProgressBar.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-play-progress',
	    innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
	  });
	};

	/**
	 * The Seek Handle shows the current position of the playhead during playback,
	 * and can be dragged to adjust the playhead.
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.SeekHandle = vjs.SliderHandle.extend({
	  init: function(player, options) {
	    vjs.SliderHandle.call(this, player, options);
	    this.on(player, 'timeupdate', this.updateContent);
	  }
	});

	/**
	 * The default value for the handle content, which may be read by screen readers
	 *
	 * @type {String}
	 * @private
	 */
	vjs.SeekHandle.prototype.defaultValue = '00:00';

	/** @inheritDoc */
	vjs.SeekHandle.prototype.createEl = function() {
	  return vjs.SliderHandle.prototype.createEl.call(this, 'div', {
	    className: 'vjs-seek-handle',
	    'aria-live': 'off'
	  });
	};

	vjs.SeekHandle.prototype.updateContent = function() {
	  var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
	  this.el_.innerHTML = '<span class="vjs-control-text">' + vjs.formatTime(time, this.player_.duration()) + '</span>';
	};

	/**
	 * The component for controlling the volume level
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.VolumeControl = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    // hide volume controls when they're not supported by the current tech
	    if (player.tech && player.tech['featuresVolumeControl'] === false) {
	      this.addClass('vjs-hidden');
	    }
	    this.on(player, 'loadstart', function(){
	      if (player.tech['featuresVolumeControl'] === false) {
	        this.addClass('vjs-hidden');
	      } else {
	        this.removeClass('vjs-hidden');
	      }
	    });
	  }
	});

	vjs.VolumeControl.prototype.options_ = {
	  children: {
	    'volumeBar': {}
	  }
	};

	vjs.VolumeControl.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-volume-control vjs-control'
	  });
	};

	/**
	 * The bar that contains the volume level and can be clicked on to adjust the level
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.VolumeBar = vjs.Slider.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Slider.call(this, player, options);
	    this.on(player, 'volumechange', this.updateARIAAttributes);
	    player.ready(vjs.bind(this, this.updateARIAAttributes));
	  }
	});

	vjs.VolumeBar.prototype.updateARIAAttributes = function(){
	  // Current value of volume bar as a percentage
	  this.el_.setAttribute('aria-valuenow',vjs.round(this.player_.volume()*100, 2));
	  this.el_.setAttribute('aria-valuetext',vjs.round(this.player_.volume()*100, 2)+'%');
	};

	vjs.VolumeBar.prototype.options_ = {
	  children: {
	    'volumeLevel': {},
	    'volumeHandle': {}
	  },
	  'barName': 'volumeLevel',
	  'handleName': 'volumeHandle'
	};

	vjs.VolumeBar.prototype.playerEvent = 'volumechange';

	vjs.VolumeBar.prototype.createEl = function(){
	  return vjs.Slider.prototype.createEl.call(this, 'div', {
	    className: 'vjs-volume-bar',
	    'aria-label': 'volume level'
	  });
	};

	vjs.VolumeBar.prototype.onMouseMove = function(event) {
	  if (this.player_.muted()) {
	    //this.player_.muted(false);
	  }

	  // VIDLA-326 (volume bar not functional in Overlay player)
	  if (global_options.hasOwnProperty('overlayPlayer')) {
	    if (event.srcElement && event.srcElement.tagName!="VIDEO" && event.srcElement.className.indexOf("vjs") >= 0) {
	        if (event.srcElement.tagName!="VIDEO" && event.srcElement.className && event.srcElement.className.indexOf("vjs") >= 0) {
	            this.player_.volume(this.calculateDistance(event));
	        }
	    }
	    // VIDLA-920 (volume bar not functional in Overlay player in Firefox)
	    else if (event.currentTarget) {
	        if (event.currentTarget.tagName!="VIDEO" && event.currentTarget.className && event.currentTarget.className.indexOf("vjs") >= 0) {
	            this.player_.volume(this.calculateDistance(event));
	        }
	    }
	  }
	  else {
	    //console.log("================ id : " + global_options.iframeVideoWrapperId);
	    //TODO minthe added to fix VID-209
	    var targetDocument = document.getElementById(global_options.iframeVideoWrapperId).contentWindow.document;
	    var targetElement = targetDocument.elementFromPoint(event.clientX, event.clientY);
	    if (targetElement && targetElement.tagName!="VIDEO" && targetElement.className.indexOf("vjs") >= 0) {
	        this.player_.volume(this.calculateDistance(event));
	    }
	  }
	};

	vjs.VolumeBar.prototype.getPercent = function(){
	  if (this.player_.muted()) {
	    return 0;
	  } else {
	    return this.player_.volume();
	  }
	};

	vjs.VolumeBar.prototype.stepForward = function(){
	  this.player_.volume(this.player_.volume() + 0.1);
	};

	vjs.VolumeBar.prototype.stepBack = function(){
	  this.player_.volume(this.player_.volume() - 0.1);
	};

	/**
	 * Shows volume level
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.VolumeLevel = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	  }
	});

	vjs.VolumeLevel.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-volume-level',
	    innerHTML: '<span class="vjs-control-text"></span>'
	  });
	};

	/**
	 * The volume handle can be dragged to adjust the volume level
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	 vjs.VolumeHandle = vjs.SliderHandle.extend();

	 vjs.VolumeHandle.prototype.defaultValue = '00:00';

	 /** @inheritDoc */
	 vjs.VolumeHandle.prototype.createEl = function(){
	   return vjs.SliderHandle.prototype.createEl.call(this, 'div', {
	     className: 'vjs-volume-handle'
	   });
	 };

	/**
	 * A button component for muting the audio
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.MuteToggle = vjs.Button.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);

	    this.on(player, 'volumechange', this.update);
	    var showMuteForIOS10 = player.getMuteSettingsForIOS10();
	    // hide mute toggle if the current tech doesn't support volume control
	    if (player.tech && player.tech['featuresVolumeControl'] === false && !showMuteForIOS10) {
	      this.addClass('vjs-hidden');
	    }

	    this.on(player, 'loadstart', function(){
	      if (player.tech['featuresVolumeControl'] === false && !showMuteForIOS10) {
	        this.addClass('vjs-hidden');
	      } else {
	        this.removeClass('vjs-hidden');
	      }
	    });
	  }
	});

	vjs.MuteToggle.prototype.createEl = function(){
	  return vjs.Button.prototype.createEl.call(this, 'div', {
	    className: 'vjs-mute-control vjs-control',
	    innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
	  });
	};

	vjs.MuteToggle.prototype.onClick = function(){
	  // VIDLA-989 if user explicitly unmutes by clicking the mute button and the volume is 0,
	  // then we set an intermediate volume and unmute.
	  if(this.player_.muted()){
	    var vol = this.player_.volume();
	    if(vol === 0){
	      vol = 0.5;
	      this.player_.volume(vol);
	    }
	  }
	  this.player_.muted( this.player_.muted() ? false : true );
	};

	vjs.MuteToggle.prototype.update = function(){
	  var vol = this.player_.volume(),
	      level = 3;

	  if (vol === 0 || this.player_.muted()) {
	    level = 0;
	  } else if (vol < 0.33) {
	    level = 1;
	  } else if (vol < 0.67) {
	    level = 2;
	  }

	  // Add null check here to avoid trying to access the element if it's already been disposed of (happens when showMute is false)
	  // TODO: Consider using disable() instead of dispose() when showMute is false, this should permanently hide it but the element
	  // still exists so we don't need null checks before accessing it.
	  if(this.el_) {
	    // Don't rewrite the button text if the actual text doesn't change.
	    // This causes unnecessary and confusing information for screen reader users.
	    // This check is needed because this function gets called every time the volume level is changed.
	    if(this.player_.muted()){
	        if(this.el_.children[0].children[0].innerHTML!=this.localize('Unmute')){
	            this.el_.children[0].children[0].innerHTML = this.localize('Unmute'); // change the button text to "Unmute"
	        }
	    } else {
	        if(this.el_.children[0].children[0].innerHTML!=this.localize('Mute')){
	            this.el_.children[0].children[0].innerHTML = this.localize('Mute'); // change the button text to "Mute"
	        }
	    }

	    /* TODO improve muted icon classes */
	    for (var i = 0; i < 4; i++) {
	      vjs.removeClass(this.el_, 'vjs-vol-'+i);
	    }
	    vjs.addClass(this.el_, 'vjs-vol-'+level);
	  }
	};

	/**
	 * Menu button with a popup for showing the volume slider.
	 * @constructor
	 */
	vjs.VolumeMenuButton = vjs.MenuButton.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.MenuButton.call(this, player, options);

	    // Same listeners as MuteToggle
	    this.on(player, 'volumechange', this.volumeUpdate);

	    // hide mute toggle if the current tech doesn't support volume control
	    if (player.tech && player.tech['featuresVolumeControl'] === false) {
	      this.addClass('vjs-hidden');
	    }

	    this.on(player, 'loadstart', function(){
	      if (player.tech['featuresVolumeControl'] === false) {
	        this.addClass('vjs-hidden');
	      } else {
	        this.removeClass('vjs-hidden');
	      }
	    });
	    this.addClass('vjs-menu-button');
	  }
	});

	vjs.VolumeMenuButton.prototype.createMenu = function(){
	  var menu = new vjs.Menu(this.player_, {
	    contentElType: 'div'
	  });
	  var vc = new vjs.VolumeBar(this.player_, this.options_['volumeBar']);
	  vc.on('focus', function() {
	    menu.lockShowing();
	  });
	  vc.on('blur', function() {
	    menu.unlockShowing();
	  });
	  menu.addChild(vc);
	  return menu;
	};

	vjs.VolumeMenuButton.prototype.onClick = function(){
	  vjs.MuteToggle.prototype.onClick.call(this);
	  vjs.MenuButton.prototype.onClick.call(this);
	};

	vjs.VolumeMenuButton.prototype.createEl = function(){
	  return vjs.Button.prototype.createEl.call(this, 'div', {
	    className: 'vjs-volume-menu-button vjs-menu-button vjs-control',
	    innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
	  });
	};
	vjs.VolumeMenuButton.prototype.volumeUpdate = vjs.MuteToggle.prototype.update;

	/**
	 * The component for controlling the playback rate
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.PlaybackRateMenuButton = vjs.MenuButton.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.MenuButton.call(this, player, options);

	    this.updateVisibility();
	    this.updateLabel();

	    this.on(player, 'loadstart', this.updateVisibility);
	    this.on(player, 'ratechange', this.updateLabel);
	  }
	});

	vjs.PlaybackRateMenuButton.prototype.buttonText = 'Playback Rate';
	vjs.PlaybackRateMenuButton.prototype.className = 'vjs-playback-rate';

	vjs.PlaybackRateMenuButton.prototype.createEl = function(){
	  var el = vjs.MenuButton.prototype.createEl.call(this);

	  this.labelEl_ = vjs.createEl('div', {
	    className: 'vjs-playback-rate-value',
	    innerHTML: 1.0
	  });

	  el.appendChild(this.labelEl_);

	  return el;
	};

	// Menu creation
	vjs.PlaybackRateMenuButton.prototype.createMenu = function(){
	  var menu = new vjs.Menu(this.player());
	  var rates = this.player().options()['playbackRates'];

	  if (rates) {
	    for (var i = rates.length - 1; i >= 0; i--) {
	      menu.addChild(
	        new vjs.PlaybackRateMenuItem(this.player(), { 'rate': rates[i] + 'x'})
	        );
	    }
	  }

	  return menu;
	};

	vjs.PlaybackRateMenuButton.prototype.updateARIAAttributes = function(){
	  // Current playback rate
	  this.el().setAttribute('aria-valuenow', this.player().playbackRate());
	};

	vjs.PlaybackRateMenuButton.prototype.onClick = function(){
	  // select next rate option
	  var currentRate = this.player().playbackRate();
	  var rates = this.player().options()['playbackRates'];
	  // this will select first one if the last one currently selected
	  var newRate = rates[0];
	  for (var i = 0; i <rates.length ; i++) {
	    if (rates[i] > currentRate) {
	      newRate = rates[i];
	      break;
	    }
	  }
	  this.player().playbackRate(newRate);
	};

	vjs.PlaybackRateMenuButton.prototype.playbackRateSupported = function(){
	  return this.player().tech
	    && this.player().tech['featuresPlaybackRate']
	    && this.player().options()['playbackRates']
	    && this.player().options()['playbackRates'].length > 0
	  ;
	};

	/**
	 * Hide playback rate controls when they're no playback rate options to select
	 */
	vjs.PlaybackRateMenuButton.prototype.updateVisibility = function(){
	  if (this.playbackRateSupported()) {
	    this.removeClass('vjs-hidden');
	  } else {
	    this.addClass('vjs-hidden');
	  }
	};

	/**
	 * Update button label when rate changed
	 */
	vjs.PlaybackRateMenuButton.prototype.updateLabel = function(){
	  if (this.playbackRateSupported()) {
	    this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
	  }
	};

	/**
	 * The specific menu item type for selecting a playback rate
	 *
	 * @constructor
	 */
	vjs.PlaybackRateMenuItem = vjs.MenuItem.extend({
	  contentElType: 'button',
	  /** @constructor */
	  init: function(player, options){
	    var label = this.label = options['rate'];
	    var rate = this.rate = parseFloat(label, 10);

	    // Modify options for parent MenuItem class's init.
	    options['label'] = label;
	    options['selected'] = rate === 1;
	    vjs.MenuItem.call(this, player, options);

	    this.on(player, 'ratechange', this.update);
	  }
	});

	vjs.PlaybackRateMenuItem.prototype.onClick = function(){
	  vjs.MenuItem.prototype.onClick.call(this);
	  this.player().playbackRate(this.rate);
	};

	vjs.PlaybackRateMenuItem.prototype.update = function(){
	  this.selected(this.player().playbackRate() == this.rate);
	};

	/* Poster Image
	================================================================================ */
	/**
	 * The component that handles showing the poster image.
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.PosterImage = vjs.Button.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);

	    this.update();
	    player.on('posterchange', vjs.bind(this, this.update));
	  }
	});

	/**
	 * Clean up the poster image
	 */
	vjs.PosterImage.prototype.dispose = function(){
	  this.player().off('posterchange', this.update);
	  vjs.Button.prototype.dispose.call(this);
	};

	/**
	 * Create the poster image element
	 * @return {Element}
	 */
	vjs.PosterImage.prototype.createEl = function(){
	  var el = vjs.createEl('div', {
	    className: 'vjs-poster',

	    // Don't want poster to be tabbable.
	    tabIndex: -1
	  });

	  // To ensure the poster image resizes while maintaining its original aspect
	  // ratio, use a div with `background-size` when available. For browsers that
	  // do not support `background-size` (e.g. IE8), fall back on using a regular
	  // img element.
	  if (!vjs.BACKGROUND_SIZE_SUPPORTED) {
	    this.fallbackImg_ = vjs.createEl('img');
	    el.appendChild(this.fallbackImg_);
	  }

	  return el;
	};

	/**
	 * Event handler for updates to the player's poster source
	 */
	vjs.PosterImage.prototype.update = function(){
	  var url = this.player().poster();

	  this.setSrc(url);

	  // If there's no poster source we should display:none on this component
	  // so it's not still clickable or right-clickable
	  if (url) {
	    this.show();
	  } else {
	    this.hide();
	  }
	};

	/**
	 * Set the poster source depending on the display method
	 */
	vjs.PosterImage.prototype.setSrc = function(url){
	  var backgroundImage;

	  if (this.fallbackImg_) {
	    this.fallbackImg_.src = url;
	  } else {
	    backgroundImage = '';
	    // Any falsey values should stay as an empty string, otherwise
	    // this will throw an extra error
	    if (url) {
	      backgroundImage = 'url("' + url + '")';
	    }

	    this.el_.style.backgroundImage = backgroundImage;
	  }
	};

	/**
	 * Event handler for clicks on the poster image
	 */
	vjs.PosterImage.prototype.onClick = function(){
	  // We don't want a click to trigger playback when controls are disabled
	  // but CSS should be hiding the poster to prevent that from happening
	  this.player_.play();
	};

	/* Loading Spinner
	================================================================================ */
	/**
	 * Loading spinner for waiting events
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.LoadingSpinner = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    // MOVING DISPLAY HANDLING TO CSS

	    // player.on('canplay', vjs.bind(this, this.hide));
	    // player.on('canplaythrough', vjs.bind(this, this.hide));
	    // player.on('playing', vjs.bind(this, this.hide));
	    // player.on('seeking', vjs.bind(this, this.show));

	    // in some browsers seeking does not trigger the 'playing' event,
	    // so we also need to trap 'seeked' if we are going to set a
	    // 'seeking' event
	    // player.on('seeked', vjs.bind(this, this.hide));

	    // player.on('ended', vjs.bind(this, this.hide));

	    // Not showing spinner on stalled any more. Browsers may stall and then not trigger any events that would remove the spinner.
	    // Checked in Chrome 16 and Safari 5.1.2. http://help.videojs.com/discussions/problems/883-why-is-the-download-progress-showing
	    // player.on('stalled', vjs.bind(this, this.show));

	    // player.on('waiting', vjs.bind(this, this.show));
	  }
	});

	vjs.LoadingSpinner.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-loading-spinner'
	  });
	};

	/* Big Play Button
	================================================================================ */
	/**
	 * Initial play button. Shows before the video has played. The hiding of the
	 * big play button is done via CSS and player states.
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.BigPlayButton = vjs.Button.extend();

	vjs.BigPlayButton.prototype.createEl = function(){
	  return vjs.Button.prototype.createEl.call(this, 'div', {
	    className: 'vjs-big-play-button',
	    innerHTML: '<span aria-hidden="true"></span>',
	    'aria-label': 'play video'
	  });
	};

	vjs.BigPlayButton.prototype.onClick = function(){
	  // VIDLA-1252-1121 Causing double play. Play is handled in framework Player Manager via explicit or programmatic play pause.
	  //this.player_.play();
	};

	/**
	 * Display that an error has occurred making the video unplayable
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.ErrorDisplay = vjs.Component.extend({
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    this.update();
	    this.on(player, 'error', this.update);
	  }
	});

	vjs.ErrorDisplay.prototype.createEl = function(){
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	  });//VID-1444

	  this.contentEl_ = vjs.createEl('div');
	  el.appendChild(this.contentEl_);

	  return el;
	};

	vjs.ErrorDisplay.prototype.update = function(){
	  if (this.player().error()) {
	    this.contentEl_.innerHTML = this.localize(this.player().error().message);
	  }
	};

	(function() {
	  var createTrackHelper;
	/**
	 * @fileoverview Media Technology Controller - Base class for media playback
	 * technology controllers like Flash and HTML5
	 */

	/**
	 * Base class for media (HTML5 Video, Flash) controllers
	 * @param {vjs.Player|Object} player  Central player instance
	 * @param {Object=} options Options object
	 * @constructor
	 */
	vjs.MediaTechController = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    options = options || {};
	    // we don't want the tech to report user activity automatically.
	    // This is done manually in addControlsListeners
	    options.reportTouchActivity = false;
	    vjs.Component.call(this, player, options, ready);

	    // Manually track progress in cases where the browser/flash player doesn't report it.
	    if (!this['featuresProgressEvents']) {
	      this.manualProgressOn();
	    }

	    // Manually track timeupdates in cases where the browser/flash player doesn't report it.
	    if (!this['featuresTimeupdateEvents']) {
	      this.manualTimeUpdatesOn();
	    }

	    this.initControlsListeners();

	    //if (!this['featuresNativeTextTracks']) {
	    //  this.emulateTextTracks();
	    //}

	    this.initTextTrackListeners();
	  }
	});

	/**
	 * Set up click and touch listeners for the playback element
	 * On desktops, a click on the video itself will toggle playback,
	 * on a mobile device a click on the video toggles controls.
	 * (toggling controls is done by toggling the user state between active and
	 * inactive)
	 *
	 * A tap can signal that a user has become active, or has become inactive
	 * e.g. a quick tap on an iPhone movie should reveal the controls. Another
	 * quick tap should hide them again (signaling the user is in an inactive
	 * viewing state)
	 *
	 * In addition to this, we still want the user to be considered inactive after
	 * a few seconds of inactivity.
	 *
	 * Note: the only part of iOS interaction we can't mimic with this setup
	 * is a touch and hold on the video element counting as activity in order to
	 * keep the controls showing, but that shouldn't be an issue. A touch and hold on
	 * any controls will still keep the user active
	 */
	vjs.MediaTechController.prototype.initControlsListeners = function(){
	  var player, activateControls;

	  player = this.player();

	  activateControls = function(){
	    if (player.controls() && !player.usingNativeControls()) {
	      this.addControlsListeners();
	    }
	  };

	  // Set up event listeners once the tech is ready and has an element to apply
	  // listeners to
	  this.ready(activateControls);
	  this.on(player, 'controlsenabled', activateControls);
	  this.on(player, 'controlsdisabled', this.removeControlsListeners);

	  // if we're loading the playback object after it has started loading or playing the
	  // video (often with autoplay on) then the loadstart event has already fired and we
	  // need to fire it manually because many things rely on it.
	  // Long term we might consider how we would do this for other events like 'canplay'
	  // that may also have fired.
	  this.ready(function(){
	    if (this.networkState && this.networkState() > 0) {
	      this.player().trigger('loadstart');
	    }
	  });
	};

	vjs.MediaTechController.prototype.addControlsListeners = function(){
	  var userWasActive;

	  // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
	  // trigger mousedown/up.
	  // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
	  // Any touch events are set to block the mousedown event from happening
	  this.on('mousedown', this.onClick);

	  // If the controls were hidden we don't want that to change without a tap event
	  // so we'll check if the controls were already showing before reporting user
	  // activity
	  this.on('touchstart', function(event) {
	    userWasActive = this.player_.userActive();
	  });

	  this.on('touchmove', function(event) {
	    if (userWasActive){
	      this.player().reportUserActivity();
	    }
	  });

	  this.on('touchend', function(event) {
	    // Stop the mouse events from also happening
	    event.preventDefault();
	  });

	  // Turn on component tap events
	  this.emitTapEvents();

	  // The tap listener needs to come after the touchend listener because the tap
	  // listener cancels out any reportedUserActivity when setting userActive(false)
	  this.on('tap', this.onTap);
	};

	/**
	 * Remove the listeners used for click and tap controls. This is needed for
	 * toggling to controls disabled, where a tap/touch should do nothing.
	 */
	vjs.MediaTechController.prototype.removeControlsListeners = function(){
	  // We don't want to just use `this.off()` because there might be other needed
	  // listeners added by techs that extend this.
	  this.off('tap');
	  this.off('touchstart');
	  this.off('touchmove');
	  this.off('touchleave');
	  this.off('touchcancel');
	  this.off('touchend');
	  this.off('click');
	  this.off('mousedown');
	};

	/**
	 * Handle a click on the media element. By default will play/pause the media.
	 */
	vjs.MediaTechController.prototype.onClick = function(event){
	  // We're using mousedown to detect clicks thanks to Flash, but mousedown
	  // will also be triggered with right-clicks, so we need to prevent that
	  if (event.button !== 0) return;

	  // When controls are disabled a click should not toggle playback because
	  // the click is considered a control
	  if (this.player().controls()) {
	    if (this.player().paused()) {
	      this.player().play();
	    } else {
	      this.player().pause();
	    }
	  }
	};

	/**
	 * Handle a tap on the media element. By default it will toggle the user
	 * activity state, which hides and shows the controls.
	 */
	vjs.MediaTechController.prototype.onTap = function(){
	  this.player().userActive(!this.player().userActive());
	};

	/* Fallbacks for unsupported event types
	================================================================================ */
	// Manually trigger progress events based on changes to the buffered amount
	// Many flash players and older HTML5 browsers don't send progress or progress-like events
	vjs.MediaTechController.prototype.manualProgressOn = function(){
	  this.manualProgress = true;

	  // Trigger progress watching when a source begins loading
	  this.trackProgress();
	};

	vjs.MediaTechController.prototype.manualProgressOff = function(){
	  this.manualProgress = false;
	  this.stopTrackingProgress();
	};

	vjs.MediaTechController.prototype.trackProgress = function(){
	  this.progressInterval = this.setInterval(function(){
	    // Don't trigger unless buffered amount is greater than last time

	    var bufferedPercent = this.player().bufferedPercent();

	    if (this.bufferedPercent_ != bufferedPercent) {
	      this.player().trigger('progress');
	    }

	    this.bufferedPercent_ = bufferedPercent;

	    if (bufferedPercent === 1) {
	      this.stopTrackingProgress();
	    }
	  }, 500);
	};
	vjs.MediaTechController.prototype.stopTrackingProgress = function(){ this.clearInterval(this.progressInterval); };

	/*! Time Tracking -------------------------------------------------------------- */
	vjs.MediaTechController.prototype.manualTimeUpdatesOn = function(){
	  var player = this.player_;

	  this.manualTimeUpdates = true;

	  this.on(player, 'play', this.trackCurrentTime);
	  this.on(player, 'pause', this.stopTrackingCurrentTime);
	  // timeupdate is also called by .currentTime whenever current time is set

	  // Watch for native timeupdate event
	  this.one('timeupdate', function(){
	    // Update known progress support for this playback technology
	    this['featuresTimeupdateEvents'] = true;
	    // Turn off manual progress tracking
	    this.manualTimeUpdatesOff();
	  });
	};

	vjs.MediaTechController.prototype.manualTimeUpdatesOff = function(){
	  var player = this.player_;

	  this.manualTimeUpdates = false;
	  this.stopTrackingCurrentTime();
	  this.off(player, 'play', this.trackCurrentTime);
	  this.off(player, 'pause', this.stopTrackingCurrentTime);
	};

	vjs.MediaTechController.prototype.trackCurrentTime = function(){
	  if (this.currentTimeInterval) { this.stopTrackingCurrentTime(); }
	  this.currentTimeInterval = this.setInterval(function(){
	    this.player().trigger('timeupdate');
	  }, 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
	};

	// Turn off play progress tracking (when paused or dragging)
	vjs.MediaTechController.prototype.stopTrackingCurrentTime = function(){
	  this.clearInterval(this.currentTimeInterval);

	  // #1002 - if the video ends right before the next timeupdate would happen,
	  // the progress bar won't make it all the way to the end
	  this.player().trigger('timeupdate');
	};

	vjs.MediaTechController.prototype.dispose = function() {
	  // Turn off any manual progress or timeupdate tracking
	  if (this.manualProgress) { this.manualProgressOff(); }

	  if (this.manualTimeUpdates) { this.manualTimeUpdatesOff(); }

	  vjs.Component.prototype.dispose.call(this);
	};

	vjs.MediaTechController.prototype.setCurrentTime = function() {
	  // improve the accuracy of manual timeupdates
	  if (this.manualTimeUpdates) { this.player().trigger('timeupdate'); }
	};

	// TODO: Consider looking at moving this into the text track display directly
	// https://github.com/videojs/video.js/issues/1863
	vjs.MediaTechController.prototype.initTextTrackListeners = function() {
	  var player = this.player_,
	      tracks,
	      textTrackListChanges = function() {
	        var textTrackDisplay = player.getChild('textTrackDisplay'),
	            controlBar;

	        if (textTrackDisplay) {
	          textTrackDisplay.updateDisplay();
	        }
	      };

	  tracks = this.textTracks();

	  if (!tracks) {
	    return;
	  }

	  tracks.addEventListener('removetrack', textTrackListChanges);
	  tracks.addEventListener('addtrack', textTrackListChanges);

	  this.on('dispose', vjs.bind(this, function() {
	    tracks.removeEventListener('removetrack', textTrackListChanges);
	    tracks.removeEventListener('addtrack', textTrackListChanges);
	  }));
	};

	vjs.MediaTechController.prototype.emulateTextTracks = function() {
	  var player = this.player_,
	      textTracksChanges,
	      tracks,
	      script;

	  if (!window['WebVTT']) {
	    //script = document.createElement('script');
	    //script.src = player.options()['vtt.js'] || '../node_modules/vtt.js/dist/vtt.js';
	    //player.el().appendChild(script);
	    //window['WebVTT'] = true;
	  }

	  tracks = this.textTracks();
	  if (!tracks) {
	    return;
	  }

	  textTracksChanges = function() {
	    var i, track, textTrackDisplay;

	    textTrackDisplay = player.getChild('textTrackDisplay'),

	    textTrackDisplay.updateDisplay();

	    for (i = 0; i < this.length; i++) {
	      track = this[i];
	      track.removeEventListener('cuechange', vjs.bind(textTrackDisplay, textTrackDisplay.updateDisplay));
	      if (track.mode === 'showing') {
	        track.addEventListener('cuechange', vjs.bind(textTrackDisplay, textTrackDisplay.updateDisplay));
	      }
	    }
	  };

	  tracks.addEventListener('change', textTracksChanges);

	  this.on('dispose', vjs.bind(this, function() {
	    tracks.removeEventListener('change', textTracksChanges);
	  }));
	};

	/**
	 * Provide default methods for text tracks.
	 *
	 * Html5 tech overrides these.
	 */

	/**
	 * List of associated text tracks
	 * @type {Array}
	 * @private
	 */
	vjs.MediaTechController.prototype.textTracks_;

	vjs.MediaTechController.prototype.textTracks = function() {
	  this.player_.textTracks_ = this.player_.textTracks_ || new vjs.TextTrackList();
	  return this.player_.textTracks_;
	};

	vjs.MediaTechController.prototype.remoteTextTracks = function() {
	  this.player_.remoteTextTracks_ = this.player_.remoteTextTracks_ || new vjs.TextTrackList();
	  return this.player_.remoteTextTracks_;
	};

	createTrackHelper = function(self, kind, label, language, options) {
	  var tracks = self.textTracks(),
	      track;

	  options = options || {};

	  options['kind'] = kind;
	  if (label) {
	    options['label'] = label;
	  }
	  if (language) {
	    options['language'] = language;
	  }
	  options['player'] = self.player_;

	  track = new vjs.TextTrack(options);
	  tracks.addTrack_(track);

	  return track;
	};

	vjs.MediaTechController.prototype.addTextTrack = function(kind, label, language) {
	  if (!kind) {
	    throw new Error('TextTrack kind is required but was not provided');
	  }

	  return createTrackHelper(this, kind, label, language);
	};

	vjs.MediaTechController.prototype.addRemoteTextTrack = function(options) {
	  var track = createTrackHelper(this, options['kind'], options['label'], options['language'], options);
	  this.remoteTextTracks().addTrack_(track);
	  return {
	    track: track
	  };
	};

	vjs.MediaTechController.prototype.removeRemoteTextTrack = function(track) {
	  this.textTracks().removeTrack_(track);
	  this.remoteTextTracks().removeTrack_(track);
	};

	/**
	 * Provide a default setPoster method for techs
	 *
	 * Poster support for techs should be optional, so we don't want techs to
	 * break if they don't have a way to set a poster.
	 */
	vjs.MediaTechController.prototype.setPoster = function(){};

	vjs.MediaTechController.prototype['featuresVolumeControl'] = true;

	// Resizing plugins using request fullscreen reloads the plugin
	vjs.MediaTechController.prototype['featuresFullscreenResize'] = false;
	vjs.MediaTechController.prototype['featuresPlaybackRate'] = false;

	// Optional events that we can manually mimic with timers
	// currently not triggered by video-js-swf
	vjs.MediaTechController.prototype['featuresProgressEvents'] = false;
	vjs.MediaTechController.prototype['featuresTimeupdateEvents'] = false;

	vjs.MediaTechController.prototype['featuresNativeTextTracks'] = false;

	/**
	 * A functional mixin for techs that want to use the Source Handler pattern.
	 *
	 * ##### EXAMPLE:
	 *
	 *   videojs.MediaTechController.withSourceHandlers.call(MyTech);
	 *
	 */
	vjs.MediaTechController.withSourceHandlers = function(Tech){
	  /**
	   * Register a source handler
	   * Source handlers are scripts for handling specific formats.
	   * The source handler pattern is used for adaptive formats (HLS, DASH) that
	   * manually load video data and feed it into a Source Buffer (Media Source Extensions)
	   * @param  {Function} handler  The source handler
	   * @param  {Boolean}  first    Register it before any existing handlers
	   */
	  Tech.registerSourceHandler = function(handler, index){
	    var handlers = Tech.sourceHandlers;

	    if (!handlers) {
	      handlers = Tech.sourceHandlers = [];
	    }

	    if (index === undefined) {
	      // add to the end of the list
	      index = handlers.length;
	    }

	    handlers.splice(index, 0, handler);
	  };

	  /**
	   * Return the first source handler that supports the source
	   * TODO: Answer question: should 'probably' be prioritized over 'maybe'
	   * @param  {Object} source The source object
	   * @returns {Object}       The first source handler that supports the source
	   * @returns {null}         Null if no source handler is found
	   */
	  Tech.selectSourceHandler = function(source){
	    var handlers = Tech.sourceHandlers || [],
	        can;

	    for (var i = 0; i < handlers.length; i++) {
	      can = handlers[i].canHandleSource(source);

	      if (can) {
	        return handlers[i];
	      }
	    }

	    return null;
	  };

	  /**
	  * Check if the tech can support the given source
	  * @param  {Object} srcObj  The source object
	  * @return {String}         'probably', 'maybe', or '' (empty string)
	  */
	  Tech.canPlaySource = function(srcObj){
	    var sh = Tech.selectSourceHandler(srcObj);

	    if (sh) {
	      return sh.canHandleSource(srcObj);
	    }

	    return '';
	  };

	  /**
	   * Create a function for setting the source using a source object
	   * and source handlers.
	   * Should never be called unless a source handler was found.
	   * @param {Object} source  A source object with src and type keys
	   * @return {vjs.MediaTechController} self
	   */
	  Tech.prototype.setSource = function(source){
	    var sh = Tech.selectSourceHandler(source);

	    if (!sh) {
	      // Fall back to a native source hander when unsupported sources are
	      // deliberately set
	      if (Tech.nativeSourceHandler) {
	        sh = Tech.nativeSourceHandler;
	      } else {
	        vjs.log.error('No source hander found for the current source.');
	      }
	    }

	    // Dispose any existing source handler
	    this.disposeSourceHandler();
	    this.off('dispose', this.disposeSourceHandler);

	    this.currentSource_ = source;
	    this.sourceHandler_ = sh.handleSource(source, this);
	    this.on('dispose', this.disposeSourceHandler);

	    return this;
	  };

	  /**
	   * Clean up any existing source handler
	   */
	  Tech.prototype.disposeSourceHandler = function(){
	    if (this.sourceHandler_ && this.sourceHandler_.dispose) {
	      this.sourceHandler_.dispose();
	    }
	  };

	};

	vjs.media = {};

	})();

	/**
	 * @fileoverview HTML5 Media Controller - Wrapper for HTML5 Media API
	 */

	/**
	 * HTML5 Media Controller - Wrapper for HTML5 Media API
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @param {Function=} ready
	 * @constructor
	 */
	vjs.Html5 = vjs.MediaTechController.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    var  nodes, nodesLength, i, node, nodeName, removeNodes;

	    if (options['nativeCaptions'] === false || options['nativeTextTracks'] === false) {
	      this['featuresNativeTextTracks'] = false;
	    }

	    vjs.MediaTechController.call(this, player, options, ready);

	    this.setupTriggers();

	    var source = options['source'];

	    // Set the source if one is provided
	    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
	    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
	    // anyway so the error gets fired.
	    if (source && (this.el_.currentSrc !== source.src || (player.tag && player.tag.initNetworkState_ === 3))) {
	      this.setSource(source);
	    }

	    if (this.el_.hasChildNodes()) {

	      nodes = this.el_.childNodes;
	      nodesLength = nodes.length;
	      removeNodes = [];

	      while (nodesLength--) {
	        node = nodes[nodesLength];
	        nodeName = node.nodeName.toLowerCase();
	        if (nodeName === 'track') {
	          if (!this['featuresNativeTextTracks']) {
	            // Empty video tag tracks so the built-in player doesn't use them also.
	            // This may not be fast enough to stop HTML5 browsers from reading the tags
	            // so we'll need to turn off any default tracks if we're manually doing
	            // captions and subtitles. videoElement.textTracks
	            removeNodes.push(node);
	          } else {
	            this.remoteTextTracks().addTrack_(node['track']);
	          }
	        }
	      }

	      for (i=0; i<removeNodes.length; i++) {
	        this.el_.removeChild(removeNodes[i]);
	      }
	    }

	    if (this['featuresNativeTextTracks']) {
	      this.on('loadstart', vjs.bind(this, this.hideCaptions));
	    }

	    // Determine if native controls should be used
	    // Our goal should be to get the custom controls on mobile solid everywhere
	    // so we can remove this all together. Right now this will block custom
	    // controls on touch enabled laptops like the Chrome Pixel
	    if (vjs.TOUCH_ENABLED && player.options()['nativeControlsForTouch'] === true) {
	      this.useNativeControls();
	    }

	    // Chrome and Safari both have issues with autoplay.
	    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
	    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
	    // This fixes both issues. Need to wait for API, so it updates displays correctly
	    player.ready(function(){
	      if (this.src() && this.tag && this.options_['autoplay'] && this.paused()) {
	        delete this.tag['poster']; // Chrome Fix. Fixed in Chrome v16.
	        this.play();
	      }
	    });

	    this.triggerReady();
	  }
	});

	vjs.Html5.prototype.dispose = function(){
	  vjs.Html5.disposeMediaElement(this.el_);
	  vjs.MediaTechController.prototype.dispose.call(this);
	};

	vjs.Html5.prototype.createEl = function(){
	  var player = this.player_,
	      track,
	      trackEl,
	      i,
	      // If possible, reuse original tag for HTML5 playback technology element
	      el = player.tag,
	      attributes,
	      newEl,
	      clone;

	  // Check if this browser supports moving the element into the box.
	  // On the iPhone video will break if you move the element,
	  // So we have to create a brand new element.
	  if (!el || this['movingMediaElementInDOM'] === false) {

	    // If the original tag is still there, clone and remove it.
	    if (el) {
	      clone = el.cloneNode(false);
	      vjs.Html5.disposeMediaElement(el);
	      el = clone;
	      player.tag = null;
	    } else {
	      el = vjs.createEl('video');

	      // determine if native controls should be used
	      attributes = videojs.util.mergeOptions({}, player.tagAttributes);
	      if (!vjs.TOUCH_ENABLED || player.options()['nativeControlsForTouch'] !== true) {
	        delete attributes.controls;
	      }

	      vjs.setElementAttributes(el,
	        vjs.obj.merge(attributes, {
	          id:player.id() + '_html5_api',
	          'class':'vjs-tech'
	        })
	      );
	    }
	    // associate the player with the new tag
	    el['player'] = player;

	    if (player.options_.tracks) {
	      for (i = 0; i < player.options_.tracks.length; i++) {
	        track = player.options_.tracks[i];
	        trackEl = document.createElement('track');
	        trackEl.kind = track.kind;
	        trackEl.label = track.label;
	        trackEl.srclang = track.srclang;
	        trackEl.src = track.src;
	        if ('default' in track) {
	          trackEl.setAttribute('default', 'default');
	        }
	        el.appendChild(trackEl);
	      }
	    }

	    vjs.insertFirst(el, player.el());
	  }

	  // Update specific tag settings, in case they were overridden
	  var settingsAttrs = ['autoplay','preload','loop','muted'];
	  for (i = settingsAttrs.length - 1; i >= 0; i--) {
	    var attr = settingsAttrs[i];
	    var overwriteAttrs = {};
	    if (typeof player.options_[attr] !== 'undefined') {
	      overwriteAttrs[attr] = player.options_[attr];
	    }
	    vjs.setElementAttributes(el, overwriteAttrs);
	  }

	    //changes for VID-2669 - inline setting for Safari and Mobile SDKS's WebView as following this announcement - https://webkit.org/blog/6784/new-video-policies-for-ios/
	    if (player.options_.enableNativeInline) {
	        el.setAttribute("playsinline","");//setting W3C standard inline video attribute on Safari and Mobile SDK's WebView
	        el.setAttribute("webkit-playsinline","");//setting Apple's inline video on Mobile SDK's WebView to have backward compatibility on older version of iOS(~9)
	    }

	  return el;
	  // jenniisawesome = true;
	};


	vjs.Html5.prototype.hideCaptions = function() {
	  var tracks = this.el_.querySelectorAll('track'),
	      track,
	      i = tracks.length,
	      kinds = {
	        'captions': 1,
	        'subtitles': 1
	      };

	  while (i--) {
	    track = tracks[i].track;
	    if ((track && track['kind'] in kinds) &&
	        (!tracks[i]['default'])) {
	      track.mode = 'disabled';
	    }
	  }
	};

	// Make video events trigger player events
	// May seem verbose here, but makes other APIs possible.
	// Triggers removed using this.off when disposed
	vjs.Html5.prototype.setupTriggers = function(){
	  for (var i = vjs.Html5.Events.length - 1; i >= 0; i--) {
	    this.on(vjs.Html5.Events[i], this.eventHandler);
	  }
	};

	vjs.Html5.prototype.eventHandler = function(evt){
	  // In the case of an error on the video element, set the error prop
	  // on the player and let the player handle triggering the event. On
	  // some platforms, error events fire that do not cause the error
	  // property on the video element to be set. See #1465 for an example.
	  if (evt.type == 'error' && this.error()) {
	    this.player().error(this.error().code);

	  // in some cases we pass the event directly to the player
	  } else {
	    // No need for media events to bubble up.
	    evt.bubbles = false;

	    this.player().trigger(evt);
	  }
	};

	vjs.Html5.prototype.useNativeControls = function(){
	  var tech, player, controlsOn, controlsOff, cleanUp;

	  tech = this;
	  player = this.player();

	  // If the player controls are enabled turn on the native controls
	  tech.setControls(player.controls());

	  // Update the native controls when player controls state is updated
	  controlsOn = function(){
	    tech.setControls(true);
	  };
	  controlsOff = function(){
	    tech.setControls(false);
	  };
	  player.on('controlsenabled', controlsOn);
	  player.on('controlsdisabled', controlsOff);

	  // Clean up when not using native controls anymore
	  cleanUp = function(){
	    player.off('controlsenabled', controlsOn);
	    player.off('controlsdisabled', controlsOff);
	  };
	  tech.on('dispose', cleanUp);
	  player.on('usingcustomcontrols', cleanUp);

	  // Update the state of the player to using native controls
	  player.usingNativeControls(true);
	};


	vjs.Html5.prototype.play = function(){ this.el_.play(); };
	vjs.Html5.prototype.pause = function(){ this.el_.pause(); };
	vjs.Html5.prototype.paused = function(){ return this.el_.paused; };

	// vjs.Html5.prototype.currentTime = function(){ return this.el_.currentTime; };
	// vjs.Html5.prototype.setCurrentTime = function(seconds){
	//   try {
	//     this.el_.currentTime = seconds;
	//   } catch(e) {
	//     vjs.log(e, 'Video is not ready. (Video.js)');
	//     // this.warning(VideoJS.warnings.videoNotReady);
	//   }
	// };

	vjs.Html5.prototype.currentTime = function(){
	    return this.el_.currentTime || this.el_.currentTimeForOutstream || 0;//ks : comment out due to Safari, FireFox, doesn't set currentTime of the video element if the video element doesn't have propoer source, so if JSVPAID creative getnerates their own video element, this current Time will not be set on Desktop Safari, Firefox
	};

	vjs.Html5.prototype.setCurrentTime = function(seconds){
	    try {
	        this.el_.currentTimeForOutstream = seconds;
	        this.el_.currentTime = seconds;
	    } catch(e) {
	        vjs.log(e, 'Video is not ready. (Video.js)');
	    }
	};



	vjs.Html5.prototype.duration = function(){ return this.el_.duration || 0; };
	vjs.Html5.prototype.buffered = function(){ return this.el_.buffered; };

	vjs.Html5.prototype.volume = function(){ return this.el_.volume; };
	vjs.Html5.prototype.setVolume = function(percentAsDecimal){ this.el_.volume = percentAsDecimal; };
	vjs.Html5.prototype.muted = function(){ return this.el_.muted; };
	vjs.Html5.prototype.setMuted = function(muted){ this.el_.muted = muted; };

	vjs.Html5.prototype.width = function(){ return this.el_.offsetWidth; };
	vjs.Html5.prototype.height = function(){ return this.el_.offsetHeight; };

	vjs.Html5.prototype.supportsFullScreen = function(){
	  if (typeof this.el_.webkitEnterFullScreen == 'function') {

	    // Seems to be broken in Chromium/Chrome && Safari in Leopard
	    if (/Android/.test(vjs.USER_AGENT) || !/Chrome|Mac OS X 10.5/.test(vjs.USER_AGENT)) {
	      return true;
	    }
	  }
	  return false;
	};

	vjs.Html5.prototype.enterFullScreen = function(){
	  var video = this.el_;

	  if ('webkitDisplayingFullscreen' in video) {
	    this.one('webkitbeginfullscreen', function() {
	      this.player_.isFullscreen(true);

	      this.one('webkitendfullscreen', function() {
	        this.player_.isFullscreen(false);
	        this.player_.trigger('fullscreenchange');
	      });

	      this.player_.trigger('fullscreenchange');
	    });
	  }

	  if (video.paused && video.networkState <= video.HAVE_METADATA) {
	    // attempt to prime the video element for programmatic access
	    // this isn't necessary on the desktop but shouldn't hurt
	    this.el_.play();

	    // playing and pausing synchronously during the transition to fullscreen
	    // can get iOS ~6.1 devices into a play/pause loop
	    this.setTimeout(function(){
	      video.pause();
	      video.webkitEnterFullScreen();
	    }, 0);
	  } else {
	    video.webkitEnterFullScreen();
	  }
	};

	vjs.Html5.prototype.exitFullScreen = function(){
	  this.el_.webkitExitFullScreen();
	};

	// Checks to see if the element's reported URI (either from `el_.src`
	// or `el_.currentSrc`) is a blob-uri and, if so, returns the uri that
	// was passed into the source-handler when it was first invoked instead
	// of the blob-uri
	vjs.Html5.prototype.returnOriginalIfBlobURI_ = function (elementURI, originalURI) {
	  var blobURIRegExp = /^blob\:/i;

	  // If originalURI is undefined then we are probably in a non-source-handler-enabled
	  // tech that inherits from the Html5 tech so we should just return the elementURI
	  // regardless of it's blobby-ness
	  if (originalURI && elementURI && blobURIRegExp.test(elementURI)) {
	    return originalURI;
	  }
	  return elementURI;
	};

	vjs.Html5.prototype.src = function(src) {
	  var elementSrc = this.el_.src;

	  if (src === undefined) {
	    return this.returnOriginalIfBlobURI_(elementSrc, this.source_);
	  } else {
	    // Setting src through `src` instead of `setSrc` will be deprecated
	    this.setSrc(src);
	  }
	};

	vjs.Html5.prototype.setSrc = function(src) {
	  this.el_.src = src;
	};

	vjs.Html5.prototype.load = function(){ this.el_.load(); };
	vjs.Html5.prototype.currentSrc = function(){
	  var elementSrc = this.el_.currentSrc;

	  if (!this.currentSource_) {
	    return elementSrc;
	  }

	  return this.returnOriginalIfBlobURI_(elementSrc, this.currentSource_.src);
	};

	vjs.Html5.prototype.poster = function(){ return this.el_.poster; };
	vjs.Html5.prototype.setPoster = function(val){ this.el_.poster = val; };

	vjs.Html5.prototype.preload = function(){ return this.el_.preload; };
	vjs.Html5.prototype.setPreload = function(val){ this.el_.preload = val; };

	vjs.Html5.prototype.autoplay = function(){ return this.el_.autoplay; };
	vjs.Html5.prototype.setAutoplay = function(val){ this.el_.autoplay = val; };

	vjs.Html5.prototype.controls = function(){ return this.el_.controls; };
	vjs.Html5.prototype.setControls = function(val){ this.el_.controls = !!val; };

	vjs.Html5.prototype.loop = function(){ return this.el_.loop; };
	vjs.Html5.prototype.setLoop = function(val){ this.el_.loop = val; };

	vjs.Html5.prototype.error = function(){ return this.el_.error; };
	vjs.Html5.prototype.seeking = function(){ return this.el_.seeking; };
	vjs.Html5.prototype.seekable = function(){ return this.el_.seekable; };
	vjs.Html5.prototype.ended = function(){ return this.el_.ended; };
	vjs.Html5.prototype.defaultMuted = function(){ return this.el_.defaultMuted; };

	vjs.Html5.prototype.playbackRate = function(){ return this.el_.playbackRate; };
	vjs.Html5.prototype.setPlaybackRate = function(val){ this.el_.playbackRate = val; };

	vjs.Html5.prototype.networkState = function(){ return this.el_.networkState; };
	vjs.Html5.prototype.readyState = function(){ return this.el_.readyState; };

	vjs.Html5.prototype.textTracks = function() {
	  if (!this['featuresNativeTextTracks']) {
	    return vjs.MediaTechController.prototype.textTracks.call(this);
	  }

	  return this.el_.textTracks;
	};
	vjs.Html5.prototype.addTextTrack = function(kind, label, language) {
	  if (!this['featuresNativeTextTracks']) {
	    return vjs.MediaTechController.prototype.addTextTrack.call(this, kind, label, language);
	  }

	  return this.el_.addTextTrack(kind, label, language);
	};

	vjs.Html5.prototype.addRemoteTextTrack = function(options) {
	  if (!this['featuresNativeTextTracks']) {
	    return vjs.MediaTechController.prototype.addRemoteTextTrack.call(this, options);
	  }

	  var track = document.createElement('track');
	  options = options || {};

	  if (options['kind']) {
	    track['kind'] = options['kind'];
	  }
	  if (options['label']) {
	    track['label'] = options['label'];
	  }
	  if (options['language'] || options['srclang']) {
	    track['srclang'] = options['language'] || options['srclang'];
	  }
	  if (options['default']) {
	    track['default'] = options['default'];
	  }
	  if (options['id']) {
	    track['id'] = options['id'];
	  }
	  if (options['src']) {
	    track['src'] = options['src'];
	  }

	  this.el().appendChild(track);

	  if (track.track['kind'] === 'metadata') {
	    track['track']['mode'] = 'hidden';
	  } else {
	    track['track']['mode'] = 'disabled';
	  }

	  track['onload'] = function() {
	    var tt = track['track'];
	    if (track.readyState >= 2) {
	      if (tt['kind'] === 'metadata' && tt['mode'] !== 'hidden') {
	        tt['mode'] = 'hidden';
	      } else if (tt['kind'] !== 'metadata' && tt['mode'] !== 'disabled') {
	        tt['mode'] = 'disabled';
	      }
	      track['onload'] = null;
	    }
	  };

	  this.remoteTextTracks().addTrack_(track.track);

	  return track;
	};

	vjs.Html5.prototype.removeRemoteTextTrack = function(track) {
	  if (!this['featuresNativeTextTracks']) {
	    return vjs.MediaTechController.prototype.removeRemoteTextTrack.call(this, track);
	  }

	  var tracks, i;

	  this.remoteTextTracks().removeTrack_(track);

	  tracks = this.el()['querySelectorAll']('track');

	  for (i = 0; i < tracks.length; i++) {
	    if (tracks[i] === track || tracks[i]['track'] === track) {
	      tracks[i]['parentNode']['removeChild'](tracks[i]);
	      break;
	    }
	  }
	};

	/* HTML5 Support Testing ---------------------------------------------------- */

	/**
	 * Check if HTML5 video is supported by this browser/device
	 * @return {Boolean}
	 */
	vjs.Html5.isSupported = function(){
	  // IE9 with no Media Player is a LIAR! (#984)
	  try {
	    vjs.TEST_VID['volume'] = 0.5;
	  } catch (e) {
	    return false;
	  }

	  return !!vjs.TEST_VID.canPlayType;
	};

	// Add Source Handler pattern functions to this tech
	vjs.MediaTechController.withSourceHandlers(vjs.Html5);

	/*
	 * Override the withSourceHandler mixin's methods with our own because
	 * the HTML5 Media Element returns blob urls when utilizing MSE and we
	 * want to still return proper source urls even when in that case
	 */
	(function(){
	  var
	    origSetSource = vjs.Html5.prototype.setSource,
	    origDisposeSourceHandler = vjs.Html5.prototype.disposeSourceHandler;

	  vjs.Html5.prototype.setSource = function (source) {
	    var retVal = origSetSource.call(this, source);
	    this.source_ = source.src;
	    return retVal;
	  };

	  vjs.Html5.prototype.disposeSourceHandler = function () {
	    this.source_ = undefined;
	    return origDisposeSourceHandler.call(this);
	  };
	})();

	/**
	 * The default native source handler.
	 * This simply passes the source to the video element. Nothing fancy.
	 * @param  {Object} source   The source object
	 * @param  {vjs.Html5} tech  The instance of the HTML5 tech
	 */
	vjs.Html5.nativeSourceHandler = {};

	/**
	 * Check if the video element can handle the source natively
	 * @param  {Object} source  The source object
	 * @return {String}         'probably', 'maybe', or '' (empty string)
	 */
	vjs.Html5.nativeSourceHandler.canHandleSource = function(source){
	  var match, ext;

	  function canPlayType(type){
	    // IE9 on Windows 7 without MediaPlayer throws an error here
	    // https://github.com/videojs/video.js/issues/519
	    try {
	      return vjs.TEST_VID.canPlayType(type);
	    } catch(e) {
	      return '';
	    }
	  }

	  // If a type was provided we should rely on that
	  if (source.type) {
	    return canPlayType(source.type);
	  } else if (source.src) {
	    // If no type, fall back to checking 'video/[EXTENSION]'
	    match = source.src.match(/\.([^.\/\?]+)(\?[^\/]+)?$/i);
	    ext = match && match[1];

	    return canPlayType('video/'+ext);
	  }

	  return '';
	};

	/**
	 * Pass the source to the video element
	 * Adaptive source handlers will have more complicated workflows before passing
	 * video data to the video element
	 * @param  {Object} source    The source object
	 * @param  {vjs.Html5} tech   The instance of the Html5 tech
	 */
	vjs.Html5.nativeSourceHandler.handleSource = function(source, tech){
	  tech.setSrc(source.src);
	};

	/**
	 * Clean up the source handler when disposing the player or switching sources..
	 * (no cleanup is needed when supporting the format natively)
	 */
	vjs.Html5.nativeSourceHandler.dispose = function(){};

	// Register the native source handler
	vjs.Html5.registerSourceHandler(vjs.Html5.nativeSourceHandler);

	/**
	 * Check if the volume can be changed in this browser/device.
	 * Volume cannot be changed in a lot of mobile devices.
	 * Specifically, it can't be changed from 1 on iOS.
	 * @return {Boolean}
	 */
	vjs.Html5.canControlVolume = function(){
	  var volume =  vjs.TEST_VID.volume;
	  vjs.TEST_VID.volume = (volume / 2) + 0.1;
	  return volume !== vjs.TEST_VID.volume;
	};

	/**
	 * Check if playbackRate is supported in this browser/device.
	 * @return {[type]} [description]
	 */
	vjs.Html5.canControlPlaybackRate = function(){
	  var playbackRate =  vjs.TEST_VID.playbackRate;
	  vjs.TEST_VID.playbackRate = (playbackRate / 2) + 0.1;
	  return playbackRate !== vjs.TEST_VID.playbackRate;
	};

	/**
	 * Check to see if native text tracks are supported by this browser/device
	 * @return {Boolean}
	 */
	vjs.Html5.supportsNativeTextTracks = function() {
	  var supportsTextTracks;

	  // Figure out native text track support
	  // If mode is a number, we cannot change it because it'll disappear from view.
	  // Browsers with numeric modes include IE10 and older (<=2013) samsung android models.
	  // Firefox isn't playing nice either with modifying the mode
	  // TODO: Investigate firefox: https://github.com/videojs/video.js/issues/1862
	  supportsTextTracks = !!vjs.TEST_VID.textTracks;
	  if (supportsTextTracks && vjs.TEST_VID.textTracks.length > 0) {
	    supportsTextTracks = typeof vjs.TEST_VID.textTracks[0]['mode'] !== 'number';
	  }
	  if (supportsTextTracks && vjs.IS_FIREFOX) {
	    supportsTextTracks = false;
	  }

	  return supportsTextTracks;
	};

	/**
	 * Set the tech's volume control support status
	 * @type {Boolean}
	 */
	vjs.Html5.prototype['featuresVolumeControl'] = vjs.Html5.canControlVolume();

	/**
	 * Set the tech's playbackRate support status
	 * @type {Boolean}
	 */
	vjs.Html5.prototype['featuresPlaybackRate'] = vjs.Html5.canControlPlaybackRate();

	/**
	 * Set the tech's status on moving the video element.
	 * In iOS, if you move a video element in the DOM, it breaks video playback.
	 * @type {Boolean}
	 */
	vjs.Html5.prototype['movingMediaElementInDOM'] = !vjs.IS_IOS;

	/**
	 * Set the the tech's fullscreen resize support status.
	 * HTML video is able to automatically resize when going to fullscreen.
	 * (No longer appears to be used. Can probably be removed.)
	 */
	vjs.Html5.prototype['featuresFullscreenResize'] = true;

	/**
	 * Set the tech's progress event support status
	 * (this disables the manual progress events of the MediaTechController)
	 */
	vjs.Html5.prototype['featuresProgressEvents'] = true;

	/**
	 * Sets the tech's status on native text track support
	 * @type {Boolean}
	 */
	vjs.Html5.prototype['featuresNativeTextTracks'] = vjs.Html5.supportsNativeTextTracks();

	// HTML5 Feature detection and Device Fixes --------------------------------- //
	(function() {
	  var canPlayType,
	      mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i,
	      mp4RE = /^video\/mp4/i;

	  vjs.Html5.patchCanPlayType = function() {
	    // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
	    if (vjs.ANDROID_VERSION >= 4.0) {
	      if (!canPlayType) {
	        canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
	      }

	      vjs.TEST_VID.constructor.prototype.canPlayType = function(type) {
	        if (type && mpegurlRE.test(type)) {
	          return 'maybe';
	        }
	        return canPlayType.call(this, type);
	      };
	    }

	    // Override Android 2.2 and less canPlayType method which is broken
	    if (vjs.IS_OLD_ANDROID) {
	      if (!canPlayType) {
	        canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
	      }

	      vjs.TEST_VID.constructor.prototype.canPlayType = function(type){
	        if (type && mp4RE.test(type)) {
	          return 'maybe';
	        }
	        return canPlayType.call(this, type);
	      };
	    }
	  };

	  vjs.Html5.unpatchCanPlayType = function() {
	    var r = vjs.TEST_VID.constructor.prototype.canPlayType;
	    vjs.TEST_VID.constructor.prototype.canPlayType = canPlayType;
	    canPlayType = null;
	    return r;
	  };

	  // by default, patch the video element
	  vjs.Html5.patchCanPlayType();
	})();

	// List of all HTML5 events (various uses).
	vjs.Html5.Events = 'loadstart,suspend,abort,error,emptied,stalled,loadedmetadata,loadeddata,canplay,canplaythrough,playing,waiting,seeking,seeked,ended,durationchange,timeupdate,progress,play,pause,ratechange,volumechange'.split(',');

	vjs.Html5.disposeMediaElement = function(el){
	  if (!el) { return; }

	  el['player'] = null;

	  if (el.parentNode) {
	    el.parentNode.removeChild(el);
	  }

	  // remove any child track or source nodes to prevent their loading
	  while(el.hasChildNodes()) {
	    el.removeChild(el.firstChild);
	  }

	  // remove any src reference. not setting `src=''` because that causes a warning
	  // in firefox
	  el.removeAttribute('src');

	  // force the media element to update its loading state by calling load()
	  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
	  if (typeof el.load === 'function') {
	    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
	    (function() {
	      try {
	        el.load();
	      } catch (e) {
	        // not supported
	      }
	    })();
	  }
	};

	/**
	 * The Media Loader is the component that decides which playback technology to load
	 * when the player is initialized.
	 *
	 * @constructor
	 */
	vjs.MediaLoader = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    vjs.Component.call(this, player, options, ready);

	    // If there are no sources when the player is initialized,
	    // load the first supported playback technology.
	    if (!player.options_['sources'] || player.options_['sources'].length === 0) {
	      for (var i=0,j=player.options_['techOrder']; i<j.length; i++) {
	        var techName = vjs.capitalize(j[i]),
	            tech = window['videojs_apn'][techName];

	        // Check if the browser supports this technology
	        if (tech && tech.isSupported()) {
	          player.loadTech(techName);
	          break;
	        }
	      }
	    } else {
	      // // Loop through playback technologies (HTML5, Flash) and check for support.
	      // // Then load the best source.
	      // // A few assumptions here:
	      // //   All playback technologies respect preload false.
	      player.src(player.options_['sources']);
	    }
	  }
	});

	/*
	 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
	 *
	 * enum TextTrackMode { "disabled",  "hidden",  "showing" };
	 */
	vjs.TextTrackMode = {
	  'disabled': 'disabled',
	  'hidden': 'hidden',
	  'showing': 'showing'
	};

	/*
	 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackkind
	 *
	 * enum TextTrackKind { "subtitles",  "captions",  "descriptions",  "chapters",  "metadata" };
	 */
	vjs.TextTrackKind = {
	  'subtitles': 'subtitles',
	  'captions': 'captions',
	  'descriptions': 'descriptions',
	  'chapters': 'chapters',
	  'metadata': 'metadata'
	};

	(function() {
	/*
	 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack
	 *
	 * interface TextTrack : EventTarget {
	 *   readonly attribute TextTrackKind kind;
	 *   readonly attribute DOMString label;
	 *   readonly attribute DOMString language;
	 *
	 *   readonly attribute DOMString id;
	 *   readonly attribute DOMString inBandMetadataTrackDispatchType;
	 *
	 *   attribute TextTrackMode mode;
	 *
	 *   readonly attribute TextTrackCueList? cues;
	 *   readonly attribute TextTrackCueList? activeCues;
	 *
	 *   void addCue(TextTrackCue cue);
	 *   void removeCue(TextTrackCue cue);
	 *
	 *   attribute EventHandler oncuechange;
	 * };
	 */

	vjs.TextTrack = function(options) {
	  var tt, id, mode, kind, label, language, cues, activeCues, timeupdateHandler, changed, prop;

	  options = options || {};

	  if (!options['player']) {
	    throw new Error('A player was not provided.');
	  }

	  tt = this;
	  if (vjs.IS_IE8) {
	    tt = document.createElement('custom');

	    for (prop in vjs.TextTrack.prototype) {
	      tt[prop] = vjs.TextTrack.prototype[prop];
	    }
	  }

	  tt.player_ = options['player'];

	  mode = vjs.TextTrackMode[options['mode']] || 'disabled';
	  kind = vjs.TextTrackKind[options['kind']] || 'subtitles';
	  label = options['label'] || '';
	  language = options['language'] || options['srclang'] || '';
	  id = options['id'] || 'vjs_text_track_' + vjs.guid++;

	  if (kind === 'metadata' || kind === 'chapters') {
	    mode = 'hidden';
	  }

	  tt.cues_ = [];
	  tt.activeCues_ = [];

	  cues = new vjs.TextTrackCueList(tt.cues_);
	  activeCues = new vjs.TextTrackCueList(tt.activeCues_);

	  changed = false;
	  timeupdateHandler = vjs.bind(tt, function() {
	    this['activeCues'];
	    if (changed) {
	      this['trigger']('cuechange');
	      changed = false;
	    }
	  });
	  if (mode !== 'disabled') {
	    tt.player_.on('timeupdate', timeupdateHandler);
	  }

	  Object.defineProperty(tt, 'kind', {
	    get: function() {
	      return kind;
	    },
	    set: Function.prototype
	  });

	  Object.defineProperty(tt, 'label', {
	    get: function() {
	      return label;
	    },
	    set: Function.prototype
	  });

	  Object.defineProperty(tt, 'language', {
	    get: function() {
	      return language;
	    },
	    set: Function.prototype
	  });

	  Object.defineProperty(tt, 'id', {
	    get: function() {
	      return id;
	    },
	    set: Function.prototype
	  });

	  Object.defineProperty(tt, 'mode', {
	    get: function() {
	      return mode;
	    },
	    set: function(newMode) {
	      if (!vjs.TextTrackMode[newMode]) {
	        return;
	      }
	      mode = newMode;
	      if (mode === 'showing') {
	        this.player_.on('timeupdate', timeupdateHandler);
	      }
	      this.trigger('modechange');
	    }
	  });

	  Object.defineProperty(tt, 'cues', {
	    get: function() {
	      if (!this.loaded_) {
	        return null;
	      }

	      return cues;
	    },
	    set: Function.prototype
	  });

	  Object.defineProperty(tt, 'activeCues', {
	    get: function() {
	      var i, l, active, ct, cue;

	      if (!this.loaded_) {
	        return null;
	      }

	      if (this['cues'].length === 0) {
	        return activeCues; // nothing to do
	      }

	      ct = this.player_.currentTime();
	      i = 0;
	      l = this['cues'].length;
	      active = [];

	      for (; i < l; i++) {
	        cue = this['cues'][i];
	        if (cue['startTime'] <= ct && cue['endTime'] >= ct) {
	          active.push(cue);
	        } else if (cue['startTime'] === cue['endTime'] && cue['startTime'] <= ct && cue['startTime'] + 0.5 >= ct) {
	          active.push(cue);
	        }
	      }

	      changed = false;

	      if (active.length !== this.activeCues_.length) {
	        changed = true;
	      } else {
	        for (i = 0; i < active.length; i++) {
	          if (indexOf.call(this.activeCues_, active[i]) === -1) {
	            changed = true;
	          }
	        }
	      }

	      this.activeCues_ = active;
	      activeCues.setCues_(this.activeCues_);

	      return activeCues;
	    },
	    set: Function.prototype
	  });

	  if (options.src) {
	    loadTrack(options.src, tt);
	  } else {
	    tt.loaded_ = true;
	  }

	  if (vjs.IS_IE8) {
	    return tt;
	  }
	};

	vjs.TextTrack.prototype = vjs.obj.create(vjs.EventEmitter.prototype);
	vjs.TextTrack.prototype.constructor = vjs.TextTrack;

	/*
	 * cuechange - One or more cues in the track have become active or stopped being active.
	 */
	vjs.TextTrack.prototype.allowedEvents_ = {
	  'cuechange': 'cuechange'
	};

	vjs.TextTrack.prototype.addCue = function(cue) {
	  var tracks = this.player_.textTracks(),
	      i = 0;

	  if (tracks) {
	    for (; i < tracks.length; i++) {
	      if (tracks[i] !== this) {
	        tracks[i].removeCue(cue);
	      }
	    }
	  }

	  this.cues_.push(cue);
	  this['cues'].setCues_(this.cues_);
	};

	vjs.TextTrack.prototype.removeCue = function(removeCue) {
	  var i = 0,
	      l = this.cues_.length,
	      cue,
	      removed = false;

	  for (; i < l; i++) {
	    cue = this.cues_[i];
	    if (cue === removeCue) {
	      this.cues_.splice(i, 1);
	      removed = true;
	    }
	  }

	  if (removed) {
	    this.cues.setCues_(this.cues_);
	  }
	};

	/*
	 * Downloading stuff happens below this point
	 */
	var loadTrack, parseCues, indexOf;

	loadTrack = function(src, track) {
	  vjs.xhr(src, vjs.bind(this, function(err, response, responseBody){
	    if (err) {
	      return vjs.log.error(err);
	    }


	    track.loaded_ = true;
	    parseCues(responseBody, track);
	  }));
	};

	parseCues = function(srcContent, track) {
	  if (typeof window['WebVTT'] !== 'function') {
	    //try again a bit later
	    return window.setTimeout(function() {
	      parseCues(srcContent, track);
	    }, 25);
	  }

	  var parser = new window['WebVTT']['Parser'](window, window['vttjs'], window['WebVTT']['StringDecoder']());

	  parser['oncue'] = function(cue) {
	    track.addCue(cue);
	  };
	  parser['onparsingerror'] = function(error) {
	    vjs.log.error(error);
	  };

	  parser['parse'](srcContent);
	  parser['flush']();
	};

	indexOf = function(searchElement, fromIndex) {

	  var k;

	  if (this == null) {
	    throw new TypeError('"this" is null or not defined');
	  }

	  var O = Object(this);

	  var len = O.length >>> 0;

	  if (len === 0) {
	    return -1;
	  }

	  var n = +fromIndex || 0;

	  if (Math.abs(n) === Infinity) {
	    n = 0;
	  }

	  if (n >= len) {
	    return -1;
	  }

	  k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

	  while (k < len) {
	    if (k in O && O[k] === searchElement) {
	      return k;
	    }
	    k++;
	  }
	  return -1;
	};

	})();

	/*
	 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist
	 *
	 * interface TextTrackList : EventTarget {
	 *   readonly attribute unsigned long length;
	 *   getter TextTrack (unsigned long index);
	 *   TextTrack? getTrackById(DOMString id);
	 * 
	 *   attribute EventHandler onchange;
	 *   attribute EventHandler onaddtrack;
	 *   attribute EventHandler onremovetrack;
	 * };
	 */
	vjs.TextTrackList = function(tracks) {
	  var list = this,
	      prop,
	      i = 0;

	  if (vjs.IS_IE8) {
	    list = document.createElement('custom');

	    for (prop in vjs.TextTrackList.prototype) {
	      list[prop] = vjs.TextTrackList.prototype[prop];
	    }
	  }

	  tracks = tracks || [];
	  list.tracks_ = [];

	  Object.defineProperty(list, 'length', {
	    get: function() {
	      return this.tracks_.length;
	    }
	  });

	  for (; i < tracks.length; i++) {
	    list.addTrack_(tracks[i]);
	  }

	  if (vjs.IS_IE8) {
	    return list;
	  }
	};

	vjs.TextTrackList.prototype = vjs.obj.create(vjs.EventEmitter.prototype);
	vjs.TextTrackList.prototype.constructor = vjs.TextTrackList;

	/*
	 * change - One or more tracks in the track list have been enabled or disabled.
	 * addtrack - A track has been added to the track list.
	 * removetrack - A track has been removed from the track list.
	*/
	vjs.TextTrackList.prototype.allowedEvents_ = {
	  'change': 'change',
	  'addtrack': 'addtrack',
	  'removetrack': 'removetrack'
	};

	// emulate attribute EventHandler support to allow for feature detection
	(function() {
	  var event;

	  for (event in vjs.TextTrackList.prototype.allowedEvents_) {
	    vjs.TextTrackList.prototype['on' + event] = null;
	  }
	})();

	vjs.TextTrackList.prototype.addTrack_ = function(track) {
	  var index = this.tracks_.length;
	  if (!(''+index in this)) {
	    Object.defineProperty(this, index, {
	      get: function() {
	        return this.tracks_[index];
	      }
	    });
	  }

	  track.addEventListener('modechange', vjs.bind(this, function() {
	    this.trigger('change');
	  }));
	  this.tracks_.push(track);

	  this.trigger({
	    type: 'addtrack',
	    track: track
	  });
	};

	vjs.TextTrackList.prototype.removeTrack_ = function(rtrack) {
	  var i = 0,
	      l = this.length,
	      result = null,
	      track;

	  for (; i < l; i++) {
	    track = this[i];
	    if (track === rtrack) {
	      this.tracks_.splice(i, 1);
	      break;
	    }
	  }

	  this.trigger({
	    type: 'removetrack',
	    track: rtrack
	  });
	};

	vjs.TextTrackList.prototype.getTrackById = function(id) {
	  var i = 0,
	      l = this.length,
	      result = null,
	      track;

	  for (; i < l; i++) {
	    track = this[i];
	    if (track.id === id) {
	      result = track;
	      break;
	    }
	  }

	  return result;
	};

	/*
	 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist
	 *
	 * interface TextTrackCueList {
	 *   readonly attribute unsigned long length;
	 *   getter TextTrackCue (unsigned long index);
	 *   TextTrackCue? getCueById(DOMString id);
	 * };
	 */

	vjs.TextTrackCueList = function(cues) {
	  var list = this,
	      prop;

	  if (vjs.IS_IE8) {
	    list = document.createElement('custom');

	    for (prop in vjs.TextTrackCueList.prototype) {
	      list[prop] = vjs.TextTrackCueList.prototype[prop];
	    }
	  }

	  vjs.TextTrackCueList.prototype.setCues_.call(list, cues);

	  Object.defineProperty(list, 'length', {
	    get: function() {
	      return this.length_;
	    }
	  });

	  if (vjs.IS_IE8) {
	    return list;
	  }
	};

	vjs.TextTrackCueList.prototype.setCues_ = function(cues) {
	  var oldLength = this.length || 0,
	      i = 0,
	      l = cues.length,
	      defineProp;

	  this.cues_ = cues;
	  this.length_ = cues.length;

	  defineProp = function(i) {
	    if (!(''+i in this)) {
	      Object.defineProperty(this, '' + i, {
	        get: function() {
	          return this.cues_[i];
	        }
	      });
	    }
	  };

	  if (oldLength < l) {
	    i = oldLength;
	    for(; i < l; i++) {
	      defineProp.call(this, i);
	    }
	  }
	};

	vjs.TextTrackCueList.prototype.getCueById = function(id) {
	  var i = 0,
	      l = this.length,
	      result = null,
	      cue;

	  for (; i < l; i++) {
	    cue = this[i];
	    if (cue.id === id) {
	      result = cue;
	      break;
	    }
	  }

	  return result;
	};

	(function() {
	'use strict';

	/* Text Track Display
	============================================================================= */
	// Global container for both subtitle and captions text. Simple div container.

	/**
	 * The component for displaying text track cues
	 *
	 * @constructor
	 */
	vjs.TextTrackDisplay = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    vjs.Component.call(this, player, options, ready);

	    player.on('loadstart', vjs.bind(this, this.toggleDisplay));

	    // This used to be called during player init, but was causing an error
	    // if a track should show by default and the display hadn't loaded yet.
	    // Should probably be moved to an external track loader when we support
	    // tracks that don't need a display.
	    player.ready(vjs.bind(this, function() {
	      if (player.tech && player.tech['featuresNativeTextTracks']) {
	        this.hide();
	        return;
	      }

	      var i, tracks, track;

	      player.on('fullscreenchange', vjs.bind(this, this.updateDisplay));

	      tracks = player.options_['tracks'] || [];
	      for (i = 0; i < tracks.length; i++) {
	        track = tracks[i];
	        this.player_.addRemoteTextTrack(track);
	      }
	    }));
	  }
	});

	vjs.TextTrackDisplay.prototype.toggleDisplay = function() {
	  if (this.player_.tech && this.player_.tech['featuresNativeTextTracks']) {
	    this.hide();
	  } else {
	    this.show();
	  }
	};

	vjs.TextTrackDisplay.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-text-track-display'
	  });
	};

	vjs.TextTrackDisplay.prototype.clearDisplay = function() {
	  if (typeof window['WebVTT'] === 'function') {
	    window['WebVTT']['processCues'](window, [], this.el_);
	  }
	};

	// Add cue HTML to display
	var constructColor = function(color, opacity) {
	  return 'rgba(' +
	    // color looks like "#f0e"
	    parseInt(color[1] + color[1], 16) + ',' +
	    parseInt(color[2] + color[2], 16) + ',' +
	    parseInt(color[3] + color[3], 16) + ',' +
	    opacity + ')';
	};
	var darkGray = '#222';
	var lightGray = '#ccc';
	var fontMap = {
	  monospace:             'monospace',
	  sansSerif:             'sans-serif',
	  serif:                 'serif',
	  monospaceSansSerif:    '"Andale Mono", "Lucida Console", monospace',
	  monospaceSerif:        '"Courier New", monospace',
	  proportionalSansSerif: 'sans-serif',
	  proportionalSerif:     'serif',
	  casual:                '"Comic Sans MS", Impact, fantasy',
	  script:                '"Monotype Corsiva", cursive',
	  smallcaps:             '"Andale Mono", "Lucida Console", monospace, sans-serif'
	};
	var tryUpdateStyle = function(el, style, rule) {
	  // some style changes will throw an error, particularly in IE8. Those should be noops.
	  try {
	    el.style[style] = rule;
	  } catch (e) {}
	};

	vjs.TextTrackDisplay.prototype.updateDisplay = function() {
	  var tracks = this.player_.textTracks(),
	      i = 0,
	      track;

	  this.clearDisplay();

	  if (!tracks) {
	    return;
	  }

	  for (; i < tracks.length; i++) {
	    track = tracks[i];
	    if (track['mode'] === 'showing') {
	      this.updateForTrack(track);
	    }
	  }
	};

	vjs.TextTrackDisplay.prototype.updateForTrack = function(track) {
	  if (typeof window['WebVTT'] !== 'function' || !track['activeCues']) {
	    return;
	  }

	  var i = 0,
	      property,
	      cueDiv,
	      overrides = this.player_['textTrackSettings'].getValues(),
	      fontSize,
	      cues = [];

	  for (; i < track['activeCues'].length; i++) {
	    cues.push(track['activeCues'][i]);
	  }

	  window['WebVTT']['processCues'](window, track['activeCues'], this.el_);

	  i = cues.length;
	  while (i--) {
	    cueDiv = cues[i].displayState;
	    if (overrides.color) {
	      cueDiv.firstChild.style.color = overrides.color;
	    }
	    if (overrides.textOpacity) {
	      tryUpdateStyle(cueDiv.firstChild,
	                     'color',
	                     constructColor(overrides.color || '#fff',
	                                    overrides.textOpacity));
	    }
	    if (overrides.backgroundColor) {
	      cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
	    }
	    if (overrides.backgroundOpacity) {
	      tryUpdateStyle(cueDiv.firstChild,
	                     'backgroundColor',
	                     constructColor(overrides.backgroundColor || '#000',
	                                    overrides.backgroundOpacity));
	    }
	    if (overrides.windowColor) {
	      if (overrides.windowOpacity) {
	        tryUpdateStyle(cueDiv,
	                       'backgroundColor',
	                       constructColor(overrides.windowColor, overrides.windowOpacity));
	      } else {
	        cueDiv.style.backgroundColor = overrides.windowColor;
	      }
	    }
	    if (overrides.edgeStyle) {
	      if (overrides.edgeStyle === 'dropshadow') {
	        cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
	      } else if (overrides.edgeStyle === 'raised') {
	        cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
	      } else if (overrides.edgeStyle === 'depressed') {
	        cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
	      } else if (overrides.edgeStyle === 'uniform') {
	        cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
	      }
	    }
	    if (overrides.fontPercent && overrides.fontPercent !== 1) {
	      fontSize = window.parseFloat(cueDiv.style.fontSize);
	      cueDiv.style.fontSize = (fontSize * overrides.fontPercent) + 'px';
	      cueDiv.style.height = 'auto';
	      cueDiv.style.top = 'auto';
	      cueDiv.style.bottom = '2px';
	    }
	    if (overrides.fontFamily && overrides.fontFamily !== 'default') {
	      if (overrides.fontFamily === 'small-caps') {
	        cueDiv.firstChild.style.fontVariant = 'small-caps';
	      } else {
	        cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
	      }
	    }
	  }
	};


	/**
	 * The specific menu item type for selecting a language within a text track kind
	 *
	 * @constructor
	 */
	vjs.TextTrackMenuItem = vjs.MenuItem.extend({
	  /** @constructor */
	  init: function(player, options){
	    var track = this.track = options['track'],
	        tracks = player.textTracks(),
	        changeHandler,
	        event;

	    if (tracks) {
	      changeHandler = vjs.bind(this, function() {
	        var selected = this.track['mode'] === 'showing',
	            track,
	            i,
	            l;

	        if (this instanceof vjs.OffTextTrackMenuItem) {
	          selected = true;

	          i = 0,
	          l = tracks.length;

	          for (; i < l; i++) {
	            track = tracks[i];
	            if (track['kind'] === this.track['kind'] && track['mode'] === 'showing') {
	              selected = false;
	              break;
	            }
	          }
	        }

	        this.selected(selected);
	      });
	      tracks.addEventListener('change', changeHandler);
	      player.on('dispose', function() {
	        tracks.removeEventListener('change', changeHandler);
	      });
	    }

	    // Modify options for parent MenuItem class's init.
	    options['label'] = track['label'] || track['language'] || 'Unknown';
	    options['selected'] = track['default'] || track['mode'] === 'showing';
	    vjs.MenuItem.call(this, player, options);

	    // iOS7 doesn't dispatch change events to TextTrackLists when an
	    // associated track's mode changes. Without something like
	    // Object.observe() (also not present on iOS7), it's not
	    // possible to detect changes to the mode attribute and polyfill
	    // the change event. As a poor substitute, we manually dispatch
	    // change events whenever the controls modify the mode.
	    if (tracks && tracks.onchange === undefined) {
	      this.on(['tap', 'click'], function() {
	        if (typeof window.Event !== 'object') {
	          // Android 2.3 throws an Illegal Constructor error for window.Event
	          try {
	            event = new window.Event('change');
	          } catch(err){}
	        }

	        if (!event) {
	          event = document.createEvent('Event');
	          event.initEvent('change', true, true);
	        }

	        tracks.dispatchEvent(event);
	      });
	    }
	  }
	});

	vjs.TextTrackMenuItem.prototype.onClick = function(){
	  var kind = this.track['kind'],
	      tracks = this.player_.textTracks(),
	      mode,
	      track,
	      i = 0;

	  vjs.MenuItem.prototype.onClick.call(this);

	  if (!tracks) {
	    return;
	  }

	  for (; i < tracks.length; i++) {
	    track = tracks[i];

	    if (track['kind'] !== kind) {
	      continue;
	    }

	    if (track === this.track) {
	      track['mode'] = 'showing';
	    } else {
	      track['mode'] = 'disabled';
	    }
	  }
	};

	/**
	 * A special menu item for turning of a specific type of text track
	 *
	 * @constructor
	 */
	vjs.OffTextTrackMenuItem = vjs.TextTrackMenuItem.extend({
	  /** @constructor */
	  init: function(player, options){
	    // Create pseudo track info
	    // Requires options['kind']
	    options['track'] = {
	      'kind': options['kind'],
	      'player': player,
	      'label': options['kind'] + ' off',
	      'default': false,
	      'mode': 'disabled'
	    };
	    vjs.TextTrackMenuItem.call(this, player, options);
	    this.selected(true);
	  }
	});

	vjs.CaptionSettingsMenuItem = vjs.TextTrackMenuItem.extend({
	  init: function(player, options) {
	    options['track'] = {
	      'kind': options['kind'],
	      'player': player,
	      'label': options['kind'] + ' settings',
	      'default': false,
	      mode: 'disabled'
	    };

	    vjs.TextTrackMenuItem.call(this, player, options);
	    this.addClass('vjs-texttrack-settings');
	  }
	});

	vjs.CaptionSettingsMenuItem.prototype.onClick = function() {
	  this.player().getChild('textTrackSettings').show();
	};

	/**
	 * The base class for buttons that toggle specific text track types (e.g. subtitles)
	 *
	 * @constructor
	 */
	vjs.TextTrackButton = vjs.MenuButton.extend({
	  /** @constructor */
	  init: function(player, options){
	    var tracks, updateHandler;

	    vjs.MenuButton.call(this, player, options);

	    tracks = this.player_.textTracks();

	    if (this.items.length <= 1) {
	      this.hide();
	    }

	    if (!tracks) {
	      return;
	    }

	    updateHandler = vjs.bind(this, this.update);
	    tracks.addEventListener('removetrack', updateHandler);
	    tracks.addEventListener('addtrack', updateHandler);

	    this.player_.on('dispose', function() {
	      tracks.removeEventListener('removetrack', updateHandler);
	      tracks.removeEventListener('addtrack', updateHandler);
	    });
	  }
	});

	// Create a menu item for each text track
	vjs.TextTrackButton.prototype.createItems = function(){
	  var items = [], track, tracks;

	  if (this instanceof vjs.CaptionsButton && !(this.player().tech && this.player().tech['featuresNativeTextTracks'])) {
	    items.push(new vjs.CaptionSettingsMenuItem(this.player_, { 'kind': this.kind_ }));
	  }

	  // Add an OFF menu item to turn all tracks off
	  items.push(new vjs.OffTextTrackMenuItem(this.player_, { 'kind': this.kind_ }));

	  tracks = this.player_.textTracks();

	  if (!tracks) {
	    return items;
	  }

	  for (var i = 0; i < tracks.length; i++) {
	    track = tracks[i];

	    // only add tracks that are of the appropriate kind and have a label
	    if (track['kind'] === this.kind_) {
	      items.push(new vjs.TextTrackMenuItem(this.player_, {
	        'track': track
	      }));
	    }
	  }

	  return items;
	};

	/**
	 * The button component for toggling and selecting captions
	 *
	 * @constructor
	 */
	vjs.CaptionsButton = vjs.TextTrackButton.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    vjs.TextTrackButton.call(this, player, options, ready);
	    this.el_.setAttribute('aria-label','Captions Menu');
	  }
	});
	vjs.CaptionsButton.prototype.kind_ = 'captions';
	vjs.CaptionsButton.prototype.buttonText = 'Captions';
	vjs.CaptionsButton.prototype.className = 'vjs-captions-button';

	vjs.CaptionsButton.prototype.update = function() {
	  var threshold = 2;
	  vjs.TextTrackButton.prototype.update.call(this);

	  // if native, then threshold is 1 because no settings button
	  if (this.player().tech && this.player().tech['featuresNativeTextTracks']) {
	    threshold = 1;
	  }

	  if (this.items && this.items.length > threshold) {
	    this.show();
	  } else {
	    this.hide();
	  }
	};

	/**
	 * The button component for toggling and selecting subtitles
	 *
	 * @constructor
	 */
	vjs.SubtitlesButton = vjs.TextTrackButton.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    vjs.TextTrackButton.call(this, player, options, ready);
	    this.el_.setAttribute('aria-label','Subtitles Menu');
	  }
	});
	vjs.SubtitlesButton.prototype.kind_ = 'subtitles';
	vjs.SubtitlesButton.prototype.buttonText = 'Subtitles';
	vjs.SubtitlesButton.prototype.className = 'vjs-subtitles-button';

	// Chapters act much differently than other text tracks
	// Cues are navigation vs. other tracks of alternative languages
	/**
	 * The button component for toggling and selecting chapters
	 *
	 * @constructor
	 */
	vjs.ChaptersButton = vjs.TextTrackButton.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    vjs.TextTrackButton.call(this, player, options, ready);
	    this.el_.setAttribute('aria-label','Chapters Menu');
	  }
	});
	vjs.ChaptersButton.prototype.kind_ = 'chapters';
	vjs.ChaptersButton.prototype.buttonText = 'Chapters';
	vjs.ChaptersButton.prototype.className = 'vjs-chapters-button';

	// Create a menu item for each text track
	vjs.ChaptersButton.prototype.createItems = function(){
	  var items = [], track, tracks;

	  tracks = this.player_.textTracks();

	  if (!tracks) {
	    return items;
	  }

	  for (var i = 0; i < tracks.length; i++) {
	    track = tracks[i];
	    if (track['kind'] === this.kind_) {
	      items.push(new vjs.TextTrackMenuItem(this.player_, {
	        'track': track
	      }));
	    }
	  }

	  return items;
	};

	vjs.ChaptersButton.prototype.createMenu = function(){
	  var tracks = this.player_.textTracks() || [],
	      i = 0,
	      l = tracks.length,
	      track, chaptersTrack,
	      items = this.items = [];

	  for (; i < l; i++) {
	    track = tracks[i];
	    if (track['kind'] == this.kind_) {
	      if (!track.cues) {
	        track['mode'] = 'hidden';
	        /* jshint loopfunc:true */
	        // TODO see if we can figure out a better way of doing this https://github.com/videojs/video.js/issues/1864
	        window.setTimeout(vjs.bind(this, function() {
	          this.createMenu();
	        }), 100);
	        /* jshint loopfunc:false */
	      } else {
	        chaptersTrack = track;
	        break;
	      }
	    }
	  }

	  var menu = this.menu;
	  if (menu === undefined) {
	    menu = new vjs.Menu(this.player_);
	    menu.contentEl().appendChild(vjs.createEl('li', {
	      className: 'vjs-menu-title',
	      innerHTML: vjs.capitalize(this.kind_),
	      tabindex: -1
	    }));
	  }

	  if (chaptersTrack) {
	    var cues = chaptersTrack['cues'], cue, mi;
	    i = 0;
	    l = cues.length;

	    for (; i < l; i++) {
	      cue = cues[i];

	      mi = new vjs.ChaptersTrackMenuItem(this.player_, {
	        'track': chaptersTrack,
	        'cue': cue
	      });

	      items.push(mi);

	      menu.addChild(mi);
	    }
	    this.addChild(menu);
	  }

	  if (this.items.length > 0) {
	    this.show();
	  }

	  return menu;
	};


	/**
	 * @constructor
	 */
	vjs.ChaptersTrackMenuItem = vjs.MenuItem.extend({
	  /** @constructor */
	  init: function(player, options){
	    var track = this.track = options['track'],
	        cue = this.cue = options['cue'],
	        currentTime = player.currentTime();

	    // Modify options for parent MenuItem class's init.
	    options['label'] = cue.text;
	    options['selected'] = (cue['startTime'] <= currentTime && currentTime < cue['endTime']);
	    vjs.MenuItem.call(this, player, options);

	    track.addEventListener('cuechange', vjs.bind(this, this.update));
	  }
	});

	vjs.ChaptersTrackMenuItem.prototype.onClick = function(){
	  vjs.MenuItem.prototype.onClick.call(this);
	  this.player_.currentTime(this.cue.startTime);
	  this.update(this.cue.startTime);
	};

	vjs.ChaptersTrackMenuItem.prototype.update = function(){
	  var cue = this.cue,
	      currentTime = this.player_.currentTime();

	  // vjs.log(currentTime, cue.startTime);
	  this.selected(cue['startTime'] <= currentTime && currentTime < cue['endTime']);
	};
	})();

	(function() {
	  'use strict';

	  vjs.TextTrackSettings = vjs.Component.extend({
	    init: function(player, options) {
	      vjs.Component.call(this, player, options);
	      this.hide();

	      vjs.on(this.el().querySelector('.vjs-done-button'), 'click', vjs.bind(this, function() {
	        this.saveSettings();
	        this.hide();
	      }));

	      vjs.on(this.el().querySelector('.vjs-default-button'), 'click', vjs.bind(this, function() {
	        this.el().querySelector('.vjs-fg-color > select').selectedIndex = 0;
	        this.el().querySelector('.vjs-bg-color > select').selectedIndex = 0;
	        this.el().querySelector('.window-color > select').selectedIndex = 0;
	        this.el().querySelector('.vjs-text-opacity > select').selectedIndex = 0;
	        this.el().querySelector('.vjs-bg-opacity > select').selectedIndex = 0;
	        this.el().querySelector('.vjs-window-opacity > select').selectedIndex = 0;
	        this.el().querySelector('.vjs-edge-style select').selectedIndex = 0;
	        this.el().querySelector('.vjs-font-family select').selectedIndex = 0;
	        this.el().querySelector('.vjs-font-percent select').selectedIndex = 2;
	        this.updateDisplay();
	      }));

	      vjs.on(this.el().querySelector('.vjs-fg-color > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-bg-color > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.window-color > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-text-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-bg-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-window-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-font-percent select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-edge-style select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-font-family select'), 'change', vjs.bind(this, this.updateDisplay));

	      if (player.options()['persistTextTrackSettings']) {
	        this.restoreSettings();
	      }
	    }
	  });

	  vjs.TextTrackSettings.prototype.createEl = function() {
	    return vjs.Component.prototype.createEl.call(this, 'div', {
	      className: 'vjs-caption-settings vjs-modal-overlay',
	      innerHTML: captionOptionsMenuTemplate()
	    });
	  };

	  vjs.TextTrackSettings.prototype.getValues = function() {
	    var el, bgOpacity, textOpacity, windowOpacity, textEdge, fontFamily, fgColor, bgColor, windowColor, result, name, fontPercent;

	    el = this.el();

	    textEdge = getSelectedOptionValue(el.querySelector('.vjs-edge-style select'));
	    fontFamily = getSelectedOptionValue(el.querySelector('.vjs-font-family select'));
	    fgColor = getSelectedOptionValue(el.querySelector('.vjs-fg-color > select'));
	    textOpacity = getSelectedOptionValue(el.querySelector('.vjs-text-opacity > select'));
	    bgColor = getSelectedOptionValue(el.querySelector('.vjs-bg-color > select'));
	    bgOpacity = getSelectedOptionValue(el.querySelector('.vjs-bg-opacity > select'));
	    windowColor = getSelectedOptionValue(el.querySelector('.window-color > select'));
	    windowOpacity = getSelectedOptionValue(el.querySelector('.vjs-window-opacity > select'));
	    fontPercent = window['parseFloat'](getSelectedOptionValue(el.querySelector('.vjs-font-percent > select')));

	    result = {
	      'backgroundOpacity': bgOpacity,
	      'textOpacity': textOpacity,
	      'windowOpacity': windowOpacity,
	      'edgeStyle': textEdge,
	      'fontFamily': fontFamily,
	      'color': fgColor,
	      'backgroundColor': bgColor,
	      'windowColor': windowColor,
	      'fontPercent': fontPercent
	    };
	    for (name in result) {
	      if (result[name] === '' || result[name] === 'none' || (name === 'fontPercent' && result[name] === 1.00)) {
	        delete result[name];
	      }
	    }
	    return result;
	  };

	  vjs.TextTrackSettings.prototype.setValues = function(values) {
	    var el = this.el(), fontPercent;

	    setSelectedOption(el.querySelector('.vjs-edge-style select'), values.edgeStyle);
	    setSelectedOption(el.querySelector('.vjs-font-family select'), values.fontFamily);
	    setSelectedOption(el.querySelector('.vjs-fg-color > select'), values.color);
	    setSelectedOption(el.querySelector('.vjs-text-opacity > select'), values.textOpacity);
	    setSelectedOption(el.querySelector('.vjs-bg-color > select'), values.backgroundColor);
	    setSelectedOption(el.querySelector('.vjs-bg-opacity > select'), values.backgroundOpacity);
	    setSelectedOption(el.querySelector('.window-color > select'), values.windowColor);
	    setSelectedOption(el.querySelector('.vjs-window-opacity > select'), values.windowOpacity);

	    fontPercent = values.fontPercent;

	    if (fontPercent) {
	      fontPercent = fontPercent.toFixed(2);
	    }

	    setSelectedOption(el.querySelector('.vjs-font-percent > select'), fontPercent);
	  };

	  vjs.TextTrackSettings.prototype.restoreSettings = function() {
	    var values;
	    try {
	      values = JSON.parse(window.localStorage.getItem('vjs-text-track-settings'));
	    } catch (e) {}

	    if (values) {
	      this.setValues(values);
	    }
	  };

	  vjs.TextTrackSettings.prototype.saveSettings = function() {
	    var values;

	    if (!this.player_.options()['persistTextTrackSettings']) {
	      return;
	    }

	    values = this.getValues();
	    try {
	      if (!vjs.isEmpty(values)) {
	        window.localStorage.setItem('vjs-text-track-settings', JSON.stringify(values));
	      } else {
	        window.localStorage.removeItem('vjs-text-track-settings');
	      }
	    } catch (e) {}
	  };

	  vjs.TextTrackSettings.prototype.updateDisplay = function() {
	    var ttDisplay = this.player_.getChild('textTrackDisplay');
	    if (ttDisplay) {
	      ttDisplay.updateDisplay();
	    }
	  };

	  function getSelectedOptionValue(target) {
	    var selectedOption;
	    // not all browsers support selectedOptions, so, fallback to options
	    if (target.selectedOptions) {
	      selectedOption = target.selectedOptions[0];
	    } else if (target.options) {
	      selectedOption = target.options[target.options.selectedIndex];
	    }

	    return selectedOption.value;
	  }

	  function setSelectedOption(target, value) {
	    var i, option;

	    if (!value) {
	      return;
	    }

	    for (i = 0; i < target.options.length; i++) {
	      option = target.options[i];
	      if (option.value === value) {
	        break;
	      }
	    }

	    target.selectedIndex = i;
	  }

	  function captionOptionsMenuTemplate() {
	    return '<div class="vjs-tracksettings">' +
	        '<div class="vjs-tracksettings-colors">' +
	          '<div class="vjs-fg-color vjs-tracksetting">' +
	              '<label class="vjs-label">Foreground</label>' +
	              '<select>' +
	                '<option value="">---</option>' +
	                '<option value="#FFF">White</option>' +
	                '<option value="#000">Black</option>' +
	                '<option value="#F00">Red</option>' +
	                '<option value="#0F0">Green</option>' +
	                '<option value="#00F">Blue</option>' +
	                '<option value="#FF0">Yellow</option>' +
	                '<option value="#F0F">Magenta</option>' +
	                '<option value="#0FF">Cyan</option>' +
	              '</select>' +
	              '<span class="vjs-text-opacity vjs-opacity">' +
	                '<select>' +
	                  '<option value="">---</option>' +
	                  '<option value="1">Opaque</option>' +
	                  '<option value="0.5">Semi-Opaque</option>' +
	                '</select>' +
	              '</span>' +
	          '</div>' + // vjs-fg-color
	          '<div class="vjs-bg-color vjs-tracksetting">' +
	              '<label class="vjs-label">Background</label>' +
	              '<select>' +
	                '<option value="">---</option>' +
	                '<option value="#FFF">White</option>' +
	                '<option value="#000">Black</option>' +
	                '<option value="#F00">Red</option>' +
	                '<option value="#0F0">Green</option>' +
	                '<option value="#00F">Blue</option>' +
	                '<option value="#FF0">Yellow</option>' +
	                '<option value="#F0F">Magenta</option>' +
	                '<option value="#0FF">Cyan</option>' +
	              '</select>' +
	              '<span class="vjs-bg-opacity vjs-opacity">' +
	                  '<select>' +
	                    '<option value="">---</option>' +
	                    '<option value="1">Opaque</option>' +
	                    '<option value="0.5">Semi-Transparent</option>' +
	                    '<option value="0">Transparent</option>' +
	                  '</select>' +
	              '</span>' +
	          '</div>' + // vjs-bg-color
	          '<div class="window-color vjs-tracksetting">' +
	              '<label class="vjs-label">Window</label>' +
	              '<select>' +
	                '<option value="">---</option>' +
	                '<option value="#FFF">White</option>' +
	                '<option value="#000">Black</option>' +
	                '<option value="#F00">Red</option>' +
	                '<option value="#0F0">Green</option>' +
	                '<option value="#00F">Blue</option>' +
	                '<option value="#FF0">Yellow</option>' +
	                '<option value="#F0F">Magenta</option>' +
	                '<option value="#0FF">Cyan</option>' +
	              '</select>' +
	              '<span class="vjs-window-opacity vjs-opacity">' +
	                  '<select>' +
	                    '<option value="">---</option>' +
	                    '<option value="1">Opaque</option>' +
	                    '<option value="0.5">Semi-Transparent</option>' +
	                    '<option value="0">Transparent</option>' +
	                  '</select>' +
	              '</span>' +
	          '</div>' + // vjs-window-color
	        '</div>' + // vjs-tracksettings
	        '<div class="vjs-tracksettings-font">' +
	          '<div class="vjs-font-percent vjs-tracksetting">' +
	            '<label class="vjs-label">Font Size</label>' +
	            '<select>' +
	              '<option value="0.50">50%</option>' +
	              '<option value="0.75">75%</option>' +
	              '<option value="1.00" selected>100%</option>' +
	              '<option value="1.25">125%</option>' +
	              '<option value="1.50">150%</option>' +
	              '<option value="1.75">175%</option>' +
	              '<option value="2.00">200%</option>' +
	              '<option value="3.00">300%</option>' +
	              '<option value="4.00">400%</option>' +
	            '</select>' +
	          '</div>' + // vjs-font-percent
	          '<div class="vjs-edge-style vjs-tracksetting">' +
	            '<label class="vjs-label">Text Edge Style</label>' +
	            '<select>' +
	              '<option value="none">None</option>' +
	              '<option value="raised">Raised</option>' +
	              '<option value="depressed">Depressed</option>' +
	              '<option value="uniform">Uniform</option>' +
	              '<option value="dropshadow">Dropshadow</option>' +
	            '</select>' +
	          '</div>' + // vjs-edge-style
	          '<div class="vjs-font-family vjs-tracksetting">' +
	            '<label class="vjs-label">Font Family</label>' +
	            '<select>' +
	              '<option value="">Default</option>' +
	              '<option value="monospaceSerif">Monospace Serif</option>' +
	              '<option value="proportionalSerif">Proportional Serif</option>' +
	              '<option value="monospaceSansSerif">Monospace Sans-Serif</option>' +
	              '<option value="proportionalSansSerif">Proportional Sans-Serif</option>' +
	              '<option value="casual">Casual</option>' +
	              '<option value="script">Script</option>' +
	              '<option value="small-caps">Small Caps</option>' +
	            '</select>' +
	          '</div>' + // vjs-font-family
	        '</div>' +
	      '</div>' +
	      '<div class="vjs-tracksettings-controls">' +
	        '<button class="vjs-default-button">Defaults</button>' +
	        '<button class="vjs-done-button">Done</button>' +
	      '</div>';
	  }

	})();

	/**
	 * @fileoverview Add JSON support
	 * @suppress {undefinedVars}
	 * (Compiler doesn't like JSON not being declared)
	 */

	/**
	 * Javascript JSON implementation
	 * (Parse Method Only)
	 * https://github.com/douglascrockford/JSON-js/blob/master/json2.js
	 * Only using for parse method when parsing data-setup attribute JSON.
	 * @suppress {undefinedVars}
	 * @namespace
	 * @private
	 */
	vjs.JSON;

	if (typeof window.JSON !== 'undefined' && typeof window.JSON.parse === 'function') {
	  vjs.JSON = window.JSON;

	} else {
	  vjs.JSON = {};

	  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

	  /**
	   * parse the json
	   *
	   * @memberof vjs.JSON
	   * @param {String} text The JSON string to parse
	   * @param {Function=} [reviver] Optional function that can transform the results
	   * @return {Object|Array} The parsed JSON
	   */
	  vjs.JSON.parse = function (text, reviver) {
	      var j;

	      function walk(holder, key) {
	          var k, v, value = holder[key];
	          if (value && typeof value === 'object') {
	              for (k in value) {
	                  if (Object.prototype.hasOwnProperty.call(value, k)) {
	                      v = walk(value, k);
	                      if (v !== undefined) {
	                          value[k] = v;
	                      } else {
	                          delete value[k];
	                      }
	                  }
	              }
	          }
	          return reviver.call(holder, key, value);
	      }
	      text = String(text);
	      cx.lastIndex = 0;
	      if (cx.test(text)) {
	          text = text.replace(cx, function (a) {
	              return '\\u' +
	                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	          });
	      }

	      if (/^[\],:{}\s]*$/
	              .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
	                  .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
	                  .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

	          j = eval('(' + text + ')');

	          return typeof reviver === 'function' ?
	              walk({'': j}, '') : j;
	      }

	      throw new SyntaxError('JSON.parse(): invalid or malformed JSON data');
	  };
	}

	/**
	 * @fileoverview Functions for automatically setting up a player
	 * based on the data-setup attribute of the video tag
	 */

	// Automatically set up any tags that have a data-setup attribute
	vjs.autoSetup = function(){
	  var options, mediaEl, player, i, e;

	  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
	  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
	  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
	  // var mediaEls = vids.concat(audios);

	  // Because IE8 doesn't support calling slice on a node list, we need to loop through each list of elements
	  // to build up a new, combined list of elements.
	  var vids = document.getElementsByTagName('video');
	  var audios = document.getElementsByTagName('audio');
	  var mediaEls = [];
	  if (vids && vids.length > 0) {
	    for(i=0, e=vids.length; i<e; i++) {
	      mediaEls.push(vids[i]);
	    }
	  }
	  if (audios && audios.length > 0) {
	    for(i=0, e=audios.length; i<e; i++) {
	      mediaEls.push(audios[i]);
	    }
	  }

	  // Check if any media elements exist
	  if (mediaEls && mediaEls.length > 0) {

	    for (i=0,e=mediaEls.length; i<e; i++) {
	      mediaEl = mediaEls[i];

	      // Check if element exists, has getAttribute func.
	      // IE seems to consider typeof el.getAttribute == 'object' instead of 'function' like expected, at least when loading the player immediately.
	      if (mediaEl && mediaEl.getAttribute) {

	        // Make sure this player hasn't already been set up.
	        if (mediaEl['player'] === undefined) {
	          options = mediaEl.getAttribute('data-setup');

	          // Check if data-setup attr exists.
	          // We only auto-setup if they've added the data-setup attr.
	          if (options !== null) {
	            // Create new video.js instance.
	            player = videojs(mediaEl);
	          }
	        }

	      // If getAttribute isn't defined, we need to wait for the DOM.
	      } else {
	        vjs.autoSetupTimeout(1);
	        break;
	      }
	    }

	  // No videos were found, so keep looping unless page is finished loading.
	  } else if (!vjs.windowLoaded) {
	    vjs.autoSetupTimeout(1);
	  }
	};

	// Pause to let the DOM keep processing
	vjs.autoSetupTimeout = function(wait){
	  setTimeout(vjs.autoSetup, wait);
	};

	if (document.readyState === 'complete') {
	  vjs.windowLoaded = true;
	} else {
	  vjs.one(window, 'load', function(){
	    vjs.windowLoaded = true;
	  });
	}

	// Run Auto-load players
	// You have to wait at least once in case this script is loaded after your video in the DOM (weird behavior only with minified version)
	vjs.autoSetupTimeout(1);

	/**
	 * the method for registering a video.js plugin
	 *
	 * @param  {String} name The name of the plugin
	 * @param  {Function} init The function that is run when the player inits
	 */
	vjs.plugin = function(name, init){
	  vjs.Player.prototype[name] = init;
	};

	/* jshint ignore:end */
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module)))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var Html5PlayerObj = __webpack_require__(7);//html5 player framework
	var Html5IosPlayerObj = __webpack_require__(36);//iOS inline video player framework
	var FlashPlayerObj = __webpack_require__(42);
	var UserSync = __webpack_require__(43);//UserSync.js
	var VideoSizeHandler = __webpack_require__(44);
	var Utils = __webpack_require__(8);

	var prefixOfLog = "PlayerManager_BuildPlayer";
	var APN_Logger = __webpack_require__(9);
	var debug = function (message) {
	    APN_Logger.verbose(message, prefixOfLog);
	};
	// var error = function (message) {
	//     APN_Logger.error(message, prefixOfLog);
	// };
	// var info = function (message) {
	//     APN_Logger.info(message, prefixOfLog);
	// };

	var buildPlayer = function (_callbackForAdUnit, _options, playerManager) {

	    debug("buildPlayer");


	    var triggerCheckingMouseLeave;

	    //join parameter and object in outside of this object
	    var options = _options;

	    var isIosInlineRequired = playerManager.isIosInlineRequired.bind(playerManager);

	    var isMobile = function () {
	        var index = navigator.appVersion.indexOf("Mobile");
	        var indexForAndroid = navigator.appVersion.indexOf("Android");
	        return (index > -1) || (indexForAndroid > -1);
	    };

	    var isIOS = function () {
	        var indexForIOS = /iPad|iPhone|iPod/.test(navigator.appVersion);
	        return indexForIOS;
	    };


	    //define and set default options by parameters
	    var setDefaultOptions = function (_options) {

	        _options.nativeControlsForTouch = false;
	        _options.controls = true;
	        _options.preload = "auto";

	        if (!_options.extensions) {
	            _options.extensions = '';
	        }

	        VideoSizeHandler.setSizeForInitialRender(_options);


	        if (isIOS()) {
	            if (_options.sideStream && _options.sideStream.enabled === false) {//side options should be allowed for iOS
	                _options.nonViewableBehavior = "pause";
	            }
	        }

	        switch (_options.initialPlayback) {
	            case "auto":
	                _options.autoplay = false;
	                break;
	            case "click":
	                _options.autoplay = false;
	                break;
	            case "mouseover":
	                _options.autoplay = false;
	                break;
	            default:

	        }

	        if (!_options.hasOwnProperty("disableTopBar")) {
	            _options.disableTopBar = false;
	        }

	        //define communicator with flash
	        _options.communicator = playerManager.externalNameOfVideoPlayer;

	        if (Utils.isAndroid()) {
	            _options.controlBarPosition = "below";
	        }

	        if (playerManager.decidePlayer(_options.requiredPlayer) === "flash") {
	            _options.controlBarPosition = "over";
	        }

	        // Apply default settings for buttons on end card screen
	        var ecOpts = _options.endCard;
	        if (ecOpts && ecOpts.enabled) {
	            // If no buttons are given by default then replay and learnMore will show up based on those settings
	            if (!ecOpts.buttons) {
	                ecOpts.buttons = [];

	                // Internal flag to indicate buttons weren't explicitly specified
	                ecOpts.showDefaultButtons = true;

	                if ((ecOpts.buttons.indexOf("replay") < 0) && (_options.disableCollapse && _options.disableCollapse.replay)) {
	                    ecOpts.buttons.push({type:"replay"});
	                }

	                if ((ecOpts.buttons.indexOf("learnMore") < 0) && (_options.learnMore && _options.learnMore.enabled)) {
	                    var lmopts = {type:"learnMore"};
	                    if (_options.learnMore.text) {
	                        lmopts.text = _options.learnMore.text;
	                    }
	                    ecOpts.buttons.push(lmopts);
	                }
	            }
	        }

	        return _options;
	    };


	    //set required default value
	    options = setDefaultOptions(options);

	    if (options.initialAudio === "off") {
	        playerManager.isMuted = true;
	    }

	    //set default swf if it doesn't have
	    options.flash = options.flash ? options.flash : {swf: "http://video.devnxs.net/players/flash/AppnexusFlashPlayer.swf"};


	    playerManager.options = options;


	    //callback for inject event to player : player should returen element of itself
	    var cbInjectEventToPlayer = function (el_wholeArea, el_videoArea) {


	        //set playOnMouseover
	        if (options.playOnMouseover === true) {

	            var _tmpMouseoverListenerForce = function () {
	                if (playerManager.isDoneInitialPlay === true && !playerManager.explicitPaused && playerManager.isViewable && playerManager.isPlayingVideo === false) {
	                    playerManager.play();
	                }
	            };
	            var _tmpMouseOutListenerForce = function () {
	                playerManager.pause();
	            };
	            el_wholeArea.addEventListener("mouseenter", _tmpMouseoverListenerForce);
	            el_wholeArea.addEventListener("mouseleave", _tmpMouseOutListenerForce);

	        }

	        //set audioOnMouseover
	        if (options.audioOnMouseover !== false) {
	            var unmuteTimeout = 0;
	            var unmuteTimeoutFn;
	            if (typeof options.audioOnMouseover === "number") {
	                unmuteTimeout = options.audioOnMouseover;
	            }

	            var _tmpMouseoutListenerForceAudio = function () {
	                if (!playerManager.isFullscreen && playerManager.isDoneInitialPlay) {
	                    clearTimeout(unmuteTimeoutFn);
	                    playerManager.mute();
	                    el_wholeArea.removeEventListener("mouseleave", _tmpMouseoutListenerForceAudio);
	                }
	            };

	            var _tmpMouseoverListenerForceAudio = function () {
	                if (!playerManager.isFullscreen && playerManager.isDoneInitialPlay && !playerManager.mutedByViewability) {
	                    unmuteTimeoutFn = setTimeout(function () {
	                        playerManager.unmute();
	                        debug("unmute by mouseover");
	                    }, unmuteTimeout);
	                }
	                el_wholeArea.addEventListener("mouseleave", _tmpMouseoutListenerForceAudio, false);
	            };


	            //this shouldn't be invoked when it's iOS because it doesn't have mouse(for some reason, browsing out will cause mouseenter event in mobile Safari browser)
	            if (!isIosInlineRequired()) {

	                triggerCheckingMouseLeave = setInterval(function () {
	                    if (playerManager && playerManager.isFullscreen && _tmpMouseoutListenerForceAudio && el_wholeArea) {
	                        el_wholeArea.removeEventListener("mouseleave", _tmpMouseoutListenerForceAudio);
	                    }
	                }, 500);

	                el_wholeArea.addEventListener("mouseenter", _tmpMouseoverListenerForceAudio, false);
	            }
	        }

	        //set resposive behavior on desktop for VID-1080
	        //mobile already has this feature so we handles it only for desktop
	        //also this should work for VID3 and VID2
	        //special case : if autoInitialSize is false and a width doesn't have a value then a behavior of this will work like autoInitialSize=true, this case is declared at ExtendDefaultOption.js
	        if (options.autoInitialSize && !isMobile()) {
	            window.addEventListener("resize", function () {

	                //for VID-1898 going to fullscreen on flash caused window resize on several OS, and it can interfere with CSS of outstreae like sidestream case, also it actually makes sense to not resize video if it's in fullscreen on Flash
	                //as a result if sideStream is enabled we don't need to resize video by window.resize event.
	                var shouldNotResizeWhenSideStreamActivated = playerManager.options.sideStreamObject && typeof(playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated) === "function" ? playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated() : false;
	                if (shouldNotResizeWhenSideStreamActivated) {
	                    return;
	                }


	                if (options.targetElement && options.targetElement.style && options.targetElement.style.height && Number(options.targetElement.style.height.replace("px", "")) === 0) {//returns only when collapse for VID-2149
	                    //initial target element height : 0.1px which is required to avoid the blocking flash on chrome.
	                    //target element height after collsapse : 0px
	                    return;//don't need to resize if video is already collapsed
	                }

	                setTimeout(function () {
	                    if (!options.disableCollapse.enabled && (playerManager.isSkipped || playerManager.isCompleted)) {
	                        return;
	                    }
	                    options.width = options.targetElement.offsetWidth;

	                    var isAndroid = (/android/i.test(navigator.userAgent.toLowerCase()));
	                    if (isAndroid) {
	                        //for android4
	                        options.targetElement.style.webkitTransition = "height 0s ease";
	                    } else {
	                        //for most of modern browser
	                        options.targetElement.style.transition = "height 0s ease";
	                    }

	                    playerManager.resizeVideo(-1);
	                    options.targetElement.style.height = options.height + "px";
	                    var videoObject = document.getElementById(playerManager.videoObjectId);
	                    if (videoObject && typeof videoObject !== undefined) {
	                        videoObject.style.width = options.width;
	                        videoObject.style.height = options.height;
	                    }

	                    setTimeout(function () {
	                        var convertToSeconds = function (ms) {
	                            if (ms < 0) {
	                                return 0;
	                            }
	                            return ms / 1000;
	                        };
	                        var animationSpeed = convertToSeconds(options.expandTime);
	                        animationSpeed = (animationSpeed <= 0) ? 0.001 : animationSpeed;//because if it's under zero, transitionEnd event is not reliable
	                        if (isAndroid) {
	                            //for android4
	                            options.targetElement.style.webkitTransition = "height " + animationSpeed + "s ease";
	                        } else {
	                            //for most of modern browser
	                            options.targetElement.style.transition = "height " + animationSpeed + "s ease";
	                        }
	                    }, 500);


	                }, 0);//we have to use this timer to avoid timing issue on Safari

	            });
	        }


	        if (playerManager.decidePlayer(options.requiredPlayer) === 'flash') {

	            el_wholeArea.addEventListener("mouseenter", function () {
	                playerManager.mouseIn();
	            });
	            el_wholeArea.addEventListener("mouseleave", function () {
	                playerManager.mouseOut();
	            });

	        }

	        //define click event
	        el_wholeArea.style.cursor = "pointer";

	        if (el_videoArea && el_videoArea !== undefined) {
	            // VIDLA-1839 iOS 11 - Video click thru does not launch the click thru url for mp4 creatives
	            // iOS11 has stopped supporting click on video element. Handler never gets called.
	            // This does not impact Outstream, as inline player handles it. This happens when iOS and html player is used.
	            if(isIOS()){
	                // listen for touchend, VIDLA-2001 touchmoveHappened helps us distinguish between a tap and touch scroll.
	                var touchmoveHappened = false;
	                el_videoArea.ontouchmove = function() {
	                    touchmoveHappened = true;
	                };
	                el_videoArea.ontouchend = function(e) {
	                    if(touchmoveHappened){
	                        touchmoveHappened = false;
	                        return;
	                    }
	                    handleVideoClick(e);
	                };
	            } else {
	                el_videoArea.onclick = function (e) {
	                    handleVideoClick(e);
	                };
	            }
	            var handleVideoClick = function () {
	                if (playerManager.decidePlayer(options.requiredPlayer) === "html5" && !options.vpaid) {
	                    if (options.learnMore.enabled === true) {
	                        if (options.learnMore.clickToPause === true) {
	                            if (playerManager.isPlayingVideo) {
	                                playerManager.explicitPause();
	                            } else {
	                                playerManager.explicitPlay();
	                            }
	                        }
	                    } else {
	                        playerManager.click();
	                    }
	                }
	            };
	        }


	        //for VID-2742 some of elements which are not used for native player now has interfered with proper rendering on iOS10 and small devices
	        //it may be a bug on iOS10 because iOS8 and iOS9 doesn't have this problem. this is for VID-2742

	        var hasCustomPlayerSkin = playerManager.options && playerManager.options.playerSkin && playerManager.options.playerSkin.customPlayerSkin;
	        if (isIOS() && playerManager.overlayPlayer && playerManager.options && playerManager.options.enableInlineVideoForIos === false && hasCustomPlayerSkin) {

	            playerManager.adVideoPlayer.controlBar.fullscreenToggle.dispose();

	            //experemental to improve more for resolving 1px moving up
	            //why this required? : even if we performed above remedy, video is still moving about 1px up so we have to re-render conrolbar where has critical part caused this issue.
	            playerManager.adVideoPlayer.one("playing",function() {//only one time! - this issue hapens only first time when we play the video, so no need to do again
	                playerManager.adVideoPlayer.controlBar.el().style.display = "none";//for re-drawing element
	                setTimeout(function() {
	                    playerManager.adVideoPlayer.controlBar.el().style.display = "block";//for re-drawing element
	                },7000);//7000ms is the time iOS10 re-renders (moving element up) after playing a video for some unknown reason on the browser
	            });
	        }
	    };


	    switch (playerManager.decidePlayer(options.requiredPlayer)) {
	        case "html5":
	            //activate new inline video for iOS if only "enableInlineVideoForIos" is true
	            if (isIosInlineRequired()) {
	                new Html5IosPlayerObj(playerManager, cbInjectEventToPlayer).start();
	            } else {
	                new Html5PlayerObj(playerManager, cbInjectEventToPlayer).start();
	            }
	            break;
	        case "flash":
	            FlashPlayerObj(playerManager, cbInjectEventToPlayer);
	            break;
	        default:
	    }

	    UserSync.sharedInstance().run(_options);//add usersync for VIDLA-1383






	};


	module.exports = buildPlayer;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	//declare module
	var utils = __webpack_require__(8);
	var _logger = __webpack_require__(9);

	var info = function (message) {
	    _logger.info("Video Player: " + message);
	};

	/**
	 * Html5Player
	 * At the end of this process, it will invoke "callbackForAdUnit.cbWhenReady" to continute a flow of video player this is asynchoronous action and Outstream will wait this callback to start doing something (expanding...)
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 */
	module.exports = function (playerManager, cbInjectEventToPlayer) {

	    var html5PlayerSelf = this;

	    //shared variable
	    this.options = playerManager.options;//getting required object from adVideoPlayerManager
	    this.an_video_ad_player_id = "";
	    this.an_video_ad_player_html5_api_id = "";
	    this.targetElement = "";
	    this.videojsOrigin = playerManager.videoPlayerObj;
	    this.dispatchEventToAdunit = playerManager.dispatchEventToAdunit.bind(playerManager);
	    this.callbackForAdUnit = playerManager.callbackForAdUnit;
	    this.topChromeHeight = 24;
	    this.pendingFullscreenExit = false;//there is a 1000ms timeout between pressing the exit fullscreen icon and the status being updated in the player,mthis variable will let us know this is the case, since a lot happens in those ms
	    this.bigbuttonUnmuteTimeout = 250; // videojs takes a while to sync mute, so we wait 250ms for safari
	    this.CONST_MESSAGE_GENERAL_ERROR = "General error reported from HTML5 video player";//const variables
	    this.adIndicatorTextContent = this.options.adText;//default is "Ad"
	    this.readyForSkip = false;//flag to be set when video is ready to skip
	    this.floatingSkipButton = null;//this button obj will be set when it's required
	    this.floatingAdSkipText = null;//this obj will be set when it's required


	    //redefine utitlity function to have backward compatibility
	    this.isIos = utils.isIos;
	    this.isAndroid = utils.isAndroid;
	    this.isMobile = utils.isMobile;
	    this.refreshVideoLookAndFeel = utils.refreshVideoLookAndFeel;


	    //sub components
	    this.initializeIframeAndVideo = __webpack_require__(10)(html5PlayerSelf, playerManager).init;
	    this.UIController = __webpack_require__(11)(html5PlayerSelf, playerManager, cbInjectEventToPlayer).init;
	    this.displayVolumeControls = __webpack_require__(35)(html5PlayerSelf).displayVolumeControls;


	    //start method
	    this.start = function () {
	        info("WE ARE USING HTML5 PLAYER");

	        var UID = new Date().getTime() + Math.floor(Math.random() * 10000);//define iframe's uniqueu id

	        //override options
	        html5PlayerSelf.options.techOrder = ["html5"];//force to use html5 for video.js because flash will be handled by diffrent swf owned by us
	        html5PlayerSelf.options.iframeVideoWrapperId = "iframeVideoWrapper_" + UID;


	        var divIdForVideo = "an_video_ad_player_" + UID;
	        var videoId = "an_video_ad_player_" + UID + "_html5_api";

	        //set flags
	        html5PlayerSelf.an_video_ad_player_id = divIdForVideo;
	        html5PlayerSelf.an_video_ad_player_html5_api_id = videoId;

	        //keep div id and video id for playerManager
	        playerManager.divIdForVideo = divIdForVideo;
	        playerManager.videoId = videoId;

	        html5PlayerSelf.targetElement = html5PlayerSelf.options.targetElement;

	        //execute UI Controller after initializeIframeAndVideo finished
	        html5PlayerSelf.initializeIframeAndVideo(html5PlayerSelf.UIController);
	    };





	};



/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Utility class
	 */

	var prefixOfLog = "PlayerManager_Utils";
	var APN_Logger = __webpack_require__(9);
	var debug = function (message) {
	    APN_Logger.verbose(message, prefixOfLog);
	};
	// var error = function (message) {
	//     APN_Logger.error(message, prefixOfLog);
	// };
	var info = function (message) {
	    APN_Logger.info(message, prefixOfLog);
	};


	var isIphone = function () {
	    var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	};

	var isIos = function () {
	    var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	};

	var isAndroid = function () {
	    return (/android/i.test(navigator.userAgent.toLowerCase()));
	};

	var isMobile = function () {
	    return navigator.appVersion.indexOf("Mobile") > -1 || navigator.appVersion.indexOf("Android") > -1;
	};

	var getIOSVersion = function() {
	    var match =navigator.userAgent.match(/OS (\d+)_/i);
	    if (match && match[1]) {
	        return match[1];
	    }
	};

	var refreshVideoLookAndFeel = function (options, playerManager) {

	    if (playerManager.isSkipped || !playerManager.isExpanded) {
	        return;
	    }

	    if (options.autoInitialSize && !options.shouldResizeVideoToFillMobileWebview) {
	        options.width = options.targetElement.offsetWidth;
	    }
	    playerManager.resizeVideo(-1, isMobile());
	    options.targetElement.style.height = options.height + "px";
	};

	var makeIframeFlexbileSize = function(playerManager) {
	    if (isIos() && playerManager.options.enableInlineVideoForIos) {
	        setTimeout(function() {
	            var iframeWrapper = document.getElementById(playerManager.options.iframeVideoWrapperId);
	            iframeWrapper.style.width = "";
	            iframeWrapper.style.height = "";
	        },0);
	    }
	};


	var fireEvent = function (obj, eventName) {
	    var event = document.createEvent("HTMLEvents");
	    event.initEvent(eventName, true, true);
	    event.eventName = eventName;
	    obj.dispatchEvent(event);
	};


	//rules regards VID-1529
	/*
	 1.Callback(VAST) : should suppress all callback related to tracking
	 2.Callback(VPAID) : don't suppress followings (which is not related to tracking or report in VAST)
	 AdLoaded
	 AdStarted
	 AdStopped
	 AdSkippableStateChange
	 AdLinearChange
	 AdDurationChange
	 AdRemainingTimeChange
	 AdLog
	 AdError
	 3.Callback(AdUnit) : don't suppressed
	 4.Tracking url : should suppress
	 5.eventCB for AST : don't suppressed
	 */
	/**
	 * Utility class for handling late invoking, orignally made for VID-1505
	 * structure : FIFO (First in - First out)
	 * @constructor
	 */
	var DelayEventHandler = function () {
	    this.queue = [];
	    this.id = "";
	    this.isSuppress = false;
	    this.isPaused = false;
	    this.isCompleted = false;

	    var timerInterval = 100;
	    var ignoreNextQueue = false;

	    /**
	     * push function or event
	     * @param cb
	     */
	    this.push = function (cb) {

	        if (this.isSuppress === false && typeof cb === 'function') {
	            cb();
	            return;
	        }

	        if (ignoreNextQueue) {
	            ignoreNextQueue = false;//TODO can occur concurrent issue but it's okay for usage of JSVPAIDConfigure.js
	            return;
	        }

	        if (this.isPaused === false) {
	            this.queue.push(cb);
	        }
	    };

	    /**
	     * start timer to consume this queue
	     */
	    this.start = function () {
	        debug("delay event starts");
	        var delayEventHandler = this;
	        var pullAndInvoke = function () {
	            if (delayEventHandler.isSuppress === false) {
	                var cb = delayEventHandler.queue.shift();
	                if (cb && typeof(cb) === "function") {
	                    cb();
	                }
	            }
	            setTimeout(function () {
	                if (delayEventHandler.isCompleted === false) {
	                    pullAndInvoke();//recursion until video is completed
	                }
	            }, timerInterval);
	        };
	        pullAndInvoke();
	    };

	    /**
	     * Immediate stop the timer
	     * @constructor
	     */
	    this.ImmediateStop = function () {
	        this.isCompleted = true;
	    };

	    /**
	     * push a function to stop the timer, the timer will stop when it's order
	     */
	    this.lazyTerminate = function () {
	        var delayEventHandler = this;
	        var cb = function () {
	            delayEventHandler.ImmediateStop();
	        };
	        this.queue.push(cb);
	    };

	    /**
	     * method to release suppressed functions or events
	     * @param o
	     */
	    this.suppress = function (o) {
	        this.isSuppress = o;
	    };

	    /**
	     * clear queue for Waterfall project
	     */
	    this.clearQueue = function () {
	        this.queue = [];
	    };

	    this.ignoreNextQueue = function () {
	        ignoreNextQueue = true;
	    };
	};


	var isEmpty = function (obj) {
	    return (typeof(obj) === "undefined" || obj === "" || obj === false || obj === null) ? true : false;
	};

	var isEmptyAndObject = function (obj) {

	    //expected behaviors
	    /*
	    isEmptyAndObject()
	    true
	    isEmptyAndObject(undefined)
	    true
	    isEmptyAndObject(0)
	    false
	    isEmptyAndObject(1)
	    false
	    isEmptyAndObject("a")
	    false
	    isEmptyAndObject("1")
	    false
	    isEmptyAndObject([])
	    true
	    isEmptyAndObject([1])
	    false
	    isEmptyAndObject({})
	    true
	    isEmptyAndObject({a:1})
	    false
	    */

	    //true cases regards it's empty
	    if (obj === null || obj === undefined) {
	        return true;
	    }
	    if (obj.length === 0) {
	        return true;
	    }
	    if (obj === "") {
	        return true;
	    }


	    //false case regards it's not empty
	    if (typeof(obj) !== "object") {
	        return false;
	    }
	    if (obj.length > 0) {
	        return false;
	    }
	    for (var key in obj) {
	        if (obj.hasOwnProperty(key)) {
	            return false;
	        }
	    }

	    //it must be empty if goes here like {} object case
	    return true;
	};

	var unique = function () {
	    var uniqueObject = {};//clousure, uniqueObject in sub function will point this in runtime
	    return {
	        pushAndCheck: function (key_, str_) {
	            var key = key_ + "_" + str_;
	            if (!uniqueObject[key]) {
	                uniqueObject[key] = true;
	                return true;
	            } else {
	                return false;
	            }
	        }
	    };
	};


	var isNumeric = function (n) {
	    var result = false;
	    try {
	        result = !isNaN(parseFloat(n)) && isFinite(n);
	    } catch(ex) {
	        debug(ex);
	    }
	    return result;
	};


	var getMsecTime = function(strTime, duration) {
	    try {
	        //duration = duration ? duration : 0;
	        var nPos = strTime.indexOf('%');
	        if (nPos > 0) {
	            if (duration && duration > 0) {
	                var _tmpPerc = Number(strTime.substring(0, nPos));
	                if (_tmpPerc >= 0 && _tmpPerc <= 100) {
	                    return Math.round(duration * (_tmpPerc / 100));//apply duration to this calculation
	                } else {
	                    return -1;
	                }
	            }
	            else {
	                return -1;
	            }
	        } else {
	            nPos = strTime.indexOf('.');
	            var msecs = nPos > 0 ? Number(strTime.substring(nPos + 1).substr(0,3)) : 0;//only allow 3 digit of under 0
	            if (nPos > 0) {
	                strTime = strTime.substring(0, nPos);
	            }
	            var arr = strTime.split(':');
	            if (arr.length === 3) {
	                for (var _tmp = 0; _tmp < arr.length; _tmp++) {
	                    var token = arr[_tmp];
	                    if (token && isNumeric(token) === false || parseInt(token) < 0) {//handle inacceptable values as -1
	                        return -1;
	                    }
	                }
	                var result = (Number(arr[0]) * 3600 + Number(arr[1]) * 60 + Number(arr[2])) * 1000 + msecs;
	                if (duration) {
	                    if (result <= duration) {
	                        return result;
	                    } else {
	                        return -1;
	                    }
	                } else {
	                    return result;
	                }

	            } else {
	                return -1;
	            }
	        }
	    } catch (ex) {
	        debug(ex);
	        return -1;
	    }
	};

	// Collision detection for given elements
	function elementsOverlap (el1, el2) {
	    if (!(el1 && el2 && el1.getBoundingClientRect && el2.getBoundingClientRect)) {
	        info('Utils.elementsOverlap expects two html elements');
	        return false;
	    }

	    var el1Bounds = el1.getBoundingClientRect();
	    var el2Bounds = el2.getBoundingClientRect();

	    return !(
	        el1Bounds.right < el2Bounds.left ||
	        el1Bounds.left > el2Bounds.right ||
	        el1Bounds.bottom < el2Bounds.top ||
	        el1Bounds.top > el2Bounds.bottom
	    );
	}


	module.exports = {
	    isIphone: isIphone,
	    isIos: isIos,
	    isAndroid: isAndroid,
	    isMobile: isMobile,
	    getIOSVersion: getIOSVersion,
	    refreshVideoLookAndFeel: refreshVideoLookAndFeel,
	    fireEvent: fireEvent,
	    DelayEventHandler: DelayEventHandler,
	    isEmpty: isEmpty,
	    unique: unique,
	    getMsecTime: getMsecTime,
	    isNumeric: isNumeric,
	    makeIframeFlexbileSize: makeIframeFlexbileSize,
	    isEmptyAndObject: isEmptyAndObject,
	    elementsOverlap: elementsOverlap
	};


/***/ }),
/* 9 */
/***/ (function(module, exports) {

	/**
	 * Client Side Logging module.
	 * @module Logging
	 */


	//Note that we have an excessive amount of try/catch blocks in this code. 
	//That is intentional. Logging should never break the features which are using it

	var TRACE_LEVEL_SILENT = 0;
	var TRACE_LEVEL_ALWAYS = 1;
	var TRACE_LEVEL_ERROR = 2;
	var TRACE_LEVEL_WARN = 3;
	var TRACE_LEVEL_INFO = 4;
	var TRACE_LEVEL_LOG = 5;
	var TRACE_LEVEL_DEBUG = 6;
	var TRACE_LEVEL_VERBOSE = 6;

	var LOCAL_STORAGE_KEY_NAME = "AppNexus_Page_Debug_Log_Level";

	//not an actual debug level, but used as a shortcut so we always
	//know what the max debug level is
	var TRACE_LEVEL_ALL = TRACE_LEVEL_DEBUG;
	var TRACE_LEVEL_DEFAULT = TRACE_LEVEL_SILENT;

	//the current debug level to use
	var _curDebugLevel = TRACE_LEVEL_DEFAULT;

	//the debug level that was set via querystring
	var _debugLevelQueryString = TRACE_LEVEL_DEFAULT;

	//the debug level that was set via localStorage
	var _debugLevelLocalStorage = TRACE_LEVEL_DEFAULT;

	//the debug level that was set via call to setDebugLevel
	var _debugLevelFunctionSet = TRACE_LEVEL_DEFAULT;

	function getCurrentTimeString() {
	    var dateToReturn = "";
	    try {
	        var curDate = new Date();
	        //  try{
	        //     dateToReturn = curDate.toISOString();
	        // }catch(ex){
	        dateToReturn = curDate.getHours() + ":" + curDate.getMinutes() + ":" + curDate.getSeconds() + "." + curDate.getMilliseconds();

	        //}
	    } catch (e) {}
	    return dateToReturn;

	}

	function getTraceMethodName(messageLogLevel) {
	    switch (messageLogLevel) {
	        case 0:
	            break;
	        case 1:
	            return 'always';
	        case 2:
	            return 'error';
	        case 3:
	            return 'warn';
	        case 4:
	            return 'info';
	        case 5:
	            return 'log';
	        case 6:
	            return 'debug';
	        case 7:
	            return 'verbose';
	        default:
	            break;
	    }
	}

	function traceMessageAtLevel(messageLogLevel, args) {

	    try {
	        //if method has been defined, and the correct debug level has been set, log it
	        if (typeof messageLogLevel !== 'undefined' && okToLogMessage(messageLogLevel)) {
	            if (console) {
	                var messagePrefix = "[APN";
	                var methodToUse = getTraceMethodName(messageLogLevel);

	                //if console message doesn't exist, use 'log' and
	                //set the original method in the message prefix 
	                if (!console[methodToUse]) {
	                    messagePrefix += "-" + methodToUse;
	                    methodToUse = 'log';
	                }
	                messagePrefix += "]";
	                messagePrefix += "[" + getCurrentTimeString() + "]";

	                args.splice(0, 0, messagePrefix);
	                //from http://tobyho.com/2012/07/27/taking-over-console-log/
	                if (console[methodToUse].apply) {
	                    console[methodToUse].apply(console, args);
	                } else {
	                    var message = Array.prototype.slice.apply(args).join('');
	                    console[methodToUse](message);
	                }
	            }
	        }
	    } catch (e) {}
	}


	//get a named parameter from the querystring
	function getParameterByName(name) {
	    //accesing window might fail at the browser level, we can't really test for it,
	    //so there are a few nested try/catch blocks here
	    try {
	        var urlToSearch = '';
	        //try checking the topmost window, and if not, use current window
	        try {
	            urlToSearch = window.top.location.search;
	        } catch (e) {
	            try {
	                urlToSearch = window.location.search;
	            } catch (e) {}
	        }

	        var regexS = '[\\?&]' + name + '=([^&#]*)';
	        var regex = new RegExp(regexS);
	        var results = regex.exec(urlToSearch);
	        if (results === null) {
	            return '';
	        }
	        return decodeURIComponent(results[1].replace(/\+/g, ' '));
	    } catch (e) {
	        return '';
	    }
	}

	function parseDebugLevelInput(incomingDebugLevel) {
	    var debugLevelToReturn = TRACE_LEVEL_DEFAULT;
	    try {
	        if (typeof incomingDebugLevel !== "undefined") {
	            var debugLevelToParseInt = parseInt(incomingDebugLevel);
	            //if level is an integer, treat it as such
	            if (!isNaN(debugLevelToParseInt)) {
	                debugLevelToReturn = debugLevelToParseInt;
	            } else {
	                if (typeof incomingDebugLevel === "boolean") {
	                    if (incomingDebugLevel) {
	                        debugLevelToReturn = TRACE_LEVEL_ALL;
	                    } else {
	                        debugLevelToReturn = TRACE_LEVEL_SILENT;
	                    }
	                } else {
	                    //not an integer or boolean, treat it as a string
	                    incomingDebugLevel = incomingDebugLevel.toUpperCase();
	                    if (incomingDebugLevel === "TRUE") {
	                        debugLevelToReturn = TRACE_LEVEL_ALL;
	                    } else {
	                        if (incomingDebugLevel === "FALSE") {
	                            debugLevelToReturn = TRACE_LEVEL_SILENT;
	                        }
	                    }
	                }
	            }
	        }
	    } catch (e) {}

	    return debugLevelToReturn;
	}

	function getLogLevelFromLocalStorage() {
	    try {
	        if (localStorage) {
	            return localStorage.getItem(LOCAL_STORAGE_KEY_NAME);
	        }
	    } catch (e) {
	        //default debug level is returned if the key doesn't exist.
	        //https://developer.mozilla.org/en-US/docs/Web/API/Storage/getItem
	        return TRACE_LEVEL_DEFAULT;
	    }
	}

	//determine the maximum debug level from the page URL
	function setDebugLevelFromPage() {
	    try {
	        //keep track of the new level
	        _debugLevelQueryString = parseDebugLevelInput(getParameterByName("ast_debug").toUpperCase());
	        _debugLevelLocalStorage = parseDebugLevelInput(getLogLevelFromLocalStorage());

	        //the highest (least restrictive debug level) always wins
	        _curDebugLevel = Math.max(Math.max(_debugLevelQueryString, _debugLevelLocalStorage), _curDebugLevel);

	    } catch (e) {}
	}

	function handleSetDebugLevel(newDebugLevel) {
	    try {
	        //keep track of the new level
	        _debugLevelFunctionSet = parseDebugLevelInput(newDebugLevel);

	        //the highest (least restrictive debug level) always wins
	        _curDebugLevel = Math.max(Math.max(_debugLevelQueryString, _debugLevelFunctionSet), _curDebugLevel);

	    } catch (e) {}
	}

	function okToLogMessage(level) {
	    return level <= _curDebugLevel; // getReqestedMaxDebugLevel();
	}


	//DEPRECATED
	function tryLogMessageLegacy(level, message, source) {
	    try {
	        var messageToLog = "[APN-" + level + "-" + new Date().toISOString() + "] ";
	        if (source !== null && source && source.length > 0) {
	            messageToLog += source + ">";
	        }
	        messageToLog += message;

	        if (okToLogMessage(level)) {
	            console.log(messageToLog);
	        }
	    } catch (ex) {
	        if (okToLogMessage(level)) {
	            console.log(ex);
	        }
	    }
	}

	module.exports = {


	    /**
	     * Call the appropriate trace method at the given level 
	     * @param (string) debugLevel = Level to debug at
	     */
	    traceAtLevel: function() {
	        try {
	            if (arguments.length > 0) {
	                var targetTraceLevel = arguments[0];
	                var argsWithoutTraceLevel = Array.prototype.slice.call(arguments, 1);
	                traceMessageAtLevel.call(this, targetTraceLevel, argsWithoutTraceLevel);
	            }
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "always" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "log" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.log style logging.
	     */
	    always: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_ALWAYS, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },


	    /**
	     * If the logging level for type "error" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "error" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.error style logging.
	     */
	    error: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_ERROR, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "log" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "log" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.log style logging.
	     */
	    log: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_LOG, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "warn" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "warn" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.warn style logging.
	     */
	    warn: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_WARN, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "info" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "info" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.info style logging.
	     */
	    info: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_INFO, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "debug" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "debug" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.debug style logging.
	     */
	    debug: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_DEBUG, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "verbose" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "debug" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.debug style logging.
	     */
	    verbose: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_VERBOSE, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * @deprecated - use other logging methods in this library
	     * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
	     * @param (string) message = text to be written to the log
	     * @param (string) source = optional string which identifies the source of the debug statement
	     *      - if present, then it will be prepended to front of the string
	     *      - example 1:  debug("hello") ==> <timestamp> hello
	     *      - example 2:  debug("hello", "TM") ==> <timestamp> TM>hello
	     */
	    handleLogDebugLegacySupport: function(message, source) {
	        /*
	        var mainArguments = Array.prototype.slice.call(arguments);
	        mainArguments.unshift("DEBUG");
	        */
	        try {
	            tryLogMessageLegacy(TRACE_LEVEL_LOG, message, source);
	        } catch (e) {}
	    },

	    /**
	     * Sets debug level for logger
	     * @param (string) level = Debug level to use
	     */
	    setDebugLevel: function(newLevel) {
	        try {
	            handleSetDebugLevel(newLevel);
	        } catch (e) {}
	    },


	    /**
	     * Checks if specified trace level will be emitted given the current trace level settings.
	     * @param (Number) levelToCheck = Debug level to check
	     */
	    isTraceLevelActive: function(levelToCheck) {
	        try {
	            return okToLogMessage(levelToCheck);
	        } catch (e) {
	            return false;
	        }
	    },

	    /** @constant {number} */
	    TRACE_LEVEL_ALWAYS: TRACE_LEVEL_ALWAYS,

	    /** @constant {number} */
	    TRACE_LEVEL_ERROR: TRACE_LEVEL_ERROR,

	    /** @constant {number} */
	    TRACE_LEVEL_WARN: TRACE_LEVEL_WARN,

	    /** @constant {number} */
	    TRACE_LEVEL_INFO: TRACE_LEVEL_INFO,

	    /** @constant {number} */
	    TRACE_LEVEL_LOG: TRACE_LEVEL_LOG,

	    /** @constant {number} */
	    TRACE_LEVEL_DEBUG: TRACE_LEVEL_DEBUG,

	    /** @constant {number} */
	    TRACE_LEVEL_VERBOSE: TRACE_LEVEL_VERBOSE
	};


	//look in the query string for debug level
	setDebugLevelFromPage();


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	var prefixOfLog = "[PlayerManager_InitializeElements]";
	var APN_Logger = __webpack_require__(9);

	var verbose = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};
	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};
	var log = function (message) {
	    APN_Logger.log(prefixOfLog, message);
	};

	/**
	 * InializeElement
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {

	    return {
	        init: function (callback) {

	            log("init");

	            var iframeVideoWrapper;
	            var found = false;

	            if (playerManager.autoplayHandler.isRequiredFakeAndroidAutoStart(html5PlayerSelf.options.initialPlayback, html5PlayerSelf.options.initialAudio, html5PlayerSelf.options.automatedTestingOnlyAndroidSkipTouchStart, true)) {
	                verbose("Setting correct iframe for androids 'fake' autostart");
	                var iframes = html5PlayerSelf.options.targetElement.getElementsByTagName("iframe");
	                for (var i = 0; i < iframes.length; i++) {
	                    var iframe = iframes[i];
	                    var name = playerManager.autoplayHandler.APN_MOBILE_IFRAME_NAME;
	                    if (html5PlayerSelf.isAndroid() && html5PlayerSelf.options.firstAdAttempted && html5PlayerSelf.options.adAttempt) {
	                        name = playerManager.autoplayHandler.APN_MOBILE_IFRAME_NAME + "_Waterfall_" + html5PlayerSelf.options.adAttempt;
	                    }
	                    if (iframes && iframe.name && iframe.name === name) {
	                        found = true;
	                        iframeVideoWrapper = iframe;
	                        break;
	                    }
	                }
	            }

	            if (!found) {
	                verbose("Creating new iframe if one is not already created.");
	                iframeVideoWrapper = document.createElement("iframe");
	                iframeVideoWrapper.src = "about:blank";
	                html5PlayerSelf.targetElement.appendChild(iframeVideoWrapper);


	                //VIDLA-90 fix IAS viewability tracking issue to have proper Iframe.location.origin
	                //var defaultTemplate = "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body style=\"margin:0px;overflow:hidden;\">\n</body>\n</html>\n";
	                var defaultTemplate = "<html></html>";//fix VIDLA-320 to have null doctype like we did before - it means this is the same with not invoking .write("") like we did at the begining of this project

	                iframeVideoWrapper.contentWindow.document.open();
	                iframeVideoWrapper.contentWindow.document.write(defaultTemplate);
	                iframeVideoWrapper.contentWindow.document.close();

	            }

	            //generate iframe
	            iframeVideoWrapper.id = html5PlayerSelf.options.iframeVideoWrapperId;
	            iframeVideoWrapper.style.width = html5PlayerSelf.options.width + "px";
	            iframeVideoWrapper.style.height = html5PlayerSelf.options.height + "px";
	            iframeVideoWrapper.style.display = "";
	            //TODO: maybe set all of these to initial, but IE does not support so maybe not
	            //iframeVideoWrapper.id = "iframeVideoWrapper";

	            if (!found) {
	                debug("Html5Player created new iframe: " + html5PlayerSelf.options.iframeVideoWrapperId);
	            }

	            //allow fullscreen in iframe
	            iframeVideoWrapper.setAttribute("allowfullscreen", "true");
	            iframeVideoWrapper.setAttribute("webkitallowfullscreen", "true");
	            iframeVideoWrapper.setAttribute("mozallowfullscreen", "true");

	            //have same color with control-bar
	            if (html5PlayerSelf.options.playerSkin && html5PlayerSelf.options.playerSkin.controlBarColor && iframeVideoWrapper.contentWindow && iframeVideoWrapper.contentWindow.document && iframeVideoWrapper.contentWindow.document.body && iframeVideoWrapper.contentWindow.document.body.style) {
	                iframeVideoWrapper.contentWindow.document.body.style.background = playerManager.options.playerSkin.controlBarColor;
	            }

	            var handleCallback = function () {

	                var IframeDocument = iframeVideoWrapper.contentWindow.document;
	                var IframeWindow = iframeVideoWrapper.contentWindow.window;


	                //create top chrome bar
	                debug("Creating and styling top chrome bar");
	                var topChrome = IframeDocument.createElement("div");
	                topChrome.id = "top_chrome";
	                topChrome.style.height = (function () {
	                    if (html5PlayerSelf.options.playerSkin && typeof html5PlayerSelf.options.playerSkin.dividerHeight === "number") {
	                        return html5PlayerSelf.topChromeHeight - html5PlayerSelf.options.playerSkin.dividerHeight + "px";
	                    }
	                    // in order to keep the top chrome 24 px, we subtract the width of the divider
	                    // (default of 1px) from the height of the chrome bar
	                    return html5PlayerSelf.topChromeHeight - 1 + "px";
	                })();
	                topChrome.style.width = html5PlayerSelf.options.width + "px";
	                topChrome.style.marginRight = "auto";
	                topChrome.style.marginLeft = "auto";
	                topChrome.className = "video-js vjs-default-skin";

	                //generate video object
	                debug("Generating and styling video object");
	                var videoEl;
	                var found = false;

	                if (playerManager.autoplayHandler.isRequiredFakeAndroidAutoStart(html5PlayerSelf.options.initialPlayback, html5PlayerSelf.options.initialAudio, html5PlayerSelf.options.automatedTestingOnlyAndroidSkipTouchStart, true)) {

	                    var prebuiltVideo = iframeVideoWrapper.contentWindow[playerManager.autoplayHandler.APN_MOBILE_VIDEO_PLACEMENT_ID];
	                    if (prebuiltVideo) {
	                        found = true;
	                        videoEl = prebuiltVideo;//override video object to resolve autoplay issue on Android
	                    }

	                }

	                if (!found) {
	                    videoEl = IframeDocument.createElement("video");
	                }

	                videoEl.id = html5PlayerSelf.an_video_ad_player_id;
	                videoEl.className = "video-js vjs-default-skin";
	                videoEl.style.marginRight = "auto";
	                videoEl.style.marginLeft = "auto";

	                topChrome.style["z-index"] = videoEl.style["z-index"] + 1;


	                //add condtition to figure out video.js problem in high latency network - video.js doesn't load video in high latency netowrk if we pass this source so that setting src should be done after video.js initalized
	                //generate source object
	                if (html5PlayerSelf.options.vpaid === false) {
	                    debug("Generating source object");
	                    var mp4Source = IframeDocument.createElement("source");
	                    mp4Source.type = html5PlayerSelf.options.video.type;
	                    mp4Source.src = html5PlayerSelf.options.videoUrl;
	                    if (!html5PlayerSelf.options.vpaid) {
	                        videoEl.appendChild(mp4Source);
	                    }
	                }


	                //inject required object into iframe
	                debug("Injecting required elements into iframe");
	                if (!html5PlayerSelf.options.disableTopBar) {
	                    IframeDocument.body.appendChild(topChrome);
	                    //topChrome.appendChild(customDivider);
	                }

	                IframeDocument.body.appendChild(videoEl);
	                IframeWindow.videojs = html5PlayerSelf.videojsOrigin;

	                if (html5PlayerSelf.options.vpaid) {
	                    //inject javascript vpaid module to iframe
	                    var videojsVpaidScript = IframeDocument.createElement("script");
	                    videojsVpaidScript.innerHTML = playerManager.videojs_vpaid;
	                    IframeDocument.head.appendChild(videojsVpaidScript);
	                }


	                IframeDocument.body.style.margin = "0px";
	                IframeDocument.body.style.overflow = "hidden";
	                callback(iframeVideoWrapper);

	            };


	            var isCompletedHandleCallbcak = false;
	            var is_firefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
	            if (is_firefox && playerManager.overlayPlayer === false) {
	                iframeVideoWrapper.onload = function () {
	                    handleCallback();
	                    isCompletedHandleCallbcak = true;
	                };
	                //for Outstream + Firefox combination, adunit will be terminated in vpaid timeout if window.load event is not delivered.
	                setTimeout(function () {
	                    if (isCompletedHandleCallbcak === false) {
	                        verbose("destroying due to an error in firefox");
	                        playerManager.destroyWithoutSkip(true, html5PlayerSelf.CONST_MESSAGE_GENERAL_ERROR, null, 900);
	                    }
	                }, html5PlayerSelf.options.vpaidTimeout);
	            } else {
	                handleCallback();
	            }

	        },
	    };
	};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var utils = __webpack_require__(8);
	var JSVPAIDConfigure = __webpack_require__(12);
	var _logger = __webpack_require__(9);
	var error = function (message) {
	    _logger.error("Video Player: " + message);
	};
	var log = function (message) {
	    _logger.log("Video Player: " + message);
	};
	var topBarHeight = 24;

	/**
	 * UI Controller for html5 player
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager, cbInjectEventToPlayer) {
	    return {
	        "init": function (iframeVideoWrapper) {
	            /**
	             * this method for customizing video.js player by its own API
	             * @param iframeVideoWrapper
	             */

	            log("init");

	            //video object in iframe
	            var an_html5_video_object = iframeVideoWrapper.contentWindow.document.getElementById(html5PlayerSelf.an_video_ad_player_id);
	            playerManager.iframeVideoWrapper = iframeVideoWrapper;

	            //activate JSVPAID plug-in this should be actiavated before video.js intialized
	            if (html5PlayerSelf.options.vpaid) {
	                try {
	                    playerManager.options.showVpaidIcons = false;
	                    JSVPAIDConfigure(playerManager);
	                } catch (ex) {
	                    error(ex);
	                }
	            } else {
	                //Cleanup previous plugin reference.
	                //VID-2023 Specific waterfall placement times out due to error on IE and Edge browsers on PC
	                if (html5PlayerSelf.options.isWaterfall && html5PlayerSelf.options.plugins) {
	                    html5PlayerSelf.options.plugins = null;
	                }
	            }

	            //fallback play for latest mobile browsers on iOS and Android both will auto-play by "autoplay" and "muted" attributes in video element. video.js will set the attributes by following codes.
	            if (html5PlayerSelf.options.initialPlayback === "autoWithFallbackPlay") {
	                html5PlayerSelf.options.autoplay = true;
	                html5PlayerSelf.options.muted = true;
	            }

	            //initialize video.js
	            html5PlayerSelf.videojsOrigin(an_html5_video_object, html5PlayerSelf.options, function () {//the "this" in this callback function will be API of videojs

	                var videojsAPI = this;

	                //do customize video.js after video.js initialized by calling back this function
	                __webpack_require__(14)(html5PlayerSelf, playerManager).init(videojsAPI, iframeVideoWrapper, cbInjectEventToPlayer);

	                //set video url if it's not VPAID
	                if (html5PlayerSelf.options.vpaid === false) {
	                    videojsAPI.src(html5PlayerSelf.options.videoUrl);
	                }

	                //do post process of this customize after setting video url
	                __webpack_require__(32)(html5PlayerSelf, playerManager).init(videojsAPI, utils, topBarHeight);

	            });

	            //notify initialize done to VPAID plugin
	            if (html5PlayerSelf.options.vpaid && playerManager && playerManager.adVideoPlayer && playerManager.adVideoPlayer.trigger) {
	                playerManager.adVideoPlayer.trigger("an.doneInitialize");
	            }


	        }
	    };


	};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * JSVPAID Configure module this is used for AdVideoPlayerHtml5 and AdVideoPlayerHtml5Ios
	 * @type {*|exports|module.exports}
	 */

	var utils = __webpack_require__(8);
	var _logger = __webpack_require__(9);
	var _uaParser = __webpack_require__(13);
	var CONST_MESSAGE_VAST_ADERROR = "VAST AdError reported from JS VPAID player";
	var CONST_MESSAGE_VPAID_ADERROR = "VPAID AdError reported from JS VPAID player";
	var error = function (message, category) {
	    _logger.error('[' + new Date().toISOString() + '] ' + message, category);
	};
	var warn = function (message) {
	    _logger.warn("JS VPAID" + message);
	};
	var info = function (message) {
	    _logger.info("JS VPAID" + message);
	};
	var log = function (message) {
	    _logger.log("JS VPAID" + message);
	};
	var debug = function (message) {
	    _logger.debug("JS VPAID" + message);
	};
	var verbose = function (message) {
	    _logger.verbose("JS VPAID" + message);
	};

	var JSVPAIDConfigure = function (playerManager) {

	    var dispatchEventToAdunit = playerManager.dispatchEventToAdunit.bind(playerManager);
	    var options = playerManager.options;
	    var videojsOrigin = playerManager.videoPlayerObj;
	    var jsVpaidUrl = options.videoUrl;
	    var callbackForAdUnit = playerManager.callbackForAdUnit;
	    var iframeVideoWrapper = playerManager.iframeVideoWrapper;
	    var alreadyProcessedError = false;
	    var ua = _uaParser();
	    var browser = ua.browser.name.toLowerCase();

	    // for Overlay player do not show any VPAID visual elements until AdStarted  is sent by creative.
	    if (!utils.isIos() && !utils.isAndroid() && iframeVideoWrapper && options.overlayPlayer && options.initialPlayback === "auto") {
	        // VIDLA-1125 IE does not like display none as it cases issues with z ordering or element overlap.
	        if(browser === "edge" || browser === "ie"){
	            iframeVideoWrapper.style.visibility = "hidden";
	        }else{
	            iframeVideoWrapper.style.display = "none";
	        }
	    }

	    //add plugin to activate vpaid-js component
	    options.plugins = {"ads-setup": {}};
	    options.vpaidImpressionFired = false;

	    if(options.isWaterfall && options.firstAdAttempted){
	        if(options.delayExpandUntilVPAIDImpression){
	            options.delayExpandUntilVPAIDInit = false;
	        } else if(options.isExpanded) {
	            options.delayExpandUntilVPAIDInit = false;
	        }
	    }

	    //initalize JSVPAID plug-in
	    videojsOrigin.plugin('ads-setup', function (opts) {
	        debug(opts);
	        var vpaidTimeout = 5000;
	        if (options.vpaidTimeout !== undefined) {
	            vpaidTimeout = options.vpaidTimeout;
	        }
	        var loggerCallback = {
	            'error' : error,
	            'warn' : warn,
	            'info' : info,
	            'log' : log,
	            'debug' : debug,
	            'verbose' : verbose
	        };
	        var vpaidEventCallback = function (eventName, data) {
	            var event = {
	                'AdImpression': 'video_impression',
	                'AdVideoStart': 'video_start',
	                'AdVideoFirstQuartile': 'video-first-quartile',
	                'AdVideoMidpoint': 'video-mid',
	                'AdVideoThirdQuartile': 'video-third-quartile',
	                'AdVideoComplete': 'video_complete',
	                'AdSkipped': 'video_skip',
	                'AdClickThru': 'ad-click'
	            };
	            if(eventName === 'AdImpression'){
	                options.vpaidImpressionFired = true;
	            }

	            if (eventName === 'AdClickThru') {
	                if (data && data.playerHandles) {
	                    // the player handles vpaid creative click event
	                    if (data.hasOwnProperty('url') && data.url && data.url.length > 0) {
	                        playerManager.click(data.url);
	                    }
	                    else {
	                        playerManager.click();
	                    }
	                }
	                else {
	                    // creative handles this event. we need only notify ad about click
	                    dispatchEventToAdunit({"name": "ad-click", "trackClick": true});
	                }
	            } else if(event[eventName]){
	                dispatchEventToAdunit({"name": event[eventName]});
	            }
	            playerManager.notifyVpaidEvent(eventName);

	            //VIDLA-1360 this should was moved from Event.js - "ended" event handler to avoid a conflict situation
	            if (eventName === "AdVideoComplete") {
	                playerManager.adVideoPlayer.trigger("customDestroy");//trigger custom event to handle destroy at central place
	            }
	        };
	        var disableControlsOnMouseover = utils.isIos() || utils.isAndroid();
	        var videojsPlayer = this;

	        if(playerManager.options.overlayPlayer){
	            // VIDLA-1262: As overlay player may initAd prior to the resize calculations have been done,
	            // or even before it gets a handle to the framework, we force a resize in-order to allow the vpaid plugin to
	            // get the right dimensions for initializing the creative.
	            playerManager.resizeVideo();
	        }

	        var vastAd = videojsPlayer.vastClient({
	            url: "",//url doesn't necessary in this vpaid plug-in
	            jsVpaidUrl: jsVpaidUrl,
	            playAdAlways: true,
	            adCancelTimeout: vpaidTimeout,
	            adsEnabled: true,
	            adParameters: options.adParameters,
	            clickUrl: options.clickUrls[0],
	            delayExpandUntilVPAIDInit: options.delayExpandUntilVPAIDInit,
	            terminateUnresponsiveVPAIDCreative: options.terminateUnresponsiveVPAIDCreative,
	            disableControlsOnMouseover: disableControlsOnMouseover,
	            initialAudio: options.initialAudio,
	            loggerCallback: loggerCallback,
	            vpaidEventCallback: vpaidEventCallback,
	            delayExpandUntilVPAIDImpression: options.delayExpandUntilVPAIDImpression,
	            vpaidEnvironmentVars: options.vpaidEnvironmentVars,
	            overlayPlayer: options.overlayPlayer,
	            mobileSDK: options.mobileSDK,
	            initialPlayback: options.initialPlayback,
	            controlBarPosition: options.controlBarPosition
	        });

	        //VIDLA-945 + VIDLA-946 : Dated:05-02-2017 For iOS9 and Android DataSaver on Force a click button.
	        //VIDLA-2058 Chrome /safari autoplay block
	        var forceOverlayPlayerClickForUnsupportedAutoPlay = function (){
	            if(!playerManager.options.overlayPlayer){
	                return;
	            }
	            var player = videojsPlayer;
	            // VIDLA-1189 : if video is paused by any device we have to synch up our UI.
	            var timeVal = utils.isAndroid() ? 1000 : 500;
	            setTimeout(function (){
	                // VIDLA-2097 Do this only for creatives which use our video slot and do not create their own.
	                if(player.paused() && (player.tech && player.tech.el() && player.tech.el().src)){
	                    player.trigger('pause');
	                }
	            },timeVal);
	        };

	        videojsPlayer.on('reset', function () {
	            if (videojsPlayer.options().plugins['ads-setup'].adsEnabled) {
	                vastAd.enable();
	            } else {
	                vastAd.disable();
	            }
	        });


	        videojsPlayer.on('vast.adError', function (evt) {

	            if (alreadyProcessedError === true) {
	                return;
	            } else {
	                alreadyProcessedError = true;
	            }

	            // clean visual element
	            videojsPlayer.loadingSpinner.hide();
	            //on a vast error, end the ad
	            playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VAST_ADERROR, false, 901);

	            var error = evt.error;
	            if (error && error.message) {
	                debug("JS-VPAID Error (vast.adError)" + error.message);
	            }
	        });

	        videojsPlayer.on("vpaid.AdVideoStart",function() {

	            var videoDuration = (playerManager && playerManager.adVideoPlayer && playerManager.adVideoPlayer.player) ? playerManager.adVideoPlayer.player().duration() : 0;
	            // @exclude
	            playerManager.test("VIDLA509",videoDuration);//test duration of metadata
	            // @endexclude

	            //test duraion
	            if (videoDuration && videoDuration > 0) {
	                //set VAST3 attributes to options
	                playerManager.setVastAttribute();//use video metadata for duration
	            } else {
	                var _isInvokedLoadedMetaData = false;
	                //wait loadedmetadata again to give additional opportunity to get duration of video
	                videojsPlayer.one("loadedmetadata",function() {
	                    _isInvokedLoadedMetaData = true;
	                    videoDuration = (playerManager && playerManager.adVideoPlayer && playerManager.adVideoPlayer.player) ? playerManager.adVideoPlayer.player().duration() : 0;

	                    // @exclude
	                    playerManager.test("VIDLA509",videoDuration);//test duration of metadata
	                    // @endexclude

	                    if (videoDuration && videoDuration > 0) {
	                        //use video metadata for duration
	                        playerManager.setVastAttribute();
	                    } else {
	                        //use vast data for duration
	                        var vastDurationMsec = playerManager.options.data.vastDurationMsec;
	                        vastDurationMsec = (vastDurationMsec && vastDurationMsec > 0) ? Math.round(vastDurationMsec / 1000) : 0;

	                        // @exclude
	                        playerManager.test("VIDLA509-2", vastDurationMsec);
	                        // @endexclude

	                        playerManager.setVastAttribute(vastDurationMsec);
	                    }
	                });
	                //timeout to cover if loadMetaData isn't delivered - it will use VAST duration instead of video meta data
	                setTimeout(function() {
	                    if (_isInvokedLoadedMetaData === false) {
	                        var vastDurationMsec = playerManager.options.data.vastDurationMsec;//use vast data for duration
	                        vastDurationMsec = (vastDurationMsec && vastDurationMsec > 0) ? Math.round(vastDurationMsec / 1000) : 0;

	                        // @exclude
	                        playerManager.test("VIDLA509-2", vastDurationMsec);
	                        // @endexclude

	                        playerManager.setVastAttribute(vastDurationMsec);
	                    }
	                },3000);
	            }
	        });

	        //this can be returned from js-vpaid 0.1.24
	        videojsPlayer.on('vast.adTimeout', function () {
	            // clean visual element
	            videojsPlayer.loadingSpinner.hide();
	            playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VPAID_ADERROR, true, 901);
	        });

	        //this can be returned from js-vpaid 0.1.24
	        videojsPlayer.on('vpaid.AdError', function (evt) {

	            if (alreadyProcessedError === true) {
	                return;
	            } else {
	                alreadyProcessedError = true;
	            }

	            // clean visual element
	            videojsPlayer.loadingSpinner.hide();
	            //on a vast error, end the ad
	            playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VPAID_ADERROR, false, 901);

	            var error = evt.error;
	            if (error && error.message) {
	                debug("JS-VPAID Error (vpaid.AdError) " + error.message);
	            }
	        });

	        videojsPlayer.on('vast.adSkip', function () {
	            //on a vast skip, end the ad
	            playerManager.destroy();
	            debug("vast.adSkip");
	        });

	        videojsPlayer.on('vpaid.AdSkipped', function () {
	            //on a vast skip, end the ad
	            playerManager.destroy();
	            debug("vpaid.AdSkipped");
	        });


	        videojsPlayer.on('vpaid.AdIcons', function (data) {
	            //decide whether to show AdIcons
	            if(!data || !data.hasOwnProperty('adIcons') || !data.adIcons){
	                playerManager.options.showVpaidIcons = true;
	            }
	        });

	        videojsPlayer.on('vast.adsCancel', function () {
	            // VIDLA-2232: Prevent adsCancel and adError from both destroying the player (was causing waterfall to advance by 2 steps instead of 1 for placement 11891882)
	            if (alreadyProcessedError) {
	                return;
	            }
	            alreadyProcessedError = true;

	            //on a vast ad cancel, end the ad
	            playerManager.destroyWithoutSkip();
	            debug("adsCancel");
	        });

	        videojsPlayer.on('vpaid.AdStopped', function () {
	            debug("vpaid.AdStopped");
	            if (options.disableCollapse.replay === true) {
	                playerManager.resetVpaid();
	                return;
	            }
	            videojsPlayer.loadingSpinner.hide();
	            videojsPlayer.controlBar.hide();
	            videojsPlayer.bigPlayButton.hide();
	            if (playerManager.isCompleted) {
	                return;
	            }
	            if (!options.disableCollapse.enabled) {
	                playerManager.destroyWithoutSkip();
	            }
	            playerManager.isCompleted = true;
	        });

	        videojsPlayer.one('vpaid.AdStarted', function () {
	            forceOverlayPlayerClickForUnsupportedAutoPlay();
	            // For overlay player show visual elements
	            if (iframeVideoWrapper && options.overlayPlayer) {
	                if(browser === "edge" || browser === "ie"){
	                    iframeVideoWrapper.style.visibility = "visible";
	                }else{
	                    iframeVideoWrapper.style.display = "block";
	                }
	            }
	            // VID-1879 forcefully hiding spinner when creative send back AdStarted to avoid spinning issues due to slow buffering etc.
	            videojsPlayer.loadingSpinner.hide();

	            //minthe : comment out following lines because it looks unnecessary code since we changed iframe's height by resizeVideo and it will notify 'change' to vpaid creative
	            //minthe : and this code might be useful when we had static bottom-bar for JSVPAID, but now we have overlayed style bottom-bar, so this change will work as well
	            /*
	             //TODO change this to beautiful way in order to notify 'change' event into vpaid container which has height as "100%"
	             //some jsvpaid creative detect whole size of outstream, but the creative try to get a value when it has been changing
	             setTimeout(function () {
	             var iframeElement = document.getElementById(options.iframeVideoWrapperId);
	             var tmp = Number(iframeElement.style.height.replace("px", ""));
	             iframeElement.style.height = tmp + 1 + "px";
	             setTimeout(function () {
	             iframeElement.style.height = tmp + "px";
	             }, 500);
	             }, 500);
	             */
	        });

	        videojsPlayer.one("vpaid.AdImpression", function() {
	            forceOverlayPlayerClickForUnsupportedAutoPlay();
	            videojsPlayer.controlBar.show();
	            // VIDLA-1183 showBigPlayButton = false, still big play button is displaying in middle of the player when pause the Ad for VPAID creatives
	            if(options.showBigPlayButton) {
	                videojsPlayer.bigPlayButton.show();
	            }
	        });

	        if (callbackForAdUnit.cbWhenReady) {//for JS-VPAID

	            /**
	             * final process to send signal to Adunit to let them know ready to go
	             */
	            var callcbWhenReady = function () {

	                // @exclude
	                playerManager.test("VIDLA509-1","");
	                // @endexclude

	                debug("callcbWhenReady (Impression, AdStarted are delivered");
	                playerManager.isReadyToExpandForMobile = true;
	                videojsPlayer.tech.removeControlsListeners();
	                var aspectRatioFromVAST = playerManager.options.width / playerManager.options.height;
	                playerManager.resizeVideo(aspectRatioFromVAST, utils.isMobile());
	                // VIDLA-245 for waterfall show play button for non autoplay placements, if needed based on delayExpandUntilVPAID configurations.
	                if(options.isWaterfall && options.firstAdAttempted && options.delayExpandUntilVPAIDInit && !options.isExpanded && options.initialPlayback !== "auto"){
	                    videojsPlayer.bigPlayButton.show();
	                }
	                if (typeof callbackForAdUnit.cbWhenReady === "function") {
	                    callbackForAdUnit.cbWhenReady(playerManager);
	                }
	            };

	            var handleDelayExpand = function () {//VID-1505
	                var doneHandleDelayExpand = false;
	                var currentVolume = videojsPlayer.volume();
	                var adStartedTriggered = false;
	                var adImpressionTriggered = false;
	                var adVideoStartTriggered = false;
	                var isVideoPaused = false;
	                var intervalTimeForPause = 100;

	                var handleEvent = function () {
	                    if (adStartedTriggered && adImpressionTriggered && adVideoStartTriggered && doneHandleDelayExpand === false) {
	                        doneHandleDelayExpand = true;
	                        setTimeout(callcbWhenReady, 500);
	                    }
	                };

	                if (utils.isIos()) {//VID-1742
	                    videojsPlayer.on("timeupdate", function () {
	                        var currentPosition = videojsPlayer.player().currentTime();
	                        if (currentPosition > 0 && isVideoPaused === false && playerManager.isAlreadyPlaingForVPAID === false) {
	                            isVideoPaused = true;
	                            adVideoStartTriggered = true;
	                            videojsPlayer.pause();
	                            handleEvent();
	                            debug("pause by timeupdate when delayExpandUntilVPAIDImpression is true");
	                        }
	                    });
	                    var checkTimingToPause = function () {
	                        var currentPosition = videojsPlayer.player().currentTime();
	                        if (currentPosition > 0 && isVideoPaused === false && playerManager.isAlreadyPlaingForVPAID === false) {
	                            isVideoPaused = true;
	                            adVideoStartTriggered = true;
	                            videojsPlayer.pause();
	                            handleEvent();
	                            debug("pause by timer when delayExpandUntilVPAIDImpression is true");
	                        }
	                        if (!doneHandleDelayExpand) {
	                            setTimeout(checkTimingToPause,intervalTimeForPause);
	                        }
	                    };
	                    setTimeout(checkTimingToPause,intervalTimeForPause);
	                } else {
	                    videojsPlayer.one("vpaid.AdVideoStart", function () {
	                        if (playerManager.isAlreadyPlaingForVPAID === false) {
	                            videojsPlayer.pause();//early pause will cause issue not to dispatch timeupdate
	                        }
	                        videojsPlayer.volume(currentVolume);
	                        adVideoStartTriggered = true;
	                        handleEvent();
	                    });
	                }

	                videojsPlayer.one("vpaid.AdStarted", function () {
	                    adStartedTriggered = true;
	                    handleEvent();
	                });

	                videojsPlayer.one("vpaid.AdImpression", function () {
	                    adImpressionTriggered = true;
	                    handleEvent();
	                });

	                videojsPlayer.volume(0);//set mute
	                playerManager.delayEventHandler.ignoreNextQueue();//for VID-1505

	                if (utils.isIos()) {
	                    playerManager.adVideoPlayer.trigger('play');//jsvpaid in iOS inline should have special call instead of .play() in order to get "AdStarted" event for JSVPAID after that, framework will have proper video url which is set by JSVPAID creative
	                    playerManager.isDoneInitialPlay = true;//mark flag to notify JSVPAID-iOS player resolved initial playback
	                } else {
	                    videojsPlayer.play();
	                }
	            };

	            var decideHowToPlayByDelayStartUntilAdImpression = function () {
	                if (options.delayExpandUntilVPAIDImpression) {
	                    handleDelayExpand(); //case of delayExpandUntilVPAIDImpression
	                } else {
	                    callcbWhenReady();//case of others
	                }
	            };

	            if(options.isWaterfall && options.firstAdAttempted){
	                // For waterfall from second ad onwards trigger ready once the player is ready.
	                videojsPlayer.one("an.doneInitialize", decideHowToPlayByDelayStartUntilAdImpression);

	            } else {
	                if (options.delayExpandUntilVPAIDInit) {
	                    //suppress a call of cbWhenReady until player got custom event in order to notify Outstream to start expanding
	                    videojsPlayer.one("an.readytogovpaid", decideHowToPlayByDelayStartUntilAdImpression);//readytogovpaid will be triggerd when VPAID returns AdLoaded
	                } else {
	                    videojsPlayer.one("an.doneInitialize", decideHowToPlayByDelayStartUntilAdImpression);//doneInitialize will be triggered when ios/html5 player is initialized
	                }
	            }
	        }


	    });


	};
	module.exports = JSVPAIDConfigure;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright © 2012-2016 Faisal Salman <fyzlman@gmail.com>
	 * Dual licensed under GPLv2 & MIT
	 *
	 * User-Agent Parser module.
	 * @module UserAgentParser
	*/

	var prefixOfLog = 'UserAgentParser';
	var APN_Logger = __webpack_require__(9);

	APN_Logger.always(prefixOfLog, 'Version 0.0.1');

	/////////////////
	// Constructor
	////////////////
	var UserAgentParser = function (uastring, extensions) {

		//////////////
		// Constants
		/////////////
		var EMPTY       = '',
		    UNKNOWN     = '?',
		    FUNC_TYPE   = 'function',
		    OBJ_TYPE    = 'object',
		    STR_TYPE    = 'string',
		    MODEL       = 'model',
		    NAME        = 'name',
		    TYPE        = 'type',
		    VENDOR      = 'vendor',
		    VERSION     = 'version',
		    CONSOLE     = 'console',
		    MOBILE      = 'mobile',
		    TABLET      = 'tablet',
		    SMARTTV     = 'smarttv',
		    WEARABLE    = 'wearable';

		///////////
		// Helper
		//////////
		var util = {
		    extend : function (regexes, extensions) {
		        var margedRegexes = {};
		        for (var i in regexes) {
		            if (extensions[i] && extensions[i].length % 2 === 0) {
		                margedRegexes[i] = extensions[i].concat(regexes[i]);
		            } else {
		                margedRegexes[i] = regexes[i];
		            }
		        }
		        return margedRegexes;
		    },
		    has : function (str1, str2) {
		      if (typeof str1 === 'string') {
		        return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
		      } else {
		        return false;
		      }
		    },
		    lowerize : function (str) {
		        return str.toLowerCase();
		    },
		    major : function (version) {
		        return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g,'').split('.')[0] : undefined;
		    },
		    trim : function (str) {
		      return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
		    }
		};

	    ///////////////
	    // Map helper
	    //////////////
	    var mapper = {

	        rgx : function () {

	            var result = {}, i = 0, j, k, p, q, matches, match, args = arguments;

	            // construct object barebones
	            for (p = 0; p < args[1].length; p++) {
	                q = args[1][p];
	                result[typeof q === OBJ_TYPE ? q[0] : q] = undefined;
	            }

	            // loop through all regexes maps
	            while (i < args.length && !matches) {

	                var regex = args[i],       // even sequence (0,2,4,..)
	                    props = args[i + 1];   // odd sequence (1,3,5,..)
	                j = k = 0;

	                // try matching uastring with regexes
	                while (j < regex.length && !matches) {

	                    matches = regex[j++].exec(this.getUA());

	                    if (!!matches) {
	                        for (p = 0; p < props.length; p++) {
	                            match = matches[++k];
	                            q = props[p];
	                            // check if given property is actually array
	                            if (typeof q === OBJ_TYPE && q.length > 0) {
	                                if (q.length === 2) {
	                                    if (typeof q[1] === FUNC_TYPE) {
	                                        // assign modified match
	                                        result[q[0]] = q[1].call(this, match);
	                                    } else {
	                                        // assign given value, ignore regex match
	                                        result[q[0]] = q[1];
	                                    }
	                                } else if (q.length === 3) {
	                                    // check whether function or regex
	                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
	                                        // call function (usually string mapper)
	                                        result[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
	                                    } else {
	                                        // sanitize match using given regex
	                                        result[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
	                                    }
	                                } else if (q.length === 4) {
	                                        result[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
	                                }
	                            } else {
	                                result[q] = match ? match : undefined;
	                            }
	                        }
	                    }
	                }
	                i += 2;
	            }
	            return result;
	        },

	        str : function (str, map) {

	            for (var i in map) {
	                // check if array
	                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
	                    for (var j = 0; j < map[i].length; j++) {
	                        if (util.has(map[i][j], str)) {
	                            return (i === UNKNOWN) ? undefined : i;
	                        }
	                    }
	                } else if (util.has(map[i], str)) {
	                    return (i === UNKNOWN) ? undefined : i;
	                }
	            }
	            return str;
	        }
	    };

	    ///////////////
	    // String map
	    //////////////
	    var maps = {

	        browser : {
	            oldsafari : {
	                version : {
	                    '1.0'   : '/8',
	                    '1.2'   : '/1',
	                    '1.3'   : '/3',
	                    '2.0'   : '/412',
	                    '2.0.2' : '/416',
	                    '2.0.3' : '/417',
	                    '2.0.4' : '/419',
	                    '?'     : '/'
	                }
	            }
	        },

	        device : {
	            amazon : {
	                model : {
	                    'Fire Phone' : ['SD', 'KF']
	                }
	            },
	            sprint : {
	                model : {
	                    'Evo Shift 4G' : '7373KT'
	                },
	                vendor : {
	                    'HTC'       : 'APA',
	                    'Sprint'    : 'Sprint'
	                }
	            }
	        },

	        os : {
	            windows : {
	                version : {
	                    'XP'        : ['NT 5.1', 'NT 5.2'],
	                    'Vista'     : 'NT 6.0',
	                    '7'         : 'NT 6.1',
	                    '8'         : 'NT 6.2',
	                    '8.1'       : 'NT 6.3',
	                    '10'        : ['NT 6.4', 'NT 10.0'],
	                    'RT'        : 'ARM'
	                }
	            }
	        }
	    };

	    //////////////
	    // Regex map
	    /////////////


	    var regexes = {

	        browser : [[

	            // Presto based
	            /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
	            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
	            /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
	            /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
	            ], [NAME, VERSION], [

	            /(opios)[\/\s]+([\w\.]+)/i                                          // Opera mini on iphone >= 8.0
	            ], [[NAME, 'Opera Mini'], VERSION], [

	            /\s(opr)\/([\w\.]+)/i                                               // Opera Webkit
	            ], [[NAME, 'Opera'], VERSION], [

	            // Mixed
	            /(kindle)\/([\w\.]+)/i,                                             // Kindle
	            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i,
	                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer

	            // Trident based
	            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,
	                                                                                // Avant/IEMobile/SlimBrowser/Baidu
	            /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer

	            // Webkit/KHTML based
	            /(rekonq)\/([\w\.]+)*/i,                                            // Rekonq
	            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs)\/([\w\.-]+)/i
	                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS
	            ], [NAME, VERSION], [

	            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
	            ], [[NAME, 'IE'], VERSION], [

	            /(edge)\/((\d+)?[\w\.]+)/i                                          // Microsoft Edge
	            ], [NAME, VERSION], [

	            /(yabrowser)\/([\w\.]+)/i                                           // Yandex
	            ], [[NAME, 'Yandex'], VERSION], [

	            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
	            ], [[NAME, /_/g, ' '], VERSION], [

	            /(micromessenger)\/([\w\.]+)/i                                      // WeChat
	            ], [[NAME, 'WeChat'], VERSION], [

	            /xiaomi\/miuibrowser\/([\w\.]+)/i                                   // MIUI Browser
	            ], [VERSION, [NAME, 'MIUI Browser']], [

	            /\swv\).+(chrome)\/([\w\.]+)/i                                      // Chrome WebView
	            ], [[NAME, /(.+)/, '$1 WebView'], VERSION], [

	            /android.+samsungbrowser\/([\w\.]+)/i,
	            /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i        // Android Browser
	            ], [VERSION, [NAME, 'Android Browser']], [

	            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i,
	                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
	            /(qqbrowser)[\/\s]?([\w\.]+)/i
	                                                                                // QQBrowser
	            ], [NAME, VERSION], [

	            /(uc\s?browser)[\/\s]?([\w\.]+)/i,
	            /ucweb.+(ucbrowser)[\/\s]?([\w\.]+)/i,
	            /juc.+(ucweb)[\/\s]?([\w\.]+)/i
	                                                                                // UCBrowser
	            ], [[NAME, 'UCBrowser'], VERSION], [

	            /(dolfin)\/([\w\.]+)/i                                              // Dolphin
	            ], [[NAME, 'Dolphin'], VERSION], [

	            /((?:android.+)crmo|crios)\/([\w\.]+)/i                             // Chrome for Android/iOS
	            ], [[NAME, 'Chrome'], VERSION], [

	            /;fbav\/([\w\.]+);/i                                                // Facebook App for iOS
	            ], [VERSION, [NAME, 'Facebook']], [

	            /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
	            ], [VERSION, [NAME, 'Firefox']], [

	            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
	            ], [VERSION, [NAME, 'Mobile Safari']], [

	            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
	            ], [VERSION, NAME], [

	            /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
	            ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [

	            /(konqueror)\/([\w\.]+)/i,                                          // Konqueror
	            /(webkit|khtml)\/([\w\.]+)/i
	            ], [NAME, VERSION], [

	            // Gecko based
	            /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
	            ], [[NAME, 'Netscape'], VERSION], [
	            /(swiftfox)/i,                                                      // Swiftfox
	            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
	                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
	            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i,
	                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
	            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla

	            // Other
	            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
	                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir
	            /(links)\s\(([\w\.]+)/i,                                            // Links
	            /(gobrowser)\/?([\w\.]+)*/i,                                        // GoBrowser
	            /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
	            /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
	            ], [NAME, VERSION]
	        ],

	        device : [[

	            /\((ipad|playbook);[\w\s\);-]+(rim|apple)/i                         // iPad/PlayBook
	            ], [MODEL, VENDOR, [TYPE, TABLET]], [

	            /applecoremedia\/[\w\.]+ \((ipad)/                                  // iPad
	            ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [

	            /(apple\s{0,1}tv)/i                                                 // Apple TV
	            ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple']], [

	            /(archos)\s(gamepad2?)/i,                                           // Archos
	            /(hp).+(touchpad)/i,                                                // HP TouchPad
	            /(hp).+(tablet)/i,                                                  // HP Tablet
	            /(kindle)\/([\w\.]+)/i,                                             // Kindle
	            /\s(nook)[\w\s]+build\/(\w+)/i,                                     // Nook
	            /(dell)\s(strea[kpr\s\d]*[\dko])/i                                  // Dell Streak
	            ], [VENDOR, MODEL, [TYPE, TABLET]], [

	            /(kf[A-z]+)\sbuild\/[\w\.]+.*silk\//i                               // Kindle Fire HD
	            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
	            /(sd|kf)[0349hijorstuw]+\sbuild\/[\w\.]+.*silk\//i                  // Fire Phone
	            ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [

	            /\((ip[honed|\s\w*]+);.+(apple)/i                                   // iPod/iPhone
	            ], [MODEL, VENDOR, [TYPE, MOBILE]], [
	            /\((ip[honed|\s\w*]+);/i                                            // iPod/iPhone
	            ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [

	            /(blackberry)[\s-]?(\w+)/i,                                         // BlackBerry
	            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|huawei|meizu|motorola|polytron)[\s_-]?([\w-]+)*/i,
	                                                                                // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Huawei/Meizu/Motorola/Polytron
	            /(hp)\s([\w\s]+\w)/i,                                               // HP iPAQ
	            /(asus)-?(\w+)/i                                                    // Asus
	            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
	            /\(bb10;\s(\w+)/i                                                   // BlackBerry 10
	            ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [
	                                                                                // Asus Tablets
	            /android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i
	            ], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [

	            /(sony)\s(tablet\s[ps])\sbuild\//i,                                  // Sony
	            /(sony)?(?:sgp.+)\sbuild\//i
	            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [
	            /(?:sony)?(?:(?:(?:c|d)\d{4})|(?:so[-l].+))\sbuild\//i
	            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Phone'], [TYPE, MOBILE]], [

	            /\s(ouya)\s/i,                                                      // Ouya
	            /(nintendo)\s([wids3u]+)/i                                          // Nintendo
	            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [

	            /android.+;\s(shield)\sbuild/i                                      // Nvidia
	            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [

	            /(playstation\s[34portablevi]+)/i                                   // Playstation
	            ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [

	            /(sprint\s(\w+))/i                                                  // Sprint Phones
	            ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [

	            /(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i                         // Lenovo tablets
	            ], [VENDOR, MODEL, [TYPE, TABLET]], [

	            /(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,                               // HTC
	            /(zte)-(\w+)*/i,                                                    // ZTE
	            /(alcatel|geeksphone|huawei|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i
	                                                                                // Alcatel/GeeksPhone/Huawei/Lenovo/Nexian/Panasonic/Sony
	            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

	            /(nexus\s9)/i                                                       // HTC Nexus 9
	            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [

	            /(nexus\s6p)/i                                                      // Huawei Nexus 6P
	            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, MOBILE]], [

	            /(microsoft);\s(lumia[\s\w]+)/i                                     // Microsoft Lumia
	            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

	            /[\s\(;](xbox(?:\sone)?)[\s\);]/i                                   // Microsoft Xbox
	            ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [
	            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
	            ], [[MODEL, /\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [

	                                                                                // Motorola
	            /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?(:?\s4g)?)[\w\s]+build\//i,
	            /mot[\s-]?(\w+)*/i,
	            /(XT\d{3,4}) build\//i,
	            /(nexus\s6)/i
	            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [
	            /android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i
	            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [

	            /hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i            // HbbTV devices
	            ], [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]], [

	            /hbbtv.+maple;(\d+)/i
	            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, 'Samsung'], [TYPE, SMARTTV]], [

	            /\(dtv[\);].+(aquos)/i                                              // Sharp
	            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [

	            /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,
	            /((SM-T\w+))/i
	            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung
	            /smart-tv.+(samsung)/i
	            ], [VENDOR, [TYPE, SMARTTV], MODEL], [
	            /((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,
	            /(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i,
	            /sec-((sgh\w+))/i
	            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [

	            /sie-(\w+)*/i                                                       // Siemens
	            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [

	            /(maemo|nokia).*(n900|lumia\s\d+)/i,                                // Nokia
	            /(nokia)[\s_-]?([\w-]+)*/i
	            ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [

	            /android\s3\.[\s\w;-]{10}(a\d{3})/i                                 // Acer
	            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

	            /android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i                     // LG Tablet
	            ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [
	            /(lg) netcast\.tv/i                                                 // LG SmartTV
	            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
	            /(nexus\s[45])/i,                                                   // LG
	            /lg[e;\s\/-]+(\w+)*/i
	            ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [

	            /android.+(ideatab[a-z0-9\-\s]+)/i                                  // Lenovo
	            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

	            /linux;.+((jolla));/i                                               // Jolla
	            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

	            /((pebble))app\/[\d\.]+\s/i                                         // Pebble
	            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [

	            /android.+;\s(glass)\s\d/i                                          // Google Glass
	            ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [

	            /android.+;\s(pixel c)\s/i                                          // Google Pixel C
	            ], [MODEL, [VENDOR, 'Google'], [TYPE, TABLET]], [

	            /android.+;\s(pixel xl|pixel)\s/i                                   // Google Pixel
	            ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [


	            /android.+(\w+)\s+build\/hm\1/i,                                    // Xiaomi Hongmi 'numeric' models
	            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
	            /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d\w)?)\s+build/i    // Xiaomi Mi
	            ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [

	            /android.+a000(1)\s+build/i                                         // OnePlus
	            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

	            /\s(tablet)[;\/]/i,                                                 // Unidentifiable Tablet
	            /\s(mobile)(?:[;\/]|\ssafari)/i                                     // Unidentifiable Mobile
	            ], [[TYPE, util.lowerize], VENDOR, MODEL]
	        ],

	        engine : [[

	            /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
	            ], [VERSION, [NAME, 'EdgeHTML']], [

	            /(presto)\/([\w\.]+)/i,                                             // Presto
	            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,     // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m
	            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
	            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
	            ], [NAME, VERSION], [

	            /rv\:([\w\.]+).*(gecko)/i                                           // Gecko
	            ], [VERSION, NAME]
	        ],

	        os : [[

	            // Windows based
	            /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
	            ], [NAME, VERSION], [
	            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
	            /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s]+\w)*/i,                  // Windows Phone
	            /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
	            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
	            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
	            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

	            // Mobile/Embedded OS
	            /\((bb)(10);/i                                                      // BlackBerry 10
	            ], [[NAME, 'BlackBerry'], VERSION], [
	            /(blackberry)\w*\/?([\w\.]+)*/i,                                    // Blackberry
	            /(tizen)[\/\s]([\w\.]+)/i,                                          // Tizen
	            /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i,
	                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki
	            /linux;.+(sailfish);/i                                              // Sailfish OS
	            ], [NAME, VERSION], [
	            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i                 // Symbian
	            ], [[NAME, 'Symbian'], VERSION], [
	            /\((series40);/i                                                    // Series 40
	            ], [NAME], [
	            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
	            ], [[NAME, 'Firefox OS'], VERSION], [

	            // Console
	            /(nintendo|playstation)\s([wids34portablevu]+)/i,                   // Nintendo/Playstation

	            // GNU/Linux based
	            /(mint)[\/\s\(]?(\w+)*/i,                                           // Mint
	            /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
	            /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]+)*/i,
	                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
	                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
	            /(hurd|linux)\s?([\w\.]+)*/i,                                       // Hurd/Linux
	            /(gnu)\s?([\w\.]+)*/i                                               // GNU
	            ], [NAME, VERSION], [

	            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
	            ], [[NAME, 'Chromium OS'], VERSION],[

	            // Solaris
	            /(sunos)\s?([\w\.]+\d)*/i                                           // Solaris
	            ], [[NAME, 'Solaris'], VERSION], [

	            // BSD based
	            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i                   // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
	            ], [NAME, VERSION],[

	            /(haiku)\s(\w+)/i                                                  // Haiku
	            ], [NAME, VERSION],[

	            /(ip[honead]+)(?:.*os\s([\w]+)*\slike\smac|;\sopera)/i              // iOS
	            ], [[NAME, 'iOS'], [VERSION, /_/g, '.']], [

	            /(mac\sos\sx)\s?([\w\s\.]+\w)*/i,
	            /(macintosh|mac(?=_powerpc)\s)/i                                    // Mac OS
	            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

	            // Other
	            /((?:open)?solaris)[\/\s-]?([\w\.]+)*/i,                            // Solaris
	            /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i,                               // AIX
	            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i,
	                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS
	            /(unix)\s?([\w\.]+)*/i                                              // UNIX
	            ], [NAME, VERSION]
	        ]
	    };

		
	    if (!(this instanceof UserAgentParser)) {
	        return new UserAgentParser(uastring, extensions).getResult();
	    }

	    var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
	    var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;

	    this.getBrowser = function () {
	        var browser = mapper.rgx.apply(this, rgxmap.browser);
	        browser.major = util.major(browser.version);
	        return browser;
	    };
	    this.getDevice = function () {
	        return mapper.rgx.apply(this, rgxmap.device);
	    };
	    this.getEngine = function () {
	        return mapper.rgx.apply(this, rgxmap.engine);
	    };
	    this.getOS = function () {
	        return mapper.rgx.apply(this, rgxmap.os);
	    };
	    this.getResult = function () {
	        return {
	            ua      : this.getUA(),
	            browser : this.getBrowser(),
	            engine  : this.getEngine(),
	            os      : this.getOS(),
	            device  : this.getDevice()
	        };
	    };
	    this.getUA = function () {
	        return ua;
	    };
	    return this;
	};

	module.exports = UserAgentParser;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_CustomizedVideoJS]";
	var APN_Logger = __webpack_require__(9);
	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};

	/**
	 * Customize VideoJS
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {

	    return {
	        "init": function (videojsAPI, iframeVideoWrapper, cbInjectEventToPlayer) {

	            debug("init");

	            // window.debugPlayerAN = videojsAPI;//TODO for debugging video.js api
	            playerManager.adVideoPlayer = videojsAPI;

	            html5PlayerSelf.options.nativeControlsForTouch = false;
	            html5PlayerSelf.options.customControlsOnMobile = false;

	            //TODO for researching mobile features
	            if (html5PlayerSelf.isMobile()) {
	                videojsAPI.enableTouchActivity();
	            } else {
	                videojsAPI.userActive(false);//disable showing controlbar for a moment when video starts, it will be shown up when mouse over or user activity detected
	            }

	            //custom skinning
	            playerManager.customSkinning.render(html5PlayerSelf, videojsAPI, iframeVideoWrapper.contentWindow.document, false);

	            //start of chrome bar
	            var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");
	            var adIndicatorTextObj = iframeVideoWrapper.contentWindow.document.createElement("div");
	            var learnMore = html5PlayerSelf.options.learnMore.enabled;
	            if (!html5PlayerSelf.options.clickUrls[0]) {
	                learnMore = false;
	            }
	            if (learnMore) {
	                if (html5PlayerSelf.options.skippable.skipLocation === "top-right") {
	                    html5PlayerSelf.adIndicatorTextContent = html5PlayerSelf.options.learnMore.text + " " + html5PlayerSelf.options.learnMore.separator + " " + html5PlayerSelf.adIndicatorTextContent;
	                } else {
	                    html5PlayerSelf.adIndicatorTextContent += " " + html5PlayerSelf.options.learnMore.separator + " " + html5PlayerSelf.options.learnMore.text;
	                }
	            }

	            var floatingAdIndicator = html5PlayerSelf.videojsOrigin.createEl('div', {
	                'role': 'button',
	                'innerHTML': html5PlayerSelf.adIndicatorTextContent,
	                'className': "top-bar-text"
	            });

	            var el_wholeArea = document.getElementById(html5PlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(html5PlayerSelf.an_video_ad_player_id);
	            var el_videoArea = document.getElementById(html5PlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(html5PlayerSelf.an_video_ad_player_html5_api_id);


	            //setup html5 video player by html5PlayerSelf.options coming from impbus or publisher's site
	            __webpack_require__(15)(html5PlayerSelf, playerManager).init(videojsAPI);
	            __webpack_require__(16)(html5PlayerSelf, playerManager).init(videojsAPI, iframeVideoWrapper, adIndicatorTextObj, floatingAdIndicator, learnMore);
	            __webpack_require__(17)(html5PlayerSelf, playerManager).init(topChrome, floatingAdIndicator, adIndicatorTextObj, videojsAPI, iframeVideoWrapper);
	            __webpack_require__(18)(html5PlayerSelf, playerManager).init(videojsAPI);
	            __webpack_require__(26)(html5PlayerSelf, playerManager).init(videojsAPI);
	            __webpack_require__(27)(html5PlayerSelf, playerManager).init(videojsAPI, floatingAdIndicator, adIndicatorTextObj);
	            __webpack_require__(28)(html5PlayerSelf).init(videojsAPI);
	            __webpack_require__(29)(html5PlayerSelf, playerManager).init();
	            __webpack_require__(30)(html5PlayerSelf, playerManager).init(videojsAPI);
	            __webpack_require__(31)(html5PlayerSelf, playerManager).init(videojsAPI);

	            //invoke callback when all components is ready to go
	            cbInjectEventToPlayer(el_wholeArea, el_videoArea);

	        }
	    };
	};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var utils = __webpack_require__(8);
	var prefixOfLog = "[PlayerManager_Customize]";
	var APN_Logger = __webpack_require__(9);

	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};

	var verbose = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};

	/**
	 * Setup Custom UI
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {

	    return {
	        "init": function (videojsAPI) {

	            debug("init");

	            if (html5PlayerSelf.options.isWaterfall && html5PlayerSelf.options.vpaid) {
	                //For vpaid ads in waterfall hide controls untill the impression occurs to avoid flicker during failed attempts.
	                videojsAPI.controlBar.hide();
	                if (html5PlayerSelf.options.firstAdAttempted) {
	                    videojsAPI.bigPlayButton.hide();
	                }
	            }

	            //disable scrubbing
	            verbose("disabling scrubbing");
	            videojsAPI.controlBar.progressControl.seekBar.off("mousedown");
	            videojsAPI.controlBar.progressControl.seekBar.off("touchstart");
	            videojsAPI.controlBar.progressControl.seekBar.off("click");

	            verbose("setting initial audio");
	            if (html5PlayerSelf.options.initialAudio === "off") {
	                videojsAPI.muted(true);
	                playerManager.isMuted = true;
	            } else {
	                videojsAPI.muted(false);
	                playerManager.isMuted = false;
	            }

	            //set mouseover to play video option
	            verbose("setting initial playback");
	            if (html5PlayerSelf.options.initialPlayback === "mouseover") {

	                var _tmpMouseoverListener = function () {
	                    playerManager.play();
	                    videojsAPI.el().removeEventListener("mouseover", _tmpMouseoverListener);
	                };
	                videojsAPI.el().addEventListener("mouseover", _tmpMouseoverListener);
	            }

	            //set maintainAspectRatio
	            verbose("setting aspect ratio"); //this doesn't do anything, remove?
	            if (html5PlayerSelf.options.maintainAspectRatio === true) {
	            } else {
	            }

	            var isMuteNeeded = function () {
	                return (html5PlayerSelf.options.showMute === true && (html5PlayerSelf.displayVolumeControls() || html5PlayerSelf.isAndroid()));
	            };

	            //set showVolume
	            if (html5PlayerSelf.options.showVolume === false || !html5PlayerSelf.displayVolumeControls()) {
	                verbose("removing volume controls");
	                videojsAPI.controlBar.volumeControl.dispose();
	            }

	            if (html5PlayerSelf.options.showPlayToggle === false) {
	                videojsAPI.controlBar.playToggle.hide();
	            }

	            if (html5PlayerSelf.options.showBigPlayButton === false) {
	                videojsAPI.bigPlayButton.hide();
	            }

	            //set showMute
	            if (isMuteNeeded()) {
	                verbose("setting mute functionality");
	                var muteHandler = function () {
	                    if (playerManager.isMuted) {
	                        if (videojsAPI.volume() > 0) {
	                            playerManager.explicitUnmute();
	                        }
	                    } else {
	                        playerManager.explicitMute();
	                    }
	                };

	                //for browsers
	                videojsAPI.controlBar.muteToggle.on("click", muteHandler);

	                //for devices
	                videojsAPI.controlBar.muteToggle.on("touchend", muteHandler);
	            } else {
	                verbose("removing mute button");
	                videojsAPI.controlBar.muteToggle.dispose();
	            }

	            //invoke mute

	            if (html5PlayerSelf.options.showVolume === true && html5PlayerSelf.displayVolumeControls()) {
	                videojsAPI.controlBar.volumeControl.volumeBar.on("mousedown", function () {
	                    var volume = videojsAPI.volume();
	                    if (volume <= 0 && !playerManager.isMuted) {
	                        verbose("muting from volume scrubber");
	                        playerManager.explicitMute();
	                    }
	                    if (volume > 0 && playerManager.isMuted) {
	                        verbose("unmuting from volume scrubber");
	                        playerManager.explicitUnmute();
	                    }
	                });
	            }

	            //For iOS10 force the mute button update
	            if (utils.isIos() && html5PlayerSelf.options.enableNativeInline && parseInt(utils.getIOSVersion()) > 9 && html5PlayerSelf.options.initialPlayback !== "click") {
	                videojsAPI.muted(true);
	                videojsAPI.controlBar.muteToggle.update();
	            }

	            if (typeof html5PlayerSelf.options.customButton.enabled === "boolean" && html5PlayerSelf.options.customButton.enabled === true) {
	                var controlBarHeight = html5PlayerSelf.options.playerSkin.controlBarHeight || 30;
	                var imgWidth = Math.min(50, html5PlayerSelf.options.customButton.imgWidth);
	                var imgHeight = Math.min(controlBarHeight, html5PlayerSelf.options.customButton.imgHeight);
	                var topMargin = Math.floor((controlBarHeight - imgHeight) / 2);
	                var spanOrAnchor = "a";
	                if (html5PlayerSelf.isMobile()) {
	                    spanOrAnchor = "span";
	                }

	                var customButton = html5PlayerSelf.videojsOrigin.createEl('div', {
	                    'innerHTML': '<' + spanOrAnchor + ' href="' + html5PlayerSelf.options.customButton.url + '" target="_blank"><img style="height:' + imgHeight + 'px;width:' + imgWidth + 'px;margin-top:' + topMargin + 'px" class="home-button-image" src="' + html5PlayerSelf.options.customButton.imageSrc + '" alt="' + html5PlayerSelf.options.customButton.altText + '"></' + spanOrAnchor + '>',
	                    'role': 'button',
	                    'aria-live': 'polite',
	                    'tabindex': '0'
	                });
	                customButton.style.cssText = "float:right;font-family:VideoJS;font-size:1.5em;line-height:2;width:50px;height:100%;text-align:center";
	                videojsAPI.controlBar.addChild('button', {
	                    'el': customButton
	                });
	                videojsAPI.controlBar.el().insertBefore(customButton, videojsAPI.controlBar.fullscreenToggle.el());
	            }

	            //set showProgressBar
	            videojsAPI.controlBar.progressControl.seekBar.seekHandle.hide();
	            videojsAPI.controlBar.progressControl.seekBar.el_.style.pointerEvents = 'none';


	            if (typeof html5PlayerSelf.options.showProgressBar === "boolean") {
	                if (html5PlayerSelf.options.showProgressBar === false) {
	                    verbose("removing progress bar");
	                    videojsAPI.controlBar.currentTimeDisplay.hide();
	                    videojsAPI.controlBar.timeDivider.hide();
	                    videojsAPI.controlBar.durationDisplay.hide();
	                }
	                videojsAPI.controlBar.progressControl.seekBar.hide();
	            } else {
	                if (html5PlayerSelf.options.showProgressBar === "text") {
	                    verbose("removing progress text");
	                    videojsAPI.controlBar.progressControl.seekBar.hide();
	                } else if (html5PlayerSelf.options.showProgressBar === "bar") {
	                    verbose("removing progress bar");
	                    videojsAPI.controlBar.currentTimeDisplay.hide();
	                    videojsAPI.controlBar.timeDivider.hide();
	                    videojsAPI.controlBar.durationDisplay.hide();
	                }
	            }

	            //set allowFullscreen
	            if (html5PlayerSelf.options.allowFullscreen === false) {
	                verbose("removing fullscreen toggle");
	                videojsAPI.controlBar.fullscreenToggle.addClass('vjs-hidden');
	            }


	        }
	    };
	};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_AdIndicator]";
	var APN_Logger = __webpack_require__(9);
	var verbose = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};

	/**
	 * Render Ad Indicator along with learn more option
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {
	    return {
	        "init": function (videojsAPI, iframeVideoWrapper, adIndicatorTextObj, floatingAdIndicator, learnMore) {

	            verbose("init");

	            adIndicatorTextObj.id = "ad_indicator_text";
	            adIndicatorTextObj.innerHTML = html5PlayerSelf.adIndicatorTextContent;
	            adIndicatorTextObj.className = 'top-bar-text';
	            adIndicatorTextObj.role = 'button';

	            var adTextHitBoxHeight = "3em";

	            if (html5PlayerSelf.isMobile()) {
	                adTextHitBoxHeight = "5em";
	            }

	            adIndicatorTextObj.style['text-align'] = "right";
	            adIndicatorTextObj.style['margin-right'] = "1em";
	            adIndicatorTextObj.style['margin-left'] = "1em";
	            adIndicatorTextObj.style['font-size'] = "1em";
	            adIndicatorTextObj.style['right'] = "0px";
	            adIndicatorTextObj.style['left'] = "";
	            adIndicatorTextObj.style['line-height'] = "24px";
	            adIndicatorTextObj.style['outline'] = "0";
	            adIndicatorTextObj.style['position'] = "absolute";
	            adIndicatorTextObj.style['padding'] = "0";
	            adIndicatorTextObj.style['height'] = "auto";
	            adIndicatorTextObj.style['width'] = "auto";
	            adIndicatorTextObj.style['max-width'] = "35%";
	            adIndicatorTextObj.style['white-space'] = "nowrap";
	            adIndicatorTextObj.style['overflow'] = "hidden";
	            adIndicatorTextObj.style['text-overflow'] = "ellipsis";

	            if (!learnMore) {
	                adIndicatorTextObj.style['pointer-events'] = "none";
	            } else {
	                adIndicatorTextObj.style['cursor'] = "pointer";
	            }

	            floatingAdIndicator.style['text-align'] = "right";
	            floatingAdIndicator.style['margin-right'] = "1em";
	            floatingAdIndicator.style['margin-left'] = "1em";
	            floatingAdIndicator.style['font-size'] = "1em";
	            floatingAdIndicator.style['right'] = "0px";
	            floatingAdIndicator.style['left'] = "";
	            floatingAdIndicator.style['line-height'] = "3em";
	            floatingAdIndicator.style['outline'] = "0";
	            floatingAdIndicator.style['position'] = "absolute";
	            floatingAdIndicator.style['padding'] = "0";
	            floatingAdIndicator.style['height'] = adTextHitBoxHeight;
	            floatingAdIndicator.style['max-width'] = "35%";
	            floatingAdIndicator.style['width'] = "auto";
	            floatingAdIndicator.style['text-overflow'] = "ellipsis";
	            floatingAdIndicator.style['white-space'] = "nowrap";
	            floatingAdIndicator.style['overflow'] = "hidden";
	            floatingAdIndicator.style['display'] = "none";

	            if (!learnMore) {
	                floatingAdIndicator.style['pointer-events'] = "none";
	            } else {
	                floatingAdIndicator.style['cursor'] = "pointer";

	                var learnMoreHandler = function (e) {
	                    playerManager.click();

	                    if (html5PlayerSelf.isMobile()) {
	                        e.stopPropagation();
	                        e.preventDefault(); // prevents a touch event from also triggering a click event
	                    }
	                };

	                adIndicatorTextObj.addEventListener("touchend", learnMoreHandler);
	                floatingAdIndicator.addEventListener("touchend", learnMoreHandler);

	                adIndicatorTextObj.addEventListener("click", learnMoreHandler);
	                floatingAdIndicator.addEventListener("click", learnMoreHandler);
	            }

	            videojsAPI.addChild('button', {
	                'el': floatingAdIndicator
	            });

	        }
	    };
	};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_Skip]";
	var APN_Logger = __webpack_require__(9);
	var Utils = __webpack_require__(8);

	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};


	var verbose = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};

	/**
	 * Skip render and handler
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {

	    return {
	        "init": function (topChrome, floatingAdIndicator, adIndicatorTextObj, videojsAPI, iframeVideoWrapper) {

	            debug("init");

	            var skipButton;
	            var adSkipText;

	            //set skip button
	            if (html5PlayerSelf.options.skippable.enabled === true) {
	                verbose("creating and styling skip buttons and skip texts");

	                var videoThreshold = html5PlayerSelf.options.skippable.videoThreshold;
	                var skipText = html5PlayerSelf.options.skippable.skipText;
	                var skipButtonText = html5PlayerSelf.options.skippable.skipButtonText;

	                skipButton = iframeVideoWrapper.contentWindow.document.createElement("div");
	                skipButton.id = "skip_button";

	                skipButton.innerHTML = skipButtonText;
	                skipButton.className = 'top-bar-text';
	                skipButton.role = 'button';

	                var skipHitBoxHeight = "";
	                if (html5PlayerSelf.isMobile()) {
	                    skipHitBoxHeight = "5.0em";
	                }

	                skipButton.style['display'] = "none";
	                skipButton.style['cursor'] = "pointer";
	                skipButton.style['font-weight'] = "bold";
	                skipButton.style['margin-right'] = "1em";
	                skipButton.style['margin-left'] = "1em";
	                skipButton.style['font-size'] = "1em";
	                skipButton.style['right'] = "";
	                skipButton.style['left'] = "0px";
	                skipButton.style['line-height'] = "24px";
	                skipButton.style['outline'] = "0";
	                skipButton.style['position'] = "absolute";
	                skipButton.style['padding'] = "0";
	                skipButton.style['height'] = skipHitBoxHeight;
	                skipButton.style['width'] = "auto";
	                skipButton.style['min-width'] = "5em";
	                skipButton.style['text-align'] = "left";

	                //skip button
	                html5PlayerSelf.floatingSkipButton = html5PlayerSelf.videojsOrigin.createEl('div', {
	                    'className': 'top-bar-text',
	                    'role': 'button',
	                    'innerHTML': skipButtonText
	                });

	                html5PlayerSelf.floatingSkipButton.style['display'] = "none";
	                html5PlayerSelf.floatingSkipButton.style['cursor'] = "pointer";
	                html5PlayerSelf.floatingSkipButton.style['font-weight'] = "bold";
	                html5PlayerSelf.floatingSkipButton.style['margin-right'] = "1em";
	                html5PlayerSelf.floatingSkipButton.style['margin-left'] = "1em";
	                html5PlayerSelf.floatingSkipButton.style['font-size'] = "1em";
	                html5PlayerSelf.floatingSkipButton.style['right'] = "";
	                html5PlayerSelf.floatingSkipButton.style['left'] = "0px";
	                html5PlayerSelf.floatingSkipButton.style['line-height'] = "3em";
	                html5PlayerSelf.floatingSkipButton.style['outline'] = "0";
	                html5PlayerSelf.floatingSkipButton.style['position'] = "absolute";
	                html5PlayerSelf.floatingSkipButton.style['padding'] = "0";
	                html5PlayerSelf.floatingSkipButton.style['height'] = skipHitBoxHeight;
	                html5PlayerSelf.floatingSkipButton.style['min-width'] = "5em";
	                html5PlayerSelf.floatingSkipButton.style['width'] = "auto";
	                html5PlayerSelf.floatingSkipButton.style['display'] = "none";
	                html5PlayerSelf.floatingSkipButton.style['text-align'] = "left";

	                videojsAPI.addChild('button', {
	                    'el': html5PlayerSelf.floatingSkipButton
	                });

	                var skipHandler = function (e) {
	                    debug("SKIP clicked, destroying player");
	                    // For JS-VPAID Ads trigger skip on Creative and wait for it to respond back with 'AdSkipped to perform action
	                    if (html5PlayerSelf.options.vpaid) {
	                        videojsAPI.trigger('skip');
	                        if (html5PlayerSelf.isMobile()) {
	                            e.stopPropagation();
	                            e.preventDefault(); // prevents a touch event from also triggering a click event
	                            if (html5PlayerSelf.options.overlayPlayer) {
	                                // VIDLA-1437 - make sure main content can autoplay after ad skipped on mobile
	                                playerManager.destroy();
	                            }
	                        }
	                        return;
	                    }
	                    // Must call this *before* setting isCompleted flag for skip tracking events to be sent
	                    playerManager.destroy();

	                    if (html5PlayerSelf.isMobile()) {
	                        e.stopPropagation();
	                        e.preventDefault(); // prevents a touch event from also triggering a click event
	                        playerManager.isCompleted = true;//added for VID-1047
	                    }
	                };

	                if (html5PlayerSelf.isMobile()) {
	                    skipButton.addEventListener("touchend", skipHandler);
	                    html5PlayerSelf.floatingSkipButton.addEventListener("touchend", skipHandler);
	                    html5PlayerSelf.floatingSkipButton.addEventListener("mousedown", function (e) {
	                        e.preventDefault();
	                    });
	                }

	                skipButton.addEventListener("click", skipHandler);
	                html5PlayerSelf.floatingSkipButton.addEventListener("click", skipHandler);

	                //skip text
	                html5PlayerSelf.floatingAdSkipText = html5PlayerSelf.videojsOrigin.createEl('div', {
	                    'className': 'top-bar-text',
	                    'role': 'button',
	                    'innerHTML': ""
	                });

	                html5PlayerSelf.floatingAdSkipText.style['margin-left'] = "1em";
	                html5PlayerSelf.floatingAdSkipText.style['margin-right'] = "1em";
	                html5PlayerSelf.floatingAdSkipText.style['right'] = "";
	                html5PlayerSelf.floatingAdSkipText.style['left'] = "0px";
	                html5PlayerSelf.floatingAdSkipText.style['font-size'] = "1em";
	                html5PlayerSelf.floatingAdSkipText.style['line-height'] = "3em";
	                html5PlayerSelf.floatingAdSkipText.style['outline'] = "0";
	                html5PlayerSelf.floatingAdSkipText.style['position'] = "absolute";
	                html5PlayerSelf.floatingAdSkipText.style['text-align'] = "left";
	                html5PlayerSelf.floatingAdSkipText.style['padding'] = "0";
	                html5PlayerSelf.floatingAdSkipText.style['height'] = "3em";
	                html5PlayerSelf.floatingAdSkipText.style['width'] = "auto";
	                html5PlayerSelf.floatingAdSkipText.style['pointer-events'] = "none";
	                html5PlayerSelf.floatingAdSkipText.style['display'] = "none";

	                videojsAPI.addChild('button', {
	                    'el': html5PlayerSelf.floatingAdSkipText
	                });

	                //skip text
	                adSkipText = iframeVideoWrapper.contentWindow.document.createElement("div");
	                adSkipText.id = "ad_skip_text";

	                adSkipText.innerHTML = skipButtonText;
	                adSkipText.className = 'top-bar-text';
	                adSkipText.role = 'button';

	                adSkipText.style['margin-left'] = "1em";
	                adSkipText.style['margin-right'] = "1em";
	                adSkipText.style['right'] = "";
	                adSkipText.style['left'] = "0px";
	                adSkipText.style['font-size'] = "1em";
	                adSkipText.style['line-height'] = "24px";
	                adSkipText.style['outline'] = "0";
	                adSkipText.style['position'] = "absolute";
	                adSkipText.style['text-align'] = "left";
	                adSkipText.style['padding'] = "0";
	                adSkipText.style['height'] = "3em";
	                adSkipText.style['width'] = "auto";
	                adSkipText.style['pointer-events'] = "none";
	                adSkipText.style['display'] = "none";

	                //switch position by option
	                switch (html5PlayerSelf.options.skippable.skipLocation) {
	                    case "top-right":
	                        skipButton.style['right'] = "0px";
	                        skipButton.style['left'] = "";
	                        skipButton.style['text-align'] = "right";

	                        adSkipText.style['right'] = "0px";
	                        adSkipText.style['left'] = "";

	                        html5PlayerSelf.floatingSkipButton.style['right'] = "0px";
	                        html5PlayerSelf.floatingSkipButton.style['left'] = "";
	                        html5PlayerSelf.floatingSkipButton.style['text-align'] = "right";

	                        html5PlayerSelf.floatingAdSkipText.style['right'] = "0px";
	                        html5PlayerSelf.floatingAdSkipText.style['left'] = "";
	                        break;
	                    default :
	                        break;
	                }

	                //quartile status to invoke only once
	                var quartile1status = false;
	                var quartile2status = false;
	                var quartile3status = false;


	                var _trackedProgressOffsetSorted = {};

	                var renderSkip = function() {
	                    var currentTime = Math.round(videojsAPI.player().currentTime());
	                    var videoDuration = Math.round(videojsAPI.player().duration());
	                    var offsetTime;

	                    if (playerManager.options.skippable.allowOverride) {
	                        offsetTime = Math.round(html5PlayerSelf.options.data.skipOffsetMsec / 1000);//trust vast3 setting
	                    } else {
	                        offsetTime = html5PlayerSelf.options.skippable.videoOffset;//trust console setting
	                    }

	                    var remainTime = offsetTime - currentTime;
	                    var needToShowSkip = (html5PlayerSelf.options.skippable.allowOverride) ? html5PlayerSelf.options.data.isVastVideoSkippable : true;
	                    needToShowSkip = (offsetTime > videoDuration) ? false : needToShowSkip;

	                    // @exclude
	                    playerManager.test("VIDLA163_needToShowSkip", needToShowSkip);
	                    // @endexclude

	                    if (videoThreshold < videoDuration && !html5PlayerSelf.options.disableTopBar && needToShowSkip) {
	                        if (remainTime > 0 && !(playerManager.startedReplay || playerManager.isEnded)) {
	                            html5PlayerSelf.floatingAdSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);
	                            skipButton.style.display = "none";
	                            adSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);
	                            adSkipText.style.display = "block";
	                            if (Utils.elementsOverlap(adSkipText, adIndicatorTextObj)) {
	                                adSkipText.style.display = "none";
	                            }
	                        } else {
	                            // @exclude
	                            if (!html5PlayerSelf.readyForSkip) {
	                                playerManager.test("log", currentTime);
	                                playerManager.test("VIDLA163_skip", currentTime);
	                            }
	                            // @endexclude

	                            html5PlayerSelf.readyForSkip = true;

	                            if (playerManager.isFullscreen && !html5PlayerSelf.pendingFullscreenExit) {
	                                html5PlayerSelf.floatingAdSkipText.style.display = "none";
	                                html5PlayerSelf.floatingSkipButton.style.display = "block";
	                            }

	                            adSkipText.style.display = "none";
	                            skipButton.style.display = "block";
	                        }
	                    }
	                };

	                videojsAPI.on("resize", function () {
	                    renderSkip();
	                });

	                //handle tick event from video.js
	                videojsAPI.on("timeupdate", function () {
	                    var _vastProgressEvent = playerManager.options.data.vastProgressEvent;

	                    if (html5PlayerSelf.options.isWaterfall && html5PlayerSelf.options.vpaid && !html5PlayerSelf.options.vpaidImpressionFired) {
	                        return;
	                    }

	                    var currentTime = Math.round(videojsAPI.player().currentTime());
	                    var _currentTimeMsec = currentTime * 1000;

	                    //handle vast3 progress event
	                    if (_vastProgressEvent && typeof(_vastProgressEvent) === "object") {

	                        var _progressCallback = function () {
	                            // @exclude
	                            playerManager.test("VIDLA163_Tracking", _trackedProgressOffsetSorted);
	                            // @endexclude
	                        };
	                        for (var _eventKey in _vastProgressEvent) {
	                            var _progressMsec = _vastProgressEvent[_eventKey];
	                            if (typeof(_progressMsec) === "number" && _progressMsec >= 0 && _currentTimeMsec >= _progressMsec && Object.keys(_trackedProgressOffsetSorted).indexOf(_eventKey) === -1) {
	                                _trackedProgressOffsetSorted[_eventKey] = _progressMsec;
	                                var obj = {};
	                                obj.name = _eventKey;
	                                if (obj.name) {
	                                    playerManager.dispatchEventToAdunit(obj, _progressCallback);
	                                }
	                            }
	                        }
	                    }

	                    renderSkip();
	                });
	            }

	            //switch position by option
	            if (html5PlayerSelf.options.skippable && html5PlayerSelf.options.skippable.skipLocation) {
	                switch (html5PlayerSelf.options.skippable.skipLocation) {
	                    case "top-right":
	                        adIndicatorTextObj.style['right'] = "";
	                        adIndicatorTextObj.style['left'] = "0px";

	                        floatingAdIndicator.style['right'] = "";
	                        floatingAdIndicator.style['left'] = "0px";
	                        break;
	                    default :
	                        break;
	                }
	            }

	            if (!html5PlayerSelf.options.disableTopBar && topChrome) {
	                if (html5PlayerSelf.options.skippable.enabled === true) {
	                    topChrome.appendChild(skipButton);
	                    topChrome.appendChild(adSkipText);
	                }
	                topChrome.appendChild(adIndicatorTextObj);
	            }

	            //set quartile event
	            videojsAPI.on("timeupdate", function () {
	                if (html5PlayerSelf.options.vpaid) {
	                    return;
	                }
	                var currentTime = Math.round(videojsAPI.player().currentTime());
	                var videoDuration = videojsAPI.player().duration();
	                if (!videoDuration) {
	                    return;
	                }
	                var quartile1 = videoDuration / 4;
	                var quartile2 = videoDuration / 4 * 2;
	                var quartile3 = videoDuration / 4 * 3;


	                if (!quartile1status && currentTime >= quartile1 && currentTime < quartile2) {
	                    html5PlayerSelf.dispatchEventToAdunit({"name": "video-first-quartile"});
	                    quartile1status = true;
	                }

	                if (!quartile2status && currentTime >= quartile2 && currentTime < quartile3) {
	                    html5PlayerSelf.dispatchEventToAdunit({"name": "video-mid"});
	                    quartile2status = true;
	                }

	                if (!quartile3status && currentTime >= quartile3) {
	                    html5PlayerSelf.dispatchEventToAdunit({"name": "video-third-quartile"});
	                    quartile3status = true;
	                }
	            });
	        }
	    };


	};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_EndCardSetup]";
	var APN_Logger = __webpack_require__(9);

	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};

	var endCardHandler = __webpack_require__(19);

	/**
	 * Endcard setup
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {
	    return {
	        "init": function (videojsAPI) {

	            debug("init");

	            if (html5PlayerSelf.options.endCard.enabled) {
	                // Re-check if replay button should show up by default, since this flag can be toggled during waterfall.
	                var ecOpts = html5PlayerSelf.options.endCard;
	                if (ecOpts.showDefaultButtons) {
	                    var replayIndex = -1;
	                    for (var i = 0; i < ecOpts.buttons.length; i++) {
	                        if (ecOpts.buttons[i].type === "replay") {
	                            replayIndex = i;
	                            break;
	                        }
	                    }
	                    if (html5PlayerSelf.options.disableCollapse.replay) {
	                        // Add replay button if it's not already there
	                        if (replayIndex < 0) {
	                            ecOpts.buttons.splice(0, 0, {type: "replay"});
	                        }
	                    } else {
	                        // Remove replay button if it's already there
	                        if (replayIndex >= 0) {
	                            ecOpts.buttons.splice(replayIndex, 1);
	                        }
	                    }
	                }

	                debug("Creating EndCard.");
	                playerManager.endCard = new endCardHandler(ecOpts, videojsAPI, playerManager);
	            }
	        }

	    };
	};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	It will be nice to figure out below jshint message
	jshint results in errors
	  Functions declared within loops referencing an outer scoped variable may lead to confusing semantics. @ line 310 char 40
	            var selectAndRenderCompanion = function(layer) {
	            }
	*/
	/* jshint ignore:start */


	var prefixOfLog = "[EndCard]";

	var APN_CompanionManager = __webpack_require__(20);
	var APN_Logger = __webpack_require__(9);
	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};
	var verbose = function(message) {
	    APN_Logger.verbose(prefixOfLog, message);
	}

	/**
	 * Options for a single layer displayed on the end card screen.
	 * @typedef {Object} EndCardLayerOptions
	 * @property {string} type - A string id indicating the type of content this layer dispays.
	 * @property {string} [width] - The CSS width of the layer, if omitted an appropriate default value will be used.
	 * @property {string} [height] - The CSS height of the layer, if omitted an appropriate default value will be used.
	 * @property {string} [imageUrl] - A full URL to the source to use for an image, this should only be used if type is "image"
	 * @property {string} [color] - A CSS color value indicating what color the layer should be, should only be used if type is "color"
	 */

	/**
	 * Options for a single button displayed on the end card screen.
	 * @typedef {Object} EndCardButtonOptions
	 * @property {string} type - A string id indicating the type of button to display.
	 */

	/**
	 * Options for the EndCard to be displayed after the video completes.
	 * @typedef {Object} EndCardOptions
	 * @property {boolean} enabled - Whether or not the end card screen is enabled, defaults to false, if true then this module will be used.
	 * @property {boolean} clickable - Whether or not the ad area should remain clickable while the end card screen is shown.
	 * @property {EndCardLayerOptions[]} layers - Array of layers to display on the end card screen, if layers are given directly then other top-level options that create a layer will have no effect.
	 * @property {EndCardButtonOptions[]} buttons - Array of buttons to display on the end card screen.
	 * @property {string} color - A CSS color value string, if given then a color layer using this color is shown atop of the video's last frame.
	 * @property {string} imageUrl - The URL of an image to display, if given then an image layer is created on top of the color/video. Images are always centered within the ad unit area for now.
	 * @property {string} imageWidth - Width of the image (CSS width string so can be px, %, etc.)
	 * @property {string} imageHeight - Height of the image (CSS height string so can be px, %, etc.)
	 * @property {boolean} showCompanion - Whether or not to show a companion ad instead of an image (if one is available)
	 */

	 /**
	  * Layer object represents a layer in the end card screen.
	  * @typedef {Object} EndCardLayer
	  * @property {HTMLElement} elem - The main HTMLElement in the DOM for this layer.
	  * @property {EndCardLayerOptions} opts - A reference to the options that this layer was created with.
	  * @property {Object} styleSave - A key/value pair of what CSS styles were on 'elem' to being changed by the saveSetStyle() method, used to easily undo CSS style changes.
	  */


	/**
	 * Constructor for EndCard object used to display a configurable end screen after the video is done.
	 * @param {EndCardOptions} options - Options for the end card screen
	 * @param {Object} vjsPlayer - The VideoJS player object that played the video ad
	 * @param {PlayerManager} playerManager - Main player manager object
	 */
	var EndCard = function (options, vjsPlayer, playerManager) {
		this.layers = [];
	    this.buttons = [];
	    this.options = options;
	    this.vjsPlayer = vjsPlayer;
	    this.playerManager = playerManager;
	    this.firedCreativeView = false;

	    // When clickable clicking any layer on end screen acts like clicking the ad
	    this.onLayerClick = function(e) {
	        e.stopPropagation();

	        //debug("LayerClick (" + e.type + ") for: " + e.currentTarget.id);

	        if (e.target === e.currentTarget) {
	            playerManager.click();
	        }
	    };

	    // Always rebuild layer list from options, otherwise end card from waterfall placements will always be
	    // based on the first ad, even if it fails. (VIDLA-1611)
	    // Also always include all layers now, we used to not create ones that weren't used, to make the DOM more
	    // consistent we'll create them and hide them if they aren't used.
	    options.layers = [
	        {type: "videoAd"}
	    ];

	    options.layers.push({
	        type: "color",
	        width: "100%",
	        height: "100%",
	        color: options.color,
	    });

	    // If ad has companions then create a companion layer
	    options.layers.push({
	        type: "companionAd",
	    });

	    // If a valid companionAd object exists for end card then use that instead of the imageUrl
	    options.layers.push({
	        type: "image",
	        width: options.imageWidth,
	        height: options.imageHeight,
	        imageUrl: options.imageUrl,
	    });

	    // Create the elements for the end card screen upon construction, will be hidden until show() method gets called
	    this.createEndCardContainer(vjsPlayer.player().el_);
	    this.createLayers();
	    this.createButtons();
	};

	/**
	 * Applies styles to an element that makes the element be centered (assuming it's parent div has text-align
	 * style set to center that is, used to center layers on the end card screen).
	 * @param {HTMLElement} elem - The element whose style properties to set.
	 * @param {string} [width] - CSS width value of the desired layer width (set as maxWidth, defaults to 100% if falsey)
	 * @param {string} [height] - CSS height value of the desired layer height (set as maxHeight, defaults to 100% if falsey)
	 */
	EndCard.prototype.styleForCentering = function(elem, width, height) {
	    elem.style.display = "block";
	    elem.style.position = "absolute";
	    elem.style.top = 0;
	    elem.style.bottom = 0;
	    elem.style.left = 0;
	    elem.style.right = 0;
	    elem.style.margin = "auto";
	    elem.style.maxWidth = width || "100%";
	    elem.style.maxHeight = height || "100%";
	    if (width) {
	        elem.style.width = width;
	    }
	    if (height) {
	        elem.style.height = height;
	    }
	};

	/**
	 * Setup styles such that the given layer scales down, preserving the aspect ratio of it's original size, when the
	 * ad unit is too small to display it at the original size. This is done by converting the rendered size into a
	 * percentage value for width and height.
	 * @param {EndCardLayer} layer - The layer to set up downscaling for.
	 * @param {number} [adWidth] - Width of the ad area the given layer is in (defaults to endCardElem.offsetWidth)
	 * @param {number} [adHeight] - Height of the ad area the given layer is in (defaults to endCardElem.offsetHeight)
	 */
	EndCard.prototype.styleSizeLimitScaleDown = function(layer, adWidth, adHeight) {
	    var self = this;
	    var elem = layer.elem;

	    var sizeToPercentage = function() {
	        adWidth = adWidth || self.endCardElem.offsetWidth;
	        adHeight = adHeight || self.endCardElem.offsetHeight;
	        var elemWidth = elem.offsetWidth;
	        var elemHeight = elem.offsetHeight;

	        // If elements don't have a size yet then wait a little bit, unfortunately there doesn't seem to be a good way
	        // to be notified when an element has been rendered, so just use a small timeout instead.
	        if (!adWidth || !adHeight || !elemWidth || !elemHeight) {
	            setTimeout(sizeToPercentage, 5);
	            return;
	        }

	        // Confused about the math used here? Check the "End Card" page on wiki for an explanation.
	        var adAspect = (adWidth / adHeight);
	        var elemAspect = (elemWidth / elemHeight);
	        var perc;

	        if (adAspect < elemAspect) {
	            // Ad width will reach element width first, so compute height based on 100% width
	            elem.style.width = "100%";
	            var adHeightAtFullWidth = adHeight * (elemWidth / adWidth);
	            perc = elemHeight / adHeightAtFullWidth;
	            elem.style.height = "" + (100 * perc) + "%";
	        } else {
	            // Ad height will reach element height first, so compute width based on 100% height
	            elem.style.height = "100%";
	            var adWidthAtFullHeight = adWidth * (elemHeight / adHeight);
	            perc = elemWidth / adWidthAtFullHeight;
	            elem.style.width = "" + (100 * perc) + "%";
	        }

	        // If the layer does not define a width/height then limit max size to the element's natural size.
	        // (prevents stretching up if imageUrl is given but imageWidth/imageHeight are not) (VIDLA-1617)
	        if (!layer.opts.width) {
	            elem.style.maxWidth = elem.naturalWidth;
	        }
	        if (!layer.opts.height) {
	            elem.style.maxHeight = elem.naturalHeight;
	        }
	    };

	    sizeToPercentage();
	};

	/**
	 * Finds the best companion ad to display on end card. The "best" is defined as the companion ad of a supported
	 * resource type with the closest aspect ratio to that of the video that fits within the end card's area.
	 * @returns {Object} - Returns the chosen companion ad's info (as returned by our VAST parser), or undefined if no adequate companion ad was found.
	 */
	EndCard.prototype.selectEndCardCompanion = function() {
	    // Do nothing if there are no companions to choose from
	    if (!Array.isArray(this.options.companionAds) || this.options.companionAds.length === 0) {
	        debug("No companion ads found.");
	        return;
	    }

	    var container = this.vjsPlayer.player().el_;

	    // Ad unit info (our target size is the size of the end card container element)
	    var adWidth = this.playerManager.options.width;
	    var adHeight = this.playerManager.options.height;

	    if (container) {
	        if (container.offsetWidth) {
	            adWidth = container.offsetWidth;
	        }
	        if (container.offsetHeight) {
	            adHeight = container.offsetHeight;
	        }
	    }

	    var adArea = (adWidth * adHeight);

	    debug("Selecting best companion for ad unit size (" + adWidth + "x" + adHeight + "):");

	    var bestComp, bestArea, scale;
	    var comp, compArea, compW, compH, compType;

	    // If multiple companions find the best fit (primarily by aspect ratio, secondarily by area).
	    // Start with very large difference values so the first valid companion will be a better fit.
	    bestArea = 99999999;

	    for(var i = 0; i < this.options.companionAds.length; i++) {
	        comp = this.options.companionAds[i];
	        compW = comp.width || 1;
	        compH = comp.height || 1;

	        // Only allow companion ads that show an image to be used in end card for now.
	        if (comp.hasOwnProperty("StaticResource") && comp.StaticResource.type.indexOf('image') === 0) {
	            compType = "StaticImageCompanion";
	        } else if (comp.hasOwnProperty("HTMLResource")) {
	            compType = "HtmlCompanion";
	        } else {
	            debug("xxx Skipping Companion: [" + i + "] - Resource type is neither a static image nor HTML.");
	            continue;
	        }

	        if (compType === "StaticImageCompanion") {
	            // StaticResource can scale down so it's ok if it's larger than the ad unit, but to measure it properly against others
	            // we need to adjust it's size to what it will be when scaled down to fit in the current ad area.
	            if (compW > adWidth) {
	                scale = adWidth / compW;
	                compW *= scale;
	                compH *= scale;
	            }
	            if (compH > adHeight) {
	                scale = adHeight / compH;
	                compW *= scale;
	                compH *= scale;
	            }
	        } else if ((compW > adWidth) || (compH > adHeight)) {
	            // Other resource types cannot scale down so companion must be <= ad unit otherwise we reject it
	            debug("xxx Skipping Companion: [" + i + "] - Companion size (" + compW + "x" + compH + ") won't fit in ad unit.");
	            continue;
	        }

	        // Get difference between companion and ad in both aspect ratio and area
	        compArea = Math.abs((compW * compH) - adArea);

	        if (compArea < bestArea) {
	            bestArea = compArea;
	            bestComp = comp;
	            this.CompanionAdType = compType;
	            debug("*** Selecting Companion: [" + i + "] size (" + compW + "x" + compH + "), areaDiff=" + bestArea);
	        } else {
	            debug("xxx Discarding Companion: [" + i + "] size (" + compW + "x" + compH + "), areaDiff=" + compArea);
	        }
	    }

	    return bestComp;
	};

	/**
	 * Prepares companion layers by rendering the best fitting companion ad into the layer's div.
	 * @returns {number} - Returns the number of companion ad layers being shown, zero if none.
	 */
	EndCard.prototype.prepareCompanionLayers = function(callback) {
	    var self = this;
	    var numCompanionsShown = 0;         // how many companion layers have been rendered and will be visible in the end card container
	    var numCompanionsRemaining = 1;     // how many companion layers are left to process (for loop holds one count on this so callback gets called even if no companion layers)

	    // Custom companion callback so creative-view only fires once (shouldn't fire again after a replay) (VIDLA-1585)
	    var endCardCompanionCallback = function(obj) {
	        if (obj.command === 'requestTracking' && obj.data === 'creative-view') {
	            if (self.firedCreativeView) {
	                return;
	            }
	            self.firedCreativeView = true;
	        }

	        if (self.options.companionCallback) {
	            self.options.companionCallback(obj);
	        }
	    };

	    for (var i = 0; i < this.layers.length; i++) {
	        var layer = this.layers[i];

	        if ((layer.opts.type !== 'companionAd') || layer.companionManager) {
	            continue;
	        }

	        var selectAndRenderCompanion = function(layer) {
	            // Wait until we are out of fullscreen/sidestream mode (end card should never be in these modes but sometimes we
	            // were picking the not best fitting companion here due to using the wrong ad size) (in fullscreen mode it was
	            // definitely a problem, we're just adding sidestream mode here as well just to be safe)
	            if (self.playerManager.isFullscreen || (self.playerManager.options.sideStreamObject && self.playerManager.options.sideStreamObject.isActivated)) {
	                verbose("Delaying companion selection since we are in " + ((self.playerManager.isFullscreen) ? "fullscreen" : "sidestream") + " mode.");
	                setTimeout(selectAndRenderCompanion, 100, layer);
	                return;
	            }

	            layer.companionAd = self.selectEndCardCompanion();

	            if (!layer.companionAd) {
	                // Hide companion layer if no suitable companion ad was found
	                layer.elem.style.display = "none";
	            } else {
	                // Render the end card companion ad in this layer's element
	                var opts = {
	                    companionContainers: [layer.elem],
	                };
	                var companionAds = {
	                    companions: [layer.companionAd],
	                };

	                // Set matching size so companion ad gets choosen by rendition manager (consider flag to not require exact match in companion ad handler instead?)
	                layer.elem.style.width = layer.opts.width = layer.companionAd.width;
	                layer.elem.style.height = layer.opts.height = layer.companionAd.height;
	                layer.elem.style.maxWidth = "";
	                layer.elem.style.maxHeight = "";

	                // FireFox doesn't seem to apply element style settings right away so wait a bit before rendering companion
	                // since the size won't match if we do it right away causing companion renderer to reject it.
	                setTimeout(function() {
	                    layer.companionManager = APN_CompanionManager.renderCompanions(companionAds, opts, endCardCompanionCallback);

	                    self.styleForCentering(layer.elem, layer.companionAd.width, layer.companionAd.height);

	                    if (self.CompanionAdType === "StaticImageCompanion") {
	                        // Force image to fill companion container so it scales with it
	                        var img = layer.elem.childNodes.item(0);
	                        if (img) {
	                            img.style.width = "100%";
	                            img.style.height = "100%";
	                        }

	                        self.styleSizeLimitScaleDown(layer);
	                    }

	                    // Disable pointer events on companion container only if it's a static companion without a click through URL.
	                    // In this case since the companion doesn't have it's own click through this allows clicks to be passed to
	                    // the layer behind it which will open the ad's landing page.
	                    if (layer.companionAd.hasOwnProperty("StaticResource") && (!layer.companionAd.CompanionClickThrough)) {
	                        layer.elem.style["pointer-events"] = "none";
	                        layer.elem.style.cursor = (self.options.clickable) ? "pointer" : "default";

	                        // Companion ad renderer just assumes images are clickable, regardless of presence of a click through URL, and
	                        // sets the img tag to use a pointer cursor, so we need to undo that in the event that it's not clickable.
	                        if ((self.CompanionAdType === "StaticImageCompanion") && !self.options.clickable) {
	                            layer.elem.childNodes.item(0).style.cursor = "default";
	                        }
	                    }
	                }, 50);

	                numCompanionsShown++;
	            }

	            if (--numCompanionsRemaining === 0) {
	                if (callback) {
	                    callback(numCompanionsShown);
	                }
	            }
	        }

	        numCompanionsRemaining++;
	        selectAndRenderCompanion(layer);
	    }

	    if(--numCompanionsRemaining === 0) {
	        if (callback) {
	            callback(numCompanionsShown);
	        }
	    }
	};

	/**
	 * Called when the ad unit is resized while end card is visible so we can hide companion ads that would otherwise get cropped.
	 */
	EndCard.prototype.onVideoResized = function(adWidth, adHeight) {
	    // Hide non-image companion ads when they are too small to fit in the ad area
	    for (var i = 0; i < this.layers.length; i++) {
	        var layer = this.layers[i];

	        if (layer.companionAd) {
	            if (this.CompanionAdType !== "StaticImageCompanion") {
	                if ((layer.companionAd.width > adWidth) || (layer.companionAd.height > adHeight)) {
	                    layer.elem.style.display = "none";
	                } else {
	                    layer.elem.style.display = "block";
	                }
	            } else {
	                // In case of side stream we might need to redo the scale if hard-coding sidestream to a size with different aspect ratio
	                //this.styleSizeLimitScaleDown(layer, adWidth, adHeight);
	            }
	        } else if (layer.type === "image" && layer.elem.style === 'block') {
	            //this.styleSizeLimitScaleDown(layer, adWidth, adHeight);
	        }
	    }
	};

	/**
	 * Changes a style on the given layer's element but saves the original value so it can be restored.
	 * @param {Layer} layer - The layer object whose element the style setting should be applied to.
	 * @param {string} property - The property name of the style to set
	 * @param {string} value - The value to set the style property to
	 */
	EndCard.prototype.saveSetStyle = function(layer, property, value) {
	    // Don't do anything if no value (so we don't have to if check before each call)
	    if (value === undefined) {
	        return;
	    }

	    if (!layer.styleSave) {
	        layer.styleSave = {};
	    }

	    if (layer.elem) {
	        // Check for undefined so if this gets called multiple times for the same property only
	        // the original value (before the first time it was changed) will be saved.
	        if (layer.styleSave[property] === undefined) {
	            layer.styleSave[property] = layer.elem.style[property];
	        }

	        layer.elem.style[property] = value;
	    }
	};

	/**
	 * Restores all CSS styles of the given layer's element to their original values (those that were changed by the saveSetStyle function)
	 * @param {EndCardLayer} layer - The layer whose element's style should be restored.
	 */
	EndCard.prototype.restoreStyle = function(layer) {
	    if (!layer.styleSave) {
	        return;
	    }

	    if (layer.elem) {
	        for(var prop in layer.styleSave) {
	            layer.elem.style[prop] = layer.styleSave[prop];
	        }
	    }

	    // Clear out the saved values
	    delete layer.styleSave;
	};

	/**
	 * Creates a div for containing all elements of the end card screen.
	 * The container is stored in "endCardElem" field.
	 */
	EndCard.prototype.createEndCardContainer = function(targetElement) {
	    if (!this.endCardElem) {
	        this.endCardElem = targetElement.ownerDocument.createElement("div");
	        targetElement.appendChild(this.endCardElem);

	        // Give the container all of the VideoJS classes in case we want to take it out of the video player div (won't hurt if it's in it)
	        this.endCardElem.className = "video-js vjs-default-skin vjs-controls-enabled vjs-big-play-centered vjs-has-started vjs-paused vjs-ended vjs-user-active";

	        if (this.playerManager.isIosInlineRequired()) {
	            // EndCard contaier on iOS is opaque black. This makes it black behind top bar after hiding it, and is ok since on iOS we
	            // need to move the video canvas into the end card container anyway so there's no need for it to be transparent.

	            //fix VIDLA-2180
	            this.endCardElem.style["background-color"] = "";
	            this.endCardElem.style["background"] = this.playerManager.options.playerSkin.videoBackgroundColor;
	            this.endCardElem.style["opacity"] = 1;

	        } else {
	            this.endCardElem.style["background-color"] = "rgba(0,0,0,0)";
	        }

		    this.endCardElem.setAttribute("name", "endCardContainer");
	        this.endCardElem.style.width = "100%";
	        this.endCardElem.style.height = "100%";
	        this.endCardElem.style.display = "none";
	        this.endCardElem.style.cursor = (this.options.clickable) ? "pointer" : "default";
	        this.endCardElem.style.position = "relative";
	        this.endCardElem.style["text-align"] = "center";

	        if (this.options.clickable) {
	            this.endCardElem.onclick = this.onLayerClick;
	        }
	    }
	};

	/**
	 * Creates a new layer that display an image.
	 * @param {Element} targetElement - The element in the DOM to add the new layer to.
	 * @param {EndCardLayerOptions} layerOptions - The options for the layer to create.
	 */
	EndCard.prototype.createImageLayer = function(targetElement, layerOptions) {
	    var layerObj = {};

		var layerElem = targetElement.ownerDocument.createElement("img");
	    targetElement.appendChild(layerElem);

		layerElem.setAttribute("name", "ecImageLayer");
	    layerElem.id = layerOptions.id || "endCardImageLayer";

	    layerElem.setAttribute("src", layerOptions.imageUrl || "");

	    layerElem.style.cursor = (this.options.clickable) ? "pointer" : "default";

	    // Waiting until shown to call styleSizeLimitScaleDown on images since we can't do the necessary
	    // computations until the size (in pixels) is known (aka when browser first renderes the image)
	    this.styleForCentering(layerElem, layerOptions.width, layerOptions.height);

	    // Hidden by default
	    layerElem.style.display = "none";

	    layerObj.elem = layerElem;
	    layerObj.opts = layerOptions;

	    this.layers.push(layerObj);
	};

	/**
	 * Creates a new layer that displays as a solid color and adds it to the layers array.
	 * @param {Element} targetElement - The element in the DOM to add the new layer to.
	 * @param {EndCardLayerOptions} layerOptions - The options for the layer to create.
	 */
	EndCard.prototype.createColorLayer = function(targetElement, layerOptions) {
		var layerObj = {};

		var layerElem = targetElement.ownerDocument.createElement("div");
		targetElement.appendChild(layerElem);

		layerElem.setAttribute("name", "ecColorLayer");
		layerElem.id = layerOptions.id || "endCardColorLayer";
	    layerElem.style["background-color"] = layerOptions.color || "black";
	    layerElem.style.cursor = (this.options.clickable) ? "pointer" : "default";

	    this.styleForCentering(layerElem, layerOptions.width || "100%", layerOptions.height || "100%");

	    // Hide this layer if no color was given
	    if (!layerOptions.color) {
	        layerElem.style.display = "none";
	    }

	    layerObj.elem = layerElem;
	    layerObj.opts = layerOptions;

	    this.layers.push(layerObj);
	};

	/**
	 * Creates a layer that contains the ad video (ad video element given as a parameter)
	 * @param {Element} videoElement - The element in the DOM for the video to display
	 * @param {EndCardLayerOptions} layerOptions - The options for the layer to create.
	 */
	EndCard.prototype.createAdVideoLayer = function(videoElement, layerOptions) {
	    if (this.videoLayer === undefined) {
	        var layerObj = {};

	        layerObj.elem = videoElement;
	        layerObj.opts = layerOptions;

	        if (videoElement) {
	            // Disabling this for desktop (VIDLA-1739), not setting videoParent will prevent video from being moved
	            // into end card container (which is only necessary on iOS when using canvas).
	            if (this.playerManager.isIosInlineRequired()) {
	                layerObj.videoParent = videoElement.parentElement;
	                layerObj.videoSibling = videoElement.nextSibling;
	            }
	        }

	        this.videoLayer = this.layers.length;   // index of the video layer

	        this.layers.push(layerObj);
	    } else {
	        debug("Can't create new video layer because one already exists!");
	    }
	};

	/**
	 * Creates a new layer that is a container for a companion ad.
	 * @param {HTMLElement} targetElement - The element in the DOM to add the new layer to.
	 * @param {EndCardLayerOptions} layerOptions - The options for the layer to create.
	 */
	EndCard.prototype.createCompanionLayer = function(targetElement, layerOptions) {
		var layerObj = {};

		var layerElem = targetElement.ownerDocument.createElement("div");
		targetElement.appendChild(layerElem);

		layerElem.setAttribute("name", "ecCompanionLayer");
		layerElem.id = "endCardCompanionLayer";
		layerElem.style.position = "absolute";
		layerElem.style.width = layerOptions.width || "100%";
		layerElem.style.height = layerOptions.height || "100%";

	    this.styleForCentering(layerElem);

	    // Make container div invisible so doesn't obscure layers behind it
	    layerElem.style["background-color"] = "rgba(0,0,0,0)";

	    layerObj.elem = layerElem;
	    layerObj.opts = layerOptions;

	    this.layers.push(layerObj);
	};

	/**
	 * Makes the end card visible.
	 */
	EndCard.prototype.show = function() {
	    // Hide control bar while end card is shown
	    if (this.vjsPlayer) {
	        if (this.vjsPlayer.controlBar) {
	            this.vjsPlayer.controlBar.hide();
	        }
	    }

	    // Move the video element into the end screen if we're showing it
	    if (this.videoLayer !== undefined) {
	        var vlayer = this.layers[this.videoLayer];
	        var layerOpts = this.options.layers[this.videoLayer];

	        if (vlayer.elem) {
	            if (vlayer.videoParent) {
	                if (this.videoLayer < (this.layers.length-1)) {
	                    // Add video in before the layer that comes after it
	                    this.endCardElem.insertBefore(vlayer.elem, this.layers[this.videoLayer+1].elem);
	                } else if (this.buttonContainer) {
	                    // If video layer is last on the layer list then add it before the button container
	                    this.endCardElem.insertBefore(vlayer.elem, this.buttonContainer);
	                } else {
	                    // If video layer is last and no buttons are visible then just append it as the last element
	                    this.endCardElem.appendChild(vlayer.elem);
	                }
	            }

	            // On iOS inline player video element size doesn't match ad unit size, end screen needs to be based
	            // on video size (so that control bar doesn't cover it up)
	            if (this.playerManager.isIosInlineRequired()) {
	                this.endCardElem.style.width = vlayer.elem.style.width;
	                this.endCardElem.style.height = vlayer.elem.style.height;
	            }
	        }

	        vlayer.styleSave = {};

	        // Size the video based on the layer (if explicit sizes are given)
	        if (layerOpts.width) {
	            this.saveSetStyle(vlayer, "width", layerOpts.width);
	        }
	        if (layerOpts.height) {
	            this.saveSetStyle(vlayer, "height", layerOpts.height);
	        }

	        // disable pointer/touch reactions on video while it's in the end screen
	        if (this.options.clickable) {
	            this.saveSetStyle(vlayer, "cursor", "pointer");
	            this.saveSetStyle(vlayer, "pointer-events", "auto");

	            // If learn-more is enabled in player then the default click handler won't click thru, so use onLayerClick in this case (VIDLA-1533)
	            if (this.playerManager.options.learnMore.enabled) {
	                vlayer.elem.addEventListener("click", this.onLayerClick);
	            }
	        } else {
	            this.saveSetStyle(vlayer, "cursor", "default");
	            this.saveSetStyle(vlayer, "pointer-events", "none");
	        }

	        // When EndCard is inside video player div we needed to resize it to the canvas size here to make it the right size.
	        // Now that EndCard is outside video player div we need to offset the top of the canvas to accomodate for the top-bar.
	        if (this.playerManager.isIosInlineRequired()) {
	            this.endCardElem.style.width = vlayer.elem.style.width;
	            this.endCardElem.style.height = vlayer.elem.style.height;
	        }
	    }

	    var self = this;

	    this.prepareCompanionLayers(function(companionsShown) {
	        for (var i = 0; i < self.layers.length; i++) {
	            var layer = self.layers[i];

	            // video and companion layers have specialized logic for clickability so don't set it up here
	            if ((layer.opts.type === 'videoAd') || (layer.opts.type === 'companionAd')) {
	                continue;
	            }

	            if (layer.opts.type === 'image') {
	                // Show the image only if a companion ad wasn't shown
	                if (companionsShown > 0) {
	                    layer.elem.style.display = "none";
	                } else if (layer.opts.imageUrl) {
	                    self.styleSizeLimitScaleDown(layer);
	                    layer.elem.style.display = "block";
	                }
	            }

	            if (self.options.clickable && layer.elem) {
	                layer.elem.addEventListener("click", self.onLayerClick);
	                layer.elem.style.cursor = "pointer";
	            }
	        }
	    });

	    this.endCardElem.style.display = "block";
	};

	/**
	 * Hides the end card screen, basically undo everything that the show method does.
	 */
	EndCard.prototype.hide = function() {
	    // If video was used in end screen restore it's CSS styles and put it back where it was
	    if (this.videoLayer !== undefined) {
	        var vlayer = this.layers[this.videoLayer];
	        this.restoreStyle(vlayer);
	        if (vlayer.videoParent) {
	            vlayer.videoParent.insertBefore(vlayer.elem, vlayer.videoSibling);
	        }
	    }

	    for(var i = 0; i < this.layers.length; i++) {
	        var layer = this.layers[i];

	        if (layer.opts.type === 'videoAd') {
	            // If learn-more is enabled in player and we're clickable we need to remove our onLayerClick listener from video
	            if (!(this.options.clickable && this.playerManager.options.learnMore.enabled)) {
	                continue;
	            }
	        }

	        if (layer.opts.type === 'companionAd') {
	            if (layer.companionManager) {
	                APN_CompanionManager.stopCompanions(layer.companionManager);
	                delete layer.companionManager;
	            }
	            continue;
	        }

	        if (this.options.clickable && layer.elem) {
	            layer.elem.removeEventListener("click", this.onLayerClick);
	        }
	    }

	    if (this.vjsPlayer && this.vjsPlayer.controlBar) {
	        this.vjsPlayer.controlBar.show();
	    }

	    this.endCardElem.style.display = "none";
	};

	/**
	 * Create and initialize each of the layer elements based on their options.
	 */
	EndCard.prototype.createLayers = function() {
	    var layers = this.options.layers;

	    if (!Array.isArray(layers) || layers.length < 0) {
	        return;
	    }

	    for(var i = 0; i < layers.length; i++) {
	        var layer = layers[i];
	        var type = layer.type || "color";

	        switch(type) {
	            case "color":
	                this.createColorLayer(this.endCardElem, layer);
	                break;
	            case "image":
	                this.createImageLayer(this.endCardElem, layer);
	                break;
	            case "videoAd":
	                // Move video element from the VideoJS player into the end screen
	                if (this.playerManager.isIosInlineRequired()) {
	                    debug("iOS inline player using canvas in place of video element");
	                    var canvases = this.endCardElem.ownerDocument.getElementsByTagName("canvas");
	                    this.createAdVideoLayer(canvases[0], layer);
	                } else if (this.vjsPlayer && this.vjsPlayer.tag) {
	                    this.createAdVideoLayer(this.vjsPlayer.tag, layer);
	                }
	                break;
	            case "companionAd":
	                if (this.options.companionAds) {
	                    this.createCompanionLayer(this.endCardElem, layer);
	                } else {
	                    debug("Companion ad layer specified but no companion ads were found.");
	                }
	                break;
	            default:
	                debug("Invalid endCard layer type: " + type);
	                break;
	        }
	    }
	};

	/**
	 * Creates container div for the button.
	 */
	EndCard.prototype.createButtonContainer = function() {
	    if (!this.buttonContainer) {
	        this.buttonContainer = this.endCardElem.ownerDocument.createElement("div");
	        this.endCardElem.appendChild(this.buttonContainer);

	        // block layout and centered
	        this.buttonContainer.setAttribute("name", "ecButtonContainer");
	        this.buttonContainer.id = "endCardButtonContainer";

	        this.buttonContainer.style.cursor = "default";
	        this.buttonContainer.style["background-color"] = "rgba(0,0,0,0.5)";

	        // center via translation (since we want button container to size to it's content)
	        this.buttonContainer.style.display = "block";
	        this.buttonContainer.style.position = "absolute";
	        this.buttonContainer.style.left = "50%";
	        this.buttonContainer.style.top = "50%";
	        this.buttonContainer.style.transform = "translate(-50%, -50%)";

	        this.buttonContainer.style["font-size"] = "14px";
	        this.buttonContainer.style["text-align"] = "left";
	    }
	};

	/**
	 * Adds a button to the container.
	 * @param {string} iconClass - The CSS class name used to display the icon
	 * @param {string} text - The text to display next to the icon for this button
	 * @param {string} type - Type of button being added
	 * @param {function} onClick - The function to execute when the user clicks this button
	 */
	EndCard.prototype.addButton = function(iconClass, text, type, onClick) {
	    var buttonDiv = this.buttonContainer.ownerDocument.createElement("div");
	    var buttonIcon = this.buttonContainer.ownerDocument.createElement("span");
	    var buttonText = this.buttonContainer.ownerDocument.createElement("span");

	    buttonDiv.className = "ec-button " + iconClass;
	    buttonDiv.id = "ec-button-" + type;

	    if (onClick) {
	        buttonDiv.addEventListener("click", onClick);
	    }

	    buttonIcon.textContent = "";

	    buttonText.textContent = text;
	    buttonText.style["margin-left"] = "6px";

	    buttonDiv.appendChild(buttonIcon);
	    buttonDiv.appendChild(buttonText);

	    this.buttonContainer.appendChild(buttonDiv);
	};

	/**
	 * createButtons: Creates all buttons (if any)
	 */
	EndCard.prototype.createButtons = function() {
	    var buttons = this.options.buttons;

	    // NOTE: Default behavior of adding replay and learnMore when enabled should occur by the caller, not here.
	    if (!Array.isArray(buttons) || buttons.length < 1) {
	        return;
	    }

	    var self = this;

	    var onReplayClicked = function(e) {
	        e.stopPropagation();

	        self.hide();
	        self.vjsPlayer.currentTime(0);
	        self.vjsPlayer.trigger("revealControls");
	        self.playerManager.replay();
	    };

	    var onLearnMoreClicked = function(e) {
	        e.stopPropagation();

	        // Learn more button behaves as a click on the ad (opening the click through url)
	        self.playerManager.click();
	    };

	    // Buttons have a container div that sizes to them
	    this.createButtonContainer();

	    for(var i = 0; i < buttons.length; i++) {
	        var button = buttons[i];
	        var type = button.type;

	        switch(type) {
	            case "replay":
	                this.addButton("vjs-big-play-button-replay", button.text || "Replay", type, onReplayClicked);
	                break;
	            case "learnMore":
	                this.addButton("vjs-ec-button-learnmore", button.text || "Learn More", type, onLearnMoreClicked);
	                break;
	            default:
	                debug("Invalid endCard button type: " + type);
	                break;
	        }
	    }
	};


	module.exports = EndCard;


	/* jshint ignore:end */

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var APN_RenditionManager = __webpack_require__(21);
	var APN_Logger = __webpack_require__(9);
	var _prefix = "CompanionsHandler > ";

	var CompanionHandler = function(containerElement, width, height, companionData, notifCallback) {
		var _containerElement = containerElement;
		var _companionData = companionData;
		var _notificationCallback = notifCallback;
		var _containerSize = {width: width, height: height};
		
		var _uniqueId = new Date().getTime() + Math.floor(Math.random() * 10000);
		
		// register companion trackings
		_notificationCallback({command: 'addTrackingEvents', uniqueId: _uniqueId, data: _companionData});

		var onClick = function() {
			if (_companionData.CompanionClickTracking) {
				_notificationCallback({command: 'requestTracking', uniqueId: _uniqueId, data: 'companion-click'});
			}
			if (_companionData.hasOwnProperty('StaticResource') && _companionData.CompanionClickThrough) {
				window.open(_companionData.CompanionClickThrough);
			}
		};
		
		var onLoad = function() {
			if (_companionData.TrackingEvents && _companionData.TrackingEvents.length > 0) {
				_notificationCallback({command: 'requestTracking', uniqueId: _uniqueId, data: 'creative-view'});
			}
		};
		
		var _needClickHandler = true;
		if (_companionData.hasOwnProperty('StaticResource')) {
			var type = _companionData.StaticResource.type;
			if (type === 'application/x-javascript') {
				var script = document.createElement('script');
				script.src = _companionData.StaticResource.src;
				script.onload = onLoad();
				_containerElement.appendChild(script);
			}
			else if (type === 'application/x-shockwave-flash') {
			    var flashObj = document.createElement("object");
			    flashObj.type = 'application/x-shockwave-flash';
			    flashObj.data = _companionData.StaticResource.src;
			    flashObj.width = _containerSize.width;
			    flashObj.height = _containerSize.height;
			    flashObj.style.top = '0';
			    flashObj.style.left = '0';
			    flashObj.style.width = _containerSize.width + "px";
			    flashObj.style.height = _containerSize.height + "px";
			    
			    var par1 = document.createElement('param');
			    par1.name = 'allowNetworking';
			    par1.value = 'all';
			    flashObj.appendChild(par1);
			    var par2 = document.createElement('param');
			    par2.name = 'wmode';
			    par2.value = 'opaque';
			    flashObj.appendChild(par2);
			    flashObj.onload = onLoad();
				_needClickHandler = false;
				_containerElement.appendChild(flashObj);
			}
			else if (type.indexOf('image') === 0) {
				// image
				var img = document.createElement('img');
				img.src = _companionData.StaticResource.src;
				img.style.maxWidth = '100%';
				img.style.maxHeight = '100%';
				img.style.width = 'auto';
				img.style.height = 'auto';
				img.style.margin = 'auto';
				img.style.display = 'block';
				img.style.top = 0;
				img.style.bottom = 0;
				img.style.left = 0;
				img.style.right = 0;
				img.style.position = 'absolute';
				img.onload = onLoad();
				img.onclick = onClick;
				_needClickHandler = false;
				img.style.cursor = 'pointer';
				_containerElement.style.display = 'inline-block';
				_containerElement.style.position = 'relative';
				_containerElement.appendChild(img);
			}
		}
		else if (_companionData.hasOwnProperty('IFrameResource')) {
			var iframe = document.createElement('iframe');
			iframe.src = _companionData.IFrameResource;
			iframe.scrolling = 'no';
			iframe.style.width = '100%';
			iframe.style.height = '100%';
			iframe.style.border = 'none';
			iframe.style.overflow = 'hidden';
			iframe.onload = onLoad();
			_needClickHandler = false;
			_containerElement.appendChild(iframe);
		}
		else if (_companionData.hasOwnProperty('HTMLResource')) {
			if (_companionData.HTMLResource.indexOf('http') === 0) {
			    var UrlLoader = __webpack_require__(24);
			    UrlLoader.load(_companionData.HTMLResource,
			        function(error, responseText) {
			    		if (error || responseText.length === 0) {
			    			// _notificationCallback
		 	    		}
			    		else {
			    			_containerElement.style.display = 'inline-block';
			    			_containerElement.style.position = 'relative';
			    			_containerElement.innerHTML = responseText;
			    			onLoad();
			    		}
			        });
			}
			else {
				_containerElement.style.display = 'inline-block';
				_containerElement.style.position = 'relative';
				_containerElement.innerHTML = _companionData.HTMLResource;
				onLoad();
			}
		}
		if (_needClickHandler) {
			if (_companionData.hasOwnProperty('StaticResource') && _companionData.CompanionClickThrough) {
				_containerElement.style.cursor = 'pointer';
			}
			_containerElement.onclick = onClick;
		}
			
		this.stop = function() {
			_containerElement.innerHTML = '';
		};
	};

	var CompanionsHandler = function(companionAds, options, notifCallback) {
		var _companionAds = companionAds;
		var _options = options;
		var _notificationCallback = notifCallback;
		
		var _companions = [];
		
		APN_Logger.always(_prefix, 'Version: 0.1.7');
		
		var containersData = [];
		for (var i = 0; i < _options.companionContainers.length; i++) {
			try {
				var styles = window.getComputedStyle(_options.companionContainers[i], null);
				var obj = {id:i, width: parseInt(styles.width), height: parseInt(styles.height), companion: null};
				containersData.push(obj);
			}
			catch(ex) {}
		}
		APN_RenditionManager.selectCompanionsForContainers(_companionAds, containersData);
		for (i = 0; i < containersData.length; i++) {
			if (containersData[i].companion) {
				var companion = new CompanionHandler(_options.companionContainers[i], containersData[i].width, containersData[i].height, 
						containersData[i].companion, _notificationCallback);
				_companions.push(companion);
			}
		}
		
		this.stop = function() {
			for (i = 0; i < _companions.length; i++) {
				_companions[i].stop();
			}
			_companions.length = 0;
		};
	};

	var trimXml = function(strVastXml) {
		var nPos = strVastXml.indexOf('<');
		var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
		nPos = strXml.lastIndexOf('>');
		if (nPos !== -1) {
			strXml = strXml.substr(0, nPos + 1);
		}
		return strXml.trim();
	};

	var parseCompanions = function(strXml) {
	    if (strXml.length === 0) {
	    	APN_Logger.warn(_prefix, 'parseCompanions > empty companions xml');
			return null;
	    }
	    strXml = trimXml(strXml);
	    if (strXml.substr(0,13) !== '<CompanionAds') {
	    	strXml = '<CompanionAds>' + strXml + '</CompanionAds>';
	    }
	    var xmlDoc = null;
	    if (typeof window.DOMParser !== 'undefined') {
	    	xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
	    	if (xmlDoc.documentElement.nodeName === 'parsererror') {
	    		try{
	    			APN_Logger.error(_prefix, 'parseCompanions > Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
	    		}
	    		catch(e) {}
	        	APN_Logger.warn(_prefix, 'parseCompanions > invalide xml structure');
		        return null;
	    	}
	    }
	    else if (typeof window.ActiveXObject !== 'undefined') {
	    	try {
		    	xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM'); 
		    	xmlDoc.loadXML(strXml);
			    if (xmlDoc.parseError.errorCode !== 0) {
			    	APN_Logger.error(_prefix, xmlDoc.parseError);
			        return null;
			    }
	    	}
	    	catch (ex) {
		    	APN_Logger.error(_prefix, 'parseCompanions > Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
	 	        return null;
	    	}
	    }
	    else {
	    	APN_Logger.error(_prefix, 'parseCompanions > Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
	        return null;
	    }
	    if (!xmlDoc) {
	    	APN_Logger.error(_prefix, 'parseCompanions > invalid xml structure');
	        return null;
	    }
	    
	    var APN_CompanionAdsParser = __webpack_require__(25);
	    var companionsObj = APN_CompanionAdsParser.parse(xmlDoc);
	    return companionsObj;
	};

	module.exports = {
		renderCompanions: function(companionAds, options, fnCallback) {
			APN_Logger.log(_prefix, 'renderCompanions called.');
			var companions = new CompanionsHandler(companionAds, options, fnCallback);
			return companions;
		},
		
		stopCompanions: function(companionsObj) {
			if (companionsObj) {
				companionsObj.stop();
			}
		},
		
		parse: function(strCompanions) {
			return parseCompanions(strCompanions);
		}
	};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Rendition Manager module.
	 * @module RenditionManager
	 */

	//var _mimeTypes = ['video/x-flv', 'video/mp4', 'video/x-m4v', 'video/x-f4v', 'video/m4v', 'video/f4v', 'video/webm',
	//                  'application/x-shockwave-flash', 'application/javascript', 'application/x-javascript'];
	var _mimeTypes = ['video/x-flv', 'video/x-f4v', 'video/f4v', 'video/mp4', 'video/webm', 'video/ogg',
	                  'application/x-shockwave-flash', 'application/javascript', 'application/x-javascript'];
	var _arrRenditions = [];
	var _priority = 0;	// 0-no priority, 1-html5 only, 2-html5 first, 3-flash only, 4-flash first
	var _cacheManager = __webpack_require__(22);

	var _logger = __webpack_require__(9);
	var _prefix = 'Rendition Manager > ';

	function normalizeRenditions(arrRenditions) {
	    var arr = [];
	    for (var i = 0; i < arrRenditions.length; i++) {
	        var rend = arrRenditions[i];
	        if (!rend.hasOwnProperty('type')) {
	        	// type is required for rendition
	        	continue;
	        }
	        
	        if (!rend.hasOwnProperty('width')) {
	            rend.width = 0;
	        }
	        if (!rend.hasOwnProperty('height')) {
	            rend.height = 0;
	        }
	        if (!rend.hasOwnProperty('bitrate')) {
	            rend.bitrate = 0x7FFFFFFF;
	        }
	        arr.push(rend);
	    }
	    return arr;
	}

	function isFlashOnlyType(type) {
		return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
			type === 'application/x-shockwave-flash';
	}

	function isHtml5OnlyType(type) {
		return type === 'video/webm' || type === 'video/ogg' || type === 'application/javascript' ||
			type === 'application/x-javascript';
	}

	function isCompatibleType(type) {
	    if (_priority === 1 && isFlashOnlyType(type)) {
	    	return false;
	    }
	    if (_priority === 3 && isHtml5OnlyType(type)) {
	    	return false;
	    }
	    for (var i = 0; i < _mimeTypes.length; i++) {
	        if (type === _mimeTypes[i]) {
	            return true;
	        }
	    }
	    return false;
	}

	function removeNotCompatibleVideoTypes() {
	    for (var i = 0; i < _arrRenditions.length; ) {
	        if (isCompatibleType(_arrRenditions[i].type.toLowerCase())) {
	        	i++;
	        }
	        else {
	        	_arrRenditions.splice(i, 1);
	        }
	    }	
	}

	function getCloserSizes(width, height) {
	    var arrRend = [];
	    var desr = -1;
	    for (var i = 0; i < _arrRenditions.length; i++) {
	        if (_arrRenditions[i].width >= width && (desr === -1 || desr >= (_arrRenditions[i].width - width))) {
	            if (desr > (_arrRenditions[i].width - width)) {
	                arrRend.length = 0;
	            }
	            arrRend.push(_arrRenditions[i]);
	            desr = _arrRenditions[i].width - width;
	        }
	    }

	    if (arrRend.length > 0) {
	        _arrRenditions.length = 0;
	        _arrRenditions = arrRend.slice();
	    } else {
	        for (i = 0; i < _arrRenditions.length; i++) {
	            if (_arrRenditions[i].width < width && (desr === -1 || desr >= (width - _arrRenditions[i].width))) {
	                if (desr > (width - _arrRenditions[i].width)) {
	                    arrRend.length = 0;
	                }
	                arrRend.push(_arrRenditions[i]);
	                desr = width - _arrRenditions[i].width;
	            }
	        }
	        if (arrRend.length > 0) {
	            _arrRenditions.length = 0;
	            _arrRenditions = arrRend.slice();
	        }
	    }
	    if (_arrRenditions.length === 1) {
	        return;
	    }

	    arrRend.length = 0;
	    desr = -1;
	    // height
	    for (i = 0; i < _arrRenditions.length; i++) {
	        if (_arrRenditions[i].height >= height && (desr === -1 || desr >= (_arrRenditions[i].height - height))) {
	            if (desr > (_arrRenditions[i].height - height)) {
	                arrRend.length = 0;
	            }
	            arrRend.push(_arrRenditions[i]);
	            desr = _arrRenditions[i].height - height;
	        }
	    }

	    if (arrRend.length > 0) {
	        _arrRenditions.length = 0;
	        _arrRenditions = arrRend.slice();
	    } else {
	        for (i = 0; i < _arrRenditions.length; i++) {
	            if (_arrRenditions[i].height < height && (desr === -1 || desr >= (height - _arrRenditions[i].height))) {
	                if (desr > (height - _arrRenditions[i].height)) {
	                    arrRend.length = 0;
	                }
	                arrRend.push(_arrRenditions[i]);
	                desr = height - _arrRenditions[i].height;
	            }
	        }
	        if (arrRend.length > 0) {
	            _arrRenditions.length = 0;
	            _arrRenditions = arrRend.slice();
	        }
	    }
	}

	function matchPriority(type) {
		if (_priority === 0) {
			return true;
		}
		if (_priority === 1 && isFlashOnlyType(type)) {
			return false;
		}
		if (_priority === 3 && isHtml5OnlyType(type)) {
			return false;
		}
		return true;
	}

	function getCloserBitrates(bitrate) {
	    var arrRend = [];
	    var desr = -1;
	    // get the lower closer bitrate rendition 
	    for (var i = 0; i < _arrRenditions.length; i++) {
	        if (_arrRenditions[i].bitrate <= bitrate && (desr === -1 || desr >= (bitrate - _arrRenditions[i].bitrate))) {
	            if (desr > (bitrate - _arrRenditions[i].bitrate)) {
	                arrRend.length = 0;
	            }
	            desr = bitrate - _arrRenditions[i].bitrate;
	            arrRend.push(_arrRenditions[i]);
	        }
	    }
	    if (arrRend.length > 0) {
	        _arrRenditions.length = 0;
	        _arrRenditions = arrRend.slice();
	    } else {
	        // get the higher closer bitrate rendition 
	        for (i = 0; i < _arrRenditions.length; i++) {
	            if (_arrRenditions[i].bitrate >= bitrate && (desr === -1 || desr >= (_arrRenditions[i].bitrate - bitrate))) {
	                if (desr > (_arrRenditions[i].bitrate - bitrate)) {
	                    arrRend.length = 0;
	                }
	                desr = _arrRenditions[i].bitrate - bitrate;
	                arrRend.push(_arrRenditions[i]);
	            }
	        }
	    }
	    if (arrRend.length === 1 || _priority === 0) {
	    	return arrRend[0];
	    }
	    else {
	    	if (_priority === 1 || _priority === 3) {
	            for (i = 0; i < arrRend.length; i++) {
	            	if (matchPriority(arrRend[i].type.toLowerCase())) {
	            		return arrRend[i];
	            	}
	            }
	            return null;
	    	}
	    	else {
	            for (i = 0; i < arrRend.length; i++) {
	            	if (_priority === 2 && !isFlashOnlyType(arrRend[i].type.toLowerCase())) {
	            		return arrRend[i];
	            	}
	            	if (_priority === 4 && isFlashOnlyType(arrRend[i].type.toLowerCase())) {
	            		return arrRend[i];
	            	}
	            }
	        	return arrRend[0];
	    	}
	     }
	}

	function getVpaidRendition(width, height, bitrate) {
		var rend = null;
		var arrNotVpaidRend = [];
	    for (var i = 0; i < _arrRenditions.length;) {
	    	if (!_arrRenditions[i].apiFramework || _arrRenditions[i].apiFramework.toLowerCase().indexOf('vpaid') < 0) {
	    		// not vpaid
	    		arrNotVpaidRend.push(_arrRenditions[i]);
	    		_arrRenditions.splice(i, 1);
	    	}
	    	else {
	    		i++;
	    	}
	    }
	    if (_arrRenditions.length > 0) {
	        if (_arrRenditions.length === 1) {
	            return _arrRenditions[0];
	        }
	    		
	        // sizes
	        getCloserSizes(width, height);
	        if (_arrRenditions.length === 1) {
	        	rend = _arrRenditions[0];
	        }
	        else {
		         // bitrates
		        rend = getCloserBitrates(bitrate);
		   }
	    }
	    if (rend === null) {
	    	// restore not vpaid renditions
	    	_arrRenditions = arrNotVpaidRend.slice();
	    }
	    return rend;
	}

	function setPriority(options) {
		_priority = 2;	// default priority to html5,flash order
		if (options && options.playerTechnology && Array.isArray(options.playerTechnology) && options.playerTechnology.length > 0) {
			if (options.playerTechnology.length === 1) {
				if (options.playerTechnology[0] === 'html5') {
					_priority = 1;
				}
				else {
					_priority = 3;
				}
			}
			else {
				if (options.playerTechnology[0] === 'flash') {
					_priority = 4;
				}
			}
		}
	}

	function setNotVpaidPriority(options) {
		_priority = 2;	// default priority to html5,flash order
		if (options && options.playerTechnology && Array.isArray(options.playerTechnology) && options.playerTechnology.length > 0) {
			if (options.playerTechnology.length === 1) {
				if (options.playerTechnology[0] === 'html5') {
					_priority = 1;
				}
				else {
					_priority = 3;
				}
			}
		}
	}

	function addPlayerPriority(rend) {
		if (!rend) {
		    _logger.error(_prefix, 'Failed to select rendition');
			return {success: false, errorCode: 403};
		}
		
		if (_priority === 1) {
			rend['requiredPlayer'] = 1;
		}
		else if (_priority === 3) {
			rend['requiredPlayer'] = 2;
		}
		else {
			if (isFlashOnlyType(rend.type.toLowerCase())) {
				rend['requiredPlayer'] = 2;
			}
			else if (isHtml5OnlyType(rend.type.toLowerCase())) {
				rend['requiredPlayer'] = 1;
			}
			else {
				rend['requiredPlayer'] = 0;
			}
		}
		rend['success'] = true;
		_logger.info(_prefix, 'Selected rendition: ', rend);
		return rend;
	}

	function getBitrate(bitrate) {
		if (bitrate && bitrate > 0) {
			_logger.info(_prefix, 'Selected bitrate (not from cache): ' + bitrate);
			return bitrate;
		}
		var newBitrate = 1;		// take a lowest bitrate
		try {
			var temp = _cacheManager.getGenericData('anxBandwidth');
			//var temp = localStorage.getItem("anxBandwidth");
			if (temp) {
				newBitrate = temp;
				_logger.info(_prefix, 'Selected bitrate (from cache): ' + newBitrate);
			}
			else {
				_logger.info(_prefix, 'No bitrate data present in cache (use bitrate 1)');
			}
		}
		catch (ex) {
			_logger.warn(_prefix, 'Exception during getting bitrate from cache (use bitrate 1)');
		}
		return newBitrate;
	}

	//this will switch an order of playerTechnology if it has both flash and html5 and if the first is flash.
	function makeHtml5Preferable(_options) {
	    if (_options && _options.playerTechnology && Array.isArray(_options.playerTechnology) && 
	    	_options.playerTechnology.length === 2 && _options.playerTechnology[0] === 'flash' && _options.playerTechnology[1] === 'html5') {
	        _options.playerTechnology = ['html5','flash'];
	    }
	    return _options;
	}

	function isMobile() {
	    return navigator.appVersion.indexOf('Mobile') > -1 || navigator.appVersion.indexOf('Android') > -1;
	}

	function getRenditionForTechnology(width, height, newBitrate, options) {
		
	    // first try to select vpaid
	    var rend = getVpaidRendition(width, height, newBitrate);
	    if (rend) {
	    	if (matchPriority(rend.type.toLowerCase())) {
	    		_logger.info(_prefix, 'VPAID selected');
	    		return rend;
	    	}
	    }
	    
	    setNotVpaidPriority(options);
	    
	    if (_arrRenditions.length === 0) {
	        return null;
	    }
	    if (_arrRenditions.length === 1) {
	    	if (matchPriority(_arrRenditions[0].type.toLowerCase())) {
	    		return _arrRenditions[0];
	    	}
	    	else {
	    		return null;
	    	}
	    }
			
	    // sizes
	    getCloserSizes(width, height);
	    if (_arrRenditions.length === 1) {
	    	_logger.log(_prefix, 'Rendition selected by size');
	    	if (matchPriority(_arrRenditions[0].type.toLowerCase())) {
	    		return _arrRenditions[0];
	    	}
	    	else {
	    		return null;
	    	}
	    }
			
	    // bitrates
	    _logger.log(_prefix, 'Try select rendition by bitrate');
	    return getCloserBitrates(newBitrate);
	}

	function getUrl(width, height, bitrate, options) {
		
		options = makeHtml5Preferable(options);

		// set priority
		setPriority(options);
		
	    // types
	    removeNotCompatibleVideoTypes();
	    
	    var newBitrate = getBitrate(bitrate);
	    
	    var allRenditions = _arrRenditions.slice();
	    
	    // get HTML5 renditions
	    _arrRenditions.length = 0;
	    for (var i = 0; i < allRenditions.length; i++) {
	    	if (!isFlashOnlyType(allRenditions[i].type.toLowerCase())) {
	    		_arrRenditions.push(allRenditions[i]);
	    	}
	    }
	    _logger.log(_prefix, 'HTML5 rendition count = ' + _arrRenditions.length);
	    var rend;
	    if (_arrRenditions.length > 0) {
	    	rend = getRenditionForTechnology(width, height, newBitrate, options);
	    	if (rend) {
	    		return addPlayerPriority(rend);
	    	}
	    }
	    
	    if (isMobile()) {
	    	addPlayerPriority(null);
	    }
	    
	    // get Flash renditions
	    _arrRenditions.length = 0;
	    for (i = 0; i < allRenditions.length; i++) {
	    	if (isFlashOnlyType(allRenditions[i].type.toLowerCase())) {
	    		_arrRenditions.push(allRenditions[i]);
	    	}
	    }
	    _logger.log(_prefix, 'Flash rendition count = ' + _arrRenditions.length);
	    if (_arrRenditions.length > 0) {
	    	rend = getRenditionForTechnology(width, height, newBitrate, options);
	    	if (rend) {
	    		return addPlayerPriority(rend);
	    	}
	    }
	    return addPlayerPriority(null);
	}
	    
	function getExactSizes(width, height) {
	    var arrRend = [];
	    for (var i = 0; i < _arrRenditions.length; i++) {
	        if (_arrRenditions[i].width === width && _arrRenditions[i].height === height) {
	            arrRend.push(_arrRenditions[i]);
	        }
	    }

	    _arrRenditions.length = 0;
	    if (arrRend.length > 0) {
	        _arrRenditions = arrRend.slice();
	    }
	}

	function removeSelectedCompanionFromArray(arrCompanions, id) {
		for (var i = 0; i < arrCompanions.length; i++) {
			if (arrCompanions[i].id === id) {
				arrCompanions.splice(i, 1);
				break;
			}
		}
	}

	function selectCompanions(companionAds, containers) {
		// validation
		if (!companionAds || companionAds.companions.length === 0 ||
			!containers || containers.length === 0) {
			return;
		}
		
		// generate rendition array from companionAds
		_arrRenditions = [];
		for (var i = 0; i < companionAds.companions.length; i++) {
			var companion = companionAds.companions[i];
			var rendition;
			try {
				rendition = Object.assign({}, companion);
			}
			catch(ex) {
				try {
					var str = JSON.stringify(companion);
					rendition = JSON.parse(str);
				}
				catch(ex) {
					continue;
				}
			}
	        rendition.id = i;
	        rendition.type = 'unknown';
	        if (companion.hasOwnProperty('StaticResource')) {
	        	rendition.type = companion.StaticResource.type;
	        }

	        _arrRenditions.push(rendition);
		}
		
		if (_arrRenditions.length === 0) {
			return;
		}
		
		var saveRenditions = _arrRenditions.slice();
		for (i = 0; i < containers.length && saveRenditions.length > 0; i++) {
			var container = containers[i];
			
			_arrRenditions.length = 0;
			_arrRenditions = saveRenditions.slice();

		    // sizes
		    getExactSizes(container.width, container.height);
		    if (_arrRenditions.length === 1) {
		    	_logger.log(_prefix, 'Companion rendition selected by size');
			    container.companion = _arrRenditions[0];
			    // make sure we will not select same companions from different containers
			    removeSelectedCompanionFromArray(saveRenditions, container.companion.id);
			    continue;
		    }
		    if (_arrRenditions.length === 0) {
		    	_logger.log(_prefix, 'Companion rendition not selected for container');
		    	container.companion = null;
		    	continue;
		    }
		    
		    // check for vpaid
		    var bFound = false;
		    for (var j = 0; j < _arrRenditions.length; j++) {
		    	if (_arrRenditions[j].apiFramework && _arrRenditions[j].apiFramework.toLowerCase().indexOf('vpaid') < 0) {
		    		_logger.log(_prefix, 'Companion rendition selected by apiFramework');
				    container.companion = _arrRenditions[j];
				    // make sure we will not select same companions from different containers
				    removeSelectedCompanionFromArray(saveRenditions, container.companion.id);
				    bFound = true;
		    		break;
		    	}
		    }
		    
		    if (!bFound) {
		    	// select the first one
		    	_logger.log(_prefix, 'First companion rendition selected');
			    container.companion = _arrRenditions[0];
			    // make sure we will not select same companions from different containers
			    removeSelectedCompanionFromArray(saveRenditions, container.companion.id);
		    }
		}
	}


	module.exports = {
		    /** Describe Rendition manager Initialization.
		     * @param {array} arrRenditions - array of available renditions. 
		     */
			init: function(arrRenditions) {
				_arrRenditions = normalizeRenditions(arrRenditions);
			},
			
		    /** Describe Rendition manager Main Entry Point Here.
		     * @param {number} width - video player width in pixels. 
		     * @param {number} height - video player height in pixels. 
		     * @param {number} bitrate - bitrate in Kbps. 
		     * @param {object} options - options from impbus request. 
		     * @return {object} return rendition object with all vast information for media file.
		     * 		Additionally the property requiredPlayer, success, and errorCode added to the output object.
		     * 		requiredPlayer value: 0 - any, 1 - html5, 2 - flash 
		     * 		success value: true is success, false otherwise (if false errorCode is added)
		     * 		errorCode value: VAST error code
		     */
			getUrl: function(width, height, bitrate, options) {
				return getUrl(width, height, bitrate, options);
		    },
			
		    /** Describe Rendition manager companions selection.
		     * @param {object} companionAds - video player width in pixels. 
		     * 		required - 'required' property from CompanionAds node if present
		     * 		companions - array of objects represents Companion nodes 
		     * @param {array} containers - array of objects represents containers for companions on page.
		     * 		each of container object has to have the following properties:
		     * 		id - internal identificator
		     * 		width - widthy of container
		     * 		height - height of container
		     * 		companion - pointer to companion object in companionAds.companions (generated by current call)  
		     */
			selectCompanionsForContainers: function(companionAds, containers) {
				selectCompanions(companionAds, containers);
		    }
	};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Cache Manager module.
	 * @module CacheManager
	 */

	var utils = __webpack_require__(23);


	var prefix = "Cache Manager";

	//////////////////////////////////////////////////////////////////////
	// CONSTANTS
	var TTL_DEFAULT_MIN = 2 * 20; // 2 hours expressed in minutes
	var MSEC_PER_MINUTE = 60 * 1000;
	var TTL_DEFAULT_MSEC = TTL_DEFAULT_MIN * MSEC_PER_MINUTE; // expressed in seconds

	//////////////////////////////////////////////////////////////////////
	// VARIABLES
	var _ttlMsec = TTL_DEFAULT_MSEC;

	var _genericDataStotagePrefix = "___appnexus_video_cachemanager_generic_data___";
	var adTokenStorageKey = "___appnexus_video_cachemanager_ad_token___";

	var backupInMemoryStorageObj = {};

	//storage types:
	//0 - localStorage
	//1 - cookie
	//2 - in memory
	var storageTypeToUse;

	if (isLocalStorageSupported()) {
	    storageTypeToUse = 0;
	} else {
	    if (isCookieStorageSupported()) {
	        storageTypeToUse = 1;
	    } else {
	        storageTypeToUse = 2;
	    }

	}

	utils.debug("Using Cache Method " + storageTypeToUse, prefix);

	//docCookies library from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie
	var docCookies = {
	    getItem: function(sKey) {
	        if (!sKey) {
	            return null;
	        }
	        return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
	    },
	    setItem: function(sKey, sValue, vEnd, sPath, sDomain, bSecure) {
	        if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
	            return false;
	        }
	        var sExpires = "";
	        if (vEnd) {
	            switch (vEnd.constructor) {
	                case Number:
	                    sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
	                    break;
	                case String:
	                    sExpires = "; expires=" + vEnd;
	                    break;
	                case Date:
	                    sExpires = "; expires=" + vEnd.toUTCString();
	                    break;
	            }
	        }
	        document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
	        return true;
	    },
	    removeItem: function(sKey, sPath, sDomain) {
	        if (!this.hasItem(sKey)) {
	            return false;
	        }
	        document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
	        return true;
	    },
	    hasItem: function(sKey) {
	        if (!sKey) {
	            return false;
	        }
	        return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
	    },
	    keys: function() {
	        var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
	        for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
	            aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);
	        }
	        return aKeys;
	    }
	};

	//write object to whatever storage method we are using, with specified key
	function writeToStorage(key, obj, dontExpire) {
	    switch (storageTypeToUse) {
	        case 0:
	            writeToLocalStorage(key, obj);
	            break;
	        case 1:
	            writeToCookieStorage(key, obj, dontExpire);
	            break;
	        default:
	        case 2:
	            writeToInMemoryStorage(key, obj);
	            break;
	    }
	}

	//get a object from the storage method we are using, that has the specified key
	function getFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            return getFromLocalStorage(key);
	        case 1:
	            return getFromCookieStorage(key);
	        default:
	        case 2:
	            return getFromInMemoryStorage(key);
	    }

	}

	//delete an object in the storaege method we are using, 
	function deleteFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            deleteFromLocalStorage(key);
	            break;
	        case 1:
	            deleteFromCookieStorage(key);
	            break;
	        default:
	        case 2:
	            deleteFromInMemoryStorage(key);
	            break;
	    }
	}

	function writeToLocalStorage(key, obj) {
	    if (localStorage) {
	        localStorage.setItem(key, obj);
	    }
	}

	function getFromLocalStorage(key) {
	    if (localStorage) {
	        return localStorage.getItem(key);
	    }
	}

	function deleteFromLocalStorage(key) {
	    if (localStorage) {
	        localStorage.removeItem(key);
	    }
	}

	function writeToCookieStorage(key, obj, dontExpire) {
	    docCookies.setItem(key, obj, (dontExpire ? Infinity : new Date((Date.now() + _ttlMsec)).toUTCString()));
	}

	function getFromCookieStorage(key) {
	    return docCookies.getItem(key);
	}

	function deleteFromCookieStorage(key) {
	    docCookies.removeItem(key);
	}

	function writeToInMemoryStorage(key, obj) {
	    if (backupInMemoryStorageObj) {
	        backupInMemoryStorageObj[key] = obj;
	    }
	}

	function getFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        return backupInMemoryStorageObj[key];
	    }
	}

	function deleteFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        delete backupInMemoryStorageObj[key];
	    }
	}

	//return true if localStorage is supported, false otherwise
	function isLocalStorageSupported() {

	    //if the browser is blocking 3rd party storage, accessing localStorage might throw an exception (VID-2089)
	    try {
	        if (localStorage) {
	            var testValue = "apntestls" + Math.random();
	            try {
	                //try writing and reading something
	                localStorage.setItem(testValue, testValue);
	                localStorage.removeItem(testValue);
	                return true;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}


	//return true if localStorage is supported, false otherwise
	function isCookieStorageSupported() {
	    try {
	        if (document && document.cookie) {
	            var testValue = "apntestcookie" + Math.random();
	            try {
	                docCookies.setItem(testValue, testValue, Infinity);
	                var cookieWorked = docCookies.hasItem(testValue) && (docCookies.getItem(testValue) === testValue);
	                docCookies.removeItem(testValue);
	                return cookieWorked;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}

	// caches the adObject - this will overwrite any existing cached ad
	// the cache will also be timestamp with the current time in milliseconds
	// for calculating time to live
	function addAdToCache(adObject, adId) {
	    var cacheObject = {};
	    cacheObject.timestamp = new Date().getTime();
	    cacheObject.ad = adObject;

	    try {
	        writeToStorage(adId, JSON.stringify(cacheObject));
	    } catch (e) {

	    }
	}

	// returns the ad stored in the cache if the cache has not expired
	// returns null if the cache has expired (based on the configured time-to-live) 
	// OR if there is no ad in the cache
	// NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function getCachedAd(adId) {
	    var ts = new Date().getTime();

	    var retrievedCacheItem;

	    try {
	        var itemFromCache = getFromStorage(adId);
	        retrievedCacheItem = (itemFromCache && JSON.parse(itemFromCache));
	        // clear the cache, setting it back to default (or empty)
	        deleteFromStorage(adId);
	    } catch (e) {

	    }

	    // check to see if the ad cache exists and if the cache has not expired
	    if (retrievedCacheItem && retrievedCacheItem.timestamp && retrievedCacheItem.timestamp > 0) {
	        var cacheAge = ts - retrievedCacheItem.timestamp;
	        //if we have expired, return nothing
	        if (cacheAge <= _ttlMsec) {
	            return retrievedCacheItem.ad;
	        }
	    }

	    return null;
	}

	// clear the ad cache by creating a default ad cache object
	//NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function clearAdCache(adId) {
	    try {
	        deleteFromStorage(adId);
	    } catch (e) {

	    }
	}

	// converts the time-to-live argument from minutes to milliseconds
	// to make it easier to compare timestamps
	function setTTL(ttlMinutes) {
	    _ttlMsec = ttlMinutes * MSEC_PER_MINUTE;
	}

	// gets the current token from the cache
	function getAdToken() {
	    var tokenToReturn;
	    var tokenFromCache;
	    tokenFromCache = getFromStorage(adTokenStorageKey);

	    if (tokenFromCache) {
	        tokenToReturn = parseInt(tokenFromCache);
	    } else {
	        //no token found, use default
	        tokenToReturn = 0;
	    }

	    //store new token in localStorage or local memory
	    writeToStorage(adTokenStorageKey, (tokenToReturn += 1), true);


	    return tokenToReturn;
	}

	function prependAppnexusIdToKey(incomingKey) {
	    return "apn_" + incomingKey;
	}

	module.exports = {

	    /**
	     * Set generic data in cache
	     * @param (string) key = key under which to store data
	     * @param (object) value = value to store.
	     * @return (boolean) true if value was succesfully stored, false otherwise
	     */
	    setGenericData: function(key, value) {
	        if (typeof key !== "undefined" && typeof value !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            try {
	                writeToStorage(key, value);
	                return true;
	            } catch (e) {

	            }
	        }
	        return false;
	    },

	    /**
	     * Get generic data from cache
	     * @param (string) key = key to retrive from data
	     * @return (object) object contaninig data from cache with given key, undefined if key not found.
	     */
	    getGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            return getFromStorage(key);
	        }
	    },

	    /**
	     * Delete generic data from cache
	     * @param (string) key = key to delete from cache
	     */
	    deleteGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            deleteFromStorage(key);
	        }
	    },

	    /**
	     * Force usage of a specifc cache storage method, This is an optional function, if it is not called we will attempt to use
	     * localStorage, with a in-memory object as backup. 0= use localStorage.  1 = use cookie.  2 = use in-memory storage
	     */
	    forceStorageMethod: function(storageType) {
	        storageTypeToUse = storageType;
	        utils.debug("Forced usage of cache method " + storageTypeToUse, prefix);
	    },

	    /**
	     * add the ad data to the cache
	     * @param (object) adObject = JSON object describing the contents of the VAST tag after it has been parsed and unwrapped
	     *      - this will become the input into the ad rendering logic
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    addAd: function(adObject, adId) {
	        if (adObject) {
	            addAdToCache(adObject, prependAppnexusIdToKey(adId));
	        }
	    },

	    /** Retrieves ad from the ad cache.  If none exists or if the cache has expired, null is returned
	     * @param (integer) adId = unique identifier for a specific ad cache
	     * @return (object) object containing results of VAST parsing if ad is cached; otherwise return null
	     */
	    getAd: function(adId) {
	        return getCachedAd(prependAppnexusIdToKey(adId));
	    },

	    /**
	     * Clears the cache, removing any cached ad
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    clearAd: function(adId) {
	        clearAdCache(prependAppnexusIdToKey(adId));
	    },

	    /** Sets the time-to-live settings for the ad cache
	     * @param (number) timeToLiveMinutes = specifies how long (in minutes) ad ad may remain in the cache before being discarded
	     */
	    setTimeToLive: function(timeToLiveMinutes) {
	        setTTL(timeToLiveMinutes);
	    },

	    /**
	     * Returns a token unique to this page which is used to identify an ad request.
	     */
	    getNextAdToken: function() {
	        // Remove unnecessary additional characters.
	        // return chars.substring(0, len);
	        return getAdToken();
	    }
	};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * General Utilities module.
	 * @module GeneralUtilities
	 */

	var _logger = __webpack_require__(9);


	//////////////////////////////////////////////////////////////////////
	// CONSTANTS
	var MAX_OBJ_TO_STRING_RECURSION = 9;




	//////////////////////////////////////////////////////////////////////
	// VARIABLES


	//////////////////////////////////////////////////////////////////////
	// FUNCTIONS
	function getXmlResponseFromXhrObject(responseObj) {
	    if (responseObj) {
	        //if the response has parsed XML, trace it as an XML object
	        //otherwise, trace it as a string
	        if (responseObj.responseXML) {
	            return responseObj.responseXML;
	        } else {
	            return responseObj.responseText;
	        }
	    }
	}

	//////////////////////////////////////////////////////////////////////
	// EXPORTS
	module.exports = {
	    /**
	     * @deprecated - use @appnexus/videoads-util-logging
	     * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
	     * @param (string) message = text to be written to the log
	     * @param (string) source = optional string which identifies the source of the debug statement
	     *      - if present, then it will be prepended to front of the string
	     *      - example 1:  debug("hello") ==> <timestamp> hello
	     *      - example 2:  debug("hello", "TM") ==> <timestamp> TM>hello
	     */
	    debug: function() {
	        _logger.handleLogDebugLegacySupport.apply(this, arguments);

	    },

	    /**
	     * @deprecated - use @appnexus/videoads-util-logging
	     * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
	     * @param (string) message = text to be written to the log
	     * @param (string) source = optional string which identifies the source of the debug statement
	     *      - if present, then it will be prepended to front of the string
	     *      - example 1:  debug("hello") ==> <timestamp> hello
	     * 
	     */
	    logDebug: function() {
	        _logger.handleLogDebugLegacySupport.apply(this, arguments);

	    },

	    /**
	     * @deprecated - use @appnexus/videoads-util-logging
	     * Sets debug level for logger
	     * @param (string) level = Debug level to use
	     */
	    setDebugLevel: function(level) {
	        _logger.setDebugLevel(level);
	    },

	    /**
	     * Checks to see if a string or an array is not empty:
	     *  @param (object) arg = string or array which is being evaluated
	     *  @returns (boolean)
	     *      - true = arg is defined and the length > 0
	     *      - false = arg is null, undefined or has a length of zero
	     */
	    isNotEmpty: function(arg) {
	        var answer = false;
	        if (arg !== null && arg) {
	            answer = (arg.length > 0);
	        }

	        return answer;
	    },

	    /**
	     * @deprecated - since we now have the abilility to directly pass objects to our debug statements, we no longer need this
	     * returns a string version of an object
	     * if the value of a field is itself an object, then will stringify that object as well
	     */
	    objectToString: function(obj, recursionCount) {
	        /*
	                try{
	                    return JSON.stringify(obj);
	                }catch(ex){
	                    return "null"
	                }
	             */
	        var answer = "null";

	        //set default recurisonCount if it's not specified
	        recursionCount = typeof recursionCount !== 'undefined' ? recursionCount : 0;

	        if (obj !== null) {
	            answer = "OBJ[";
	            var props = "";
	            for (var key in obj) {
	                var val = obj[key];
	                if (typeof val === 'object') {
	                    recursionCount++;
	                    if (recursionCount < MAX_OBJ_TO_STRING_RECURSION) {
	                        try {
	                            val = this.objectToString(val);
	                        } catch (ex) {
	                            val = "err:" + ex;
	                        }
	                    } else {
	                        val = "err: max recursion hit";
	                    }
	                }
	                if (props.length > 0) {
	                    props += ",";
	                }
	                props += (key + "=" + val);
	            }
	            answer += props;
	            answer += "]";
	        }


	        return answer;

	    },

	    /**
	     *  Generates a alphanueric random string, up to 16 characters long containing the set [0-9,a-z].
	     *  Note: It is not guaranteed that this will start with a letter.
	     *  Note: These are not UUIDs/GUIDs, do not use as such in critcial situaitons.
	     *  Note: This is not guaranteed to be crypogtaphically secure.
	     *  @param (object) arg = string or array which is being evaluated
	     *  @returns (String)
	     *      - random character string
	     */
	    getRandomString: function() {
	        return Math.random().toString(36).substring(2);
	    },

	    /**
	     *  Trace a XML response in a XHR object at the "info" trace level (if enabled)
	     *  @param (Object) responseObjects = Single XHR Response object, or Array of XHR Response Objects to trace.
	     *  @param (String) tracePrefix = Text to print as part of trace statement.
	     *
	     */
	    traceVastFromXhr: function(responseObjects, tracePrefix) {
	        try {
	            if (responseObjects) {
	                //if we are passed an array, treat each item in array as a XHR Response
	                if (Array.isArray(responseObjects)) {
	                    if (responseObjects.length > 0) {
	                        // var responsesToTrace = [];
	                        var xmlUrlLoadingChain = [];

	                        //parse URL and payload out of each object
	                        for (var curResponseArrayPos in responseObjects) {
	                            // var curResponsePayload = {};
	                            // curResponsePayload.url = responseObjects[curResponseArrayPos].responseURL;
	                            // curResponsePayload.payloadObj = getXmlResponseFromXhrObject(responseObjects[curResponseArrayPos]);
	                            // responsesToTrace.push(curResponsePayload);

	                            xmlUrlLoadingChain.push(responseObjects[curResponseArrayPos].responseURL);
	                        }

	                        var finalXhrObject = responseObjects[responseObjects.length - 1];
	                        if (finalXhrObject) {
	                            var finalXmlTag = getXmlResponseFromXhrObject(finalXhrObject);
	                            var finalXmlTagUrl = finalXhrObject.responseURL;

	                            _logger.info(tracePrefix, "Tag load chain:", xmlUrlLoadingChain, "\n",
	                                "Final Tag URL: ", finalXmlTagUrl, "\n", "Final Tag: ", finalXmlTag);
	                        }
	                    }
	                } else {
	                    //if we didn't get an array, treat responseObjects as a single XHR responsw
	                    var responsePayloadToTrace = getXmlResponseFromXhrObject(responseObjects);
	                    _logger.info(tracePrefix, "Tag URL:", responseObjects.responseURL, "\n", "Tag:", responsePayloadToTrace);

	                }
	            } 
	        }catch (e) {}
	    }



	};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * URL Loader module.
	 * @module UrlLoader
	 */



	var _logger = __webpack_require__(9);

	function ajaxLoad(url, data, callback, timeout, options, command) {

	    var httpRequest;
	    var startTime = 0;
	    var duration = 0;
	    var calcDuration = false;
	    var logger = __webpack_require__(23);
	    var cacheManager = __webpack_require__(22);

	    var useWithCredentials = true;
	    
		var debug = function(message) {
		    logger.logDebug(message, 'URL Loader');
		};
	    
	    if (options &&  typeof options.withCredentials !== 'undefined') {
	        useWithCredentials = options.withCredentials;
	    } 

	    if (window.XMLHttpRequest) { // Mozilla, Safari, ...
	        httpRequest = new XMLHttpRequest();
	    } else if (window.ActiveXObject) { // IE
	        try {
	            httpRequest = new ActiveXObject('Msxml2.XMLHTTP');
	        } catch (msxmlErr) {
	            try {
	                httpRequest = new ActiveXObject('Microsoft.XMLHTTP');
	            } catch (msErr) {}
	        }
	    }


	    if (!httpRequest) {
	        if (callback) {
	            callback.call(this, '406', ''); // request is not acceptable
	        }
	        return;
	    }
	    
	    httpRequest.onreadystatechange = function() {
	        if (httpRequest.readyState === 4) {

	            if (httpRequest.status === 200) {
	                if (callback) {
	                    callback.call(this, undefined, httpRequest.responseText, httpRequest);
	                }
	                debug('duration: ' + duration + ', response length: ' + httpRequest.responseText.length);
	                if (calcDuration && httpRequest.responseText && httpRequest.responseText.length > 2048) {
	                	var nBandWidth = (httpRequest.responseText.length * 8.0 * 1000.0) / (Math.max(1.0, duration) * 1024.0);
	            		var intBandwidth = parseInt(nBandWidth.toString());
	                    debug('Bandwidth: ' + intBandwidth);
	                	try {
	                		cacheManager.setGenericData('anxBandwidth', intBandwidth);
	                		//localStorage.setItem('anxBandwidth', intBandwidth);
	                	}
	                	catch(ex) {
	                	}
	                }
	            } else {
	                if (httpRequest.status >= 400 && httpRequest.status < 600) {
	                    if (callback) {
	                        callback.call(this, httpRequest.status, '', httpRequest);
	                    }
	                }
	            }

	        }
	        else if (httpRequest.readyState === 2) {
	        	startTime = (new Date()).getTime();
	        }
	        else if (httpRequest.readyState === 3) {
	        	if (startTime > 0) {
	        		calcDuration = true;
	        		duration = (new Date()).getTime() - startTime;
	        	}
	        }
	    };

	    httpRequest.onerror = function() {
	        //if there is an error, it might be becase we are using withCredentials
	        //let's try one more time without that flag set.
	        //this won't send cookies, but it's better than no ad at all
	        if(useWithCredentials) {
	            var newOpts = options ? options : {};
	            newOpts.withCredentials = false;
	            ajaxLoad(url, data, callback, timeout, newOpts, command);
	        } else {
	            if (callback) {
	                var errorStatus = httpRequest.status === 0 ? '404' : httpRequest.status.toString();
	                callback.call(this, errorStatus, '', httpRequest);
	            }
	        }
	    };


	    httpRequest.ontimeout = function() {
	        //_logger.log('Server Timeout');
	        if (callback) {
	            callback.call(this, 'Timeout', '', httpRequest);
	        }
	    };

	    httpRequest.open(command, url);
	    if (timeout) {
	        httpRequest.timeout = timeout;
	    }
	    httpRequest.withCredentials = useWithCredentials;
	    startTime = 0;
	    if (command === 'POST') {
	    	httpRequest.send(data);
	    }
	    else {
	        httpRequest.send();
	    }
	}

	function createTrackingPixel(url, eventName) {
	    _logger.log('Logging Event: ' + eventName + ' at url:' + url);
	    new Image(1, 1).src = url;

	}



	module.exports = {
		    /** Load a URL.
		     * @param {string} url - Target URL to load. 
		     * @param {Function} callback - Function to call back once loading has either completed or encountered an error.
		     * @param {number} timeout - Timeout (in ms) to use for this URL Load.
		     */
		    load: function(url, callback, timeout) {
		        ajaxLoad(url, null, callback, timeout, {withCredentials:true}, 'GET');
		    },

		    /** Load a URL.
		     * @param {string} url - Target URL to load. 
		     * @param {string} data - request data 
		     * @param {Function} callback - Function to call back once loading has either completed or encountered an error.
		     * @param {number} timeout - Timeout (in ms) to use for this URL Load.
		     */
		    loadPost: function(url, data, callback, timeout) {
		        ajaxLoad(url, data, callback, timeout, {withCredentials:true}, 'POST');
		    },


	    /** Track Pixel.
	     * @param {String} url - Url of traking pixel to track. 
	     * @param {String} eventName - Name of event being tracked.
	     */
	    trackPixel: function(url, eventName) {
	        createTrackingPixel(url, eventName);
	    }
	};


/***/ }),
/* 25 */
/***/ (function(module, exports) {

	var CompanionAdsParser = {
		
	    parse: function (xmlDoc) {
	    	var companionAdsDest = {companions: []};
	    	
	    	var VastXMLParserHelper = function () {
	    	    this.getSubNodes = function (node, subNodeName) {
	    	        var nodes = node.getElementsByTagName(subNodeName);
	    	        if (nodes.length > 0) {
	    	            return nodes;
	    	        }
	    	        return null;
	    	    };

	    	    this.getSubNode = function (node, subNodeName, index) {
	    	        if (!index) {
	    	            index = 0;
	    	        }
	    	        var nodes = node.getElementsByTagName(subNodeName);
	    	        if (nodes.length > index) {
	    	            return nodes[index];
	    	        }
	    	        return null;
	    	    };

	    	    this.getNodeValue = function (node) {
	    	        if (node.childNodes.length === 0) {
	    	            return '';
	    	        }
	    	        var val = node.childNodes[0].nodeValue;
	    	        return val.trim();
	    	    };

	    	    this.getNodeValues = function (node) {
	    	        if (node.childNodes.length === 0) {
	    	            return '';
	    	        }
	    	        var wholeVal = '';
	    	        for (var i = 0; i < node.childNodes.length; i++) {
	    	            var val = node.childNodes[i].nodeValue;
	    	            wholeVal += val;
	    	        }
	    	        return wholeVal.trim();
	    	    };

	    	    this.getNodeAttributeValue = function (node, attributeName) {
	    	        var val = node.getAttribute(attributeName);
	    	        if (val === null) {
	    	            val = '';
	    	        }
	    	        return val;
	    	    };

	    	    this.getNodeAttributeNumberValue = function (node, attributeName, defaultValue) {
	    	        if (!defaultValue) {
	    	            defaultValue = 0;
	    	        }
	    	        var answer = defaultValue;
	    	        var val = this.getNodeAttributeValue(node, attributeName);

	    	        if (val.length > 0) {
	    	            if (val.indexOf('.') >= 0) {
	    	                answer = parseFloat(val);
	    	            }
	    	            else {
	    	                answer = parseInt(val);
	    	            }
	    	        }

	    	        return answer;
	    	    };

	    	    this.getNodeAttributeBooleanValue = function (node, attributeName, defaultValue) {
	    	        if (!defaultValue) {
	    	            defaultValue = false;
	    	        }
	    	        var answer = defaultValue;
	    	        var val = this.getNodeAttributeValue(node, attributeName);

	    	        if (val.length > 0) {
	    	            var char = val.toLowerCase().charAt(0);
	    	            answer = (char === 't');
	    	        }

	    	        return answer;
	    	    };

	    	    this.getSubNodeValue = function (parentNode, subNodeName, defaultValue) {
	    	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	    	        var subnode = this.getSubNode(parentNode, subNodeName);
	    	        if (subnode !== null) {
	    	            return this.getNodeValue(subnode);
	    	        }
	    	        return defaultValue;
	    	    };

	    	    this.getSubNodeWholeValue = function (parentNode, subNodeName, defaultValue) {
	    	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	    	        var subnode = this.getSubNode(parentNode, subNodeName);
	    	        if (subnode !== null) {
	    	            return this.getNodeValues(subnode);
	    	        }
	    	        return defaultValue;
	    	    };

	    	    this.getSubNodeBooleanValue = function (parentNode, subNodeName, defaultValue) {
	    	        defaultValue = (typeof defaultValue === 'undefined') ? 'false' : defaultValue;

	    	        var value = this.getSubNodeValue(parentNode, subNodeName);
	    	        if (value.length > 0 && value.toLowerCase().charAt(0) === 't') {
	    	            return true;
	    	        }
	    	        if (value.length > 0 && value.toLowerCase().charAt(0) === 'f') {
	    	            return false;
	    	        }
	    	        return defaultValue;
	    	    };
	    	};
	    	var helper = new VastXMLParserHelper();
	    	
	    	var companionAdsNode = helper.getSubNode(xmlDoc, 'CompanionAds');
	    	var req = helper.getNodeAttributeValue(companionAdsNode, 'required');
	    	if (req && req.length > 0) {
	    		companionAdsDest.required = req;
	    	}
	    	
	        var nodes = helper.getSubNodes(companionAdsNode, 'Companion');
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
	            	//var companion = JSON.parse(JSON.stringify(APN_Companion));
	            	var companion = {};
	            	
	            	// required attributes 
	            	var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
	            	var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
	            	if (width <= 0 || height <= 0) {
	            		continue;
	            	}
	            	companion.width = width;
	            	companion.height = height;
	            	
	            	// optional attributes and subnodes
	            	var val = helper.getNodeAttributeValue(node, 'id');
	            	if (val) {
	            		companion.id = val;
	            	}
	            	
	            	val = helper.getNodeAttributeNumberValue(node, 'assetWidth', -1);
	            	if (val > 0) {
	            		companion.assetWidth = val;
	            	}
	            	
	            	val = helper.getNodeAttributeNumberValue(node, 'assetHeight', -1);
	            	if (val > 0) {
	            		companion.assetHeight = val;
	            	}
	            	
	            	val = helper.getNodeAttributeNumberValue(node, 'expandedWidth', -1);
	            	if (val > 0) {
	            		companion.expandedWidth = val;
	            	}
	            	
	            	val = helper.getNodeAttributeNumberValue(node, 'expandedHeight', -1);
	            	if (val > 0) {
	            		companion.expandedHeight = val;
	            	}
	            	
	            	val = helper.getNodeAttributeValue(node, 'apiFramework');
	            	if (val) {
	            		companion.apiFramework = val;
	            	}
	            	
	            	val = helper.getNodeAttributeValue(node, 'adSlotID');
	            	if (val) {
	            		companion.adSlotID = val;
	            	}
	            	
	            	val = helper.getNodeAttributeValue(node, 'required');
	            	if (val) {
	            		companion.required = val;
	            	}
	            	
	            	val = helper.getSubNodeValue(node, 'AltText');
	            	if (val) {
	            		companion.AltText = val;
	            	}
	            	
	            	val = helper.getSubNodeValue(node, 'AdParameters');
	            	if (val) {
	            		companion.AdParameters = val;
	            	}
	            	
	            	var resource = helper.getSubNode(node, 'StaticResource');
	            	if (resource) {
	                	val = helper.getNodeAttributeValue(resource, 'creativeType');
	                	if (val) {
	                		// validate capability
	                		var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
	                		var isMobile = false;
	            			if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
	            				isMobile = true;
	            			}
	            			if (isMobile && flashOnlyType) {
	            				// ignore this companion
	            				continue;
	            			}
	                		
	            			var staticResource = {type: val};
	                		val = helper.getNodeValues(resource);
	                		if (val) {
	                			staticResource.src = val;
	                       		companion.StaticResource = staticResource;
	                		}
	                 	}
	            	}
	            	
	            	val = helper.getSubNodeWholeValue(node, 'IFrameResource');
	            	if (val) {
	            		companion.IFrameResource = val;
	            	}
	            	
	            	val = helper.getSubNodeWholeValue(node, 'HTMLResource');
	            	if (val) {
	            		companion.HTMLResource = val;
	            	}
	            	
	            	val = helper.getSubNodeValue(node, 'CompanionClickThrough');
	            	if (val) {
	            		companion.CompanionClickThrough = val;
	            	}
	            	
	            	var j;
	            	var trackingNode;
	            	var url;
	                var clickTrackinEvents = helper.getSubNodes(node, 'CompanionClickTracking');
	                if (clickTrackinEvents) {
	                	companion.CompanionClickTracking = [];
	                	for (j = 0; j < clickTrackinEvents.length; j++) {
	                		trackingNode = clickTrackinEvents[j];
	                    	url = helper.getNodeValues(trackingNode);
	                    	if (url) {
	                    		companion.CompanionClickTracking.push(url);
	                    	}
	                	}
	                }
	            	
	                var trackinEvents = helper.getSubNodes(node, 'Tracking');
	                if (trackinEvents) {
	                	companion.TrackingEvents = [];
	                	for (j = 0; j < trackinEvents.length; j++) {
	                		trackingNode = trackinEvents[j];
	                    	var event = helper.getNodeAttributeValue(trackingNode, 'event');
	                    	url = helper.getNodeValues(trackingNode);
	                    	if (event && url) {
	                    		companion.TrackingEvents.push({eventType: event, url: url});
	                    	}
	                	}
	                }
	                
	                companionAdsDest.companions.push(companion);
	            }
	        }
	        return companionAdsDest;
	    }
	};

	module.exports = CompanionAdsParser;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_Destroy]";
	var APN_Logger = __webpack_require__(9);

	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};


	var verbose = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};

	/**
	 * Destroy handler
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {

	    return {
	        "init": function (videojsAPI) {

	            debug("init");

	            //set destroy event
	            videojsAPI.on("ended", function () {//this can be called multiple time because of replay mechanism
	                if (html5PlayerSelf.options.vpaid === false) {//jsvpaid case will be handled by JSVPAIDConfigure.js
	                    videojsAPI.trigger("customDestroy");
	                }
	            });

	            //custom event to handle destroy this can be called by both side of html5 and vpaid cases
	            videojsAPI.on("customDestroy", function () {//this can be called multiple time because of replay mechanism
	                var callbackFunctionAfterVideoComplete = function () {
	                    playerManager.isEnded = true;

	                    // Disable sidestream after ad is done if we aren't collapsing it
	                    if (html5PlayerSelf.options.disableCollapse.enabled === true) {
	                        if (playerManager.options.sideStreamObject) {
	                            if (playerManager.options.sideStreamObject.isActivated) {
	                                playerManager.options.sideStreamObject.moveAdUnitBack();
	                            }
	                        }

	                        playerManager.options.sideStream.wasEnabled = playerManager.options.sideStream.enabled;
	                        playerManager.options.sideStream.enabled = false;
	                    }

	                    if (html5PlayerSelf.options.disableCollapse.enabled === true && html5PlayerSelf.options.disableCollapse.replay === true && !html5PlayerSelf.options.endCard.enabled) {
	                        videojsAPI.bigPlayButton.show();
	                        videojsAPI.bigPlayButton.addClass("vjs-big-play-button-replay");
	                        videojsAPI.controlBar.playToggle.el().style["pointer-events"] = "none";
	                    } else {


	                        //make black frame when video ended for VIDLA-1398
	                        //var el_wholeArea = document.getElementById(html5PlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(html5PlayerSelf.an_video_ad_player_id);
	                        document.getElementById(html5PlayerSelf.options.iframeVideoWrapperId).style.background = "black";


	                        //normal case
	                        verbose("hiding control bar and big play button");
	                        videojsAPI.trigger("concealControls");
	                        videojsAPI.bigPlayButton.hide();

	                        //VIDLA-1360 this should be moved to a part of handling video-complete vpaid event to avoid a conflict situation
	                        //destroyWithoutSkip should invoke only one time, seconds time will be igonored by existing rules
	                        //for that reason if disableCollapse is true, there will be second chance to invoke destroyWithoutSkip() when user click "skip" button
	                        //so following condition is required
	                        if (!html5PlayerSelf.options.disableCollapse.enabled) {
	                            playerManager.isSkipped = true;//this flag should set for VID-1885, and if disableCollapse is false and video complete means skip, we have to set isSkipped to true.
	                            playerManager.destroyWithoutSkip();//this actual termination logic should be invoked after video_complete triggered. so this callbackFunctionAfterVideoComplete is being passed into eventHandling logic
	                        }

	                        // Setting this flag prevents rewind tracker when firing if end card replay button clicked. In fact in the
	                        // normal replay John implemented this flag never gets set to true.
	                        if (!html5PlayerSelf.options.endCard.enabled) {
	                            verbose("isCompleted = true");
	                            playerManager.isCompleted = true;
	                        }
	                    }

	                    if (playerManager.isFullscreen) {//if video is on fullscreen then it will exit out of fullscreen when video is finished
	                        // exit full-screen
	                        verbose("exiting fullscreen before destroy()");
	                        if (document.exitFullscreen) {
	                            document.exitFullscreen();
	                        } else if (document.webkitExitFullscreen) {
	                            document.webkitExitFullscreen();
	                        } else if (document.mozCancelFullScreen) {
	                            document.mozCancelFullScreen();
	                        } else if (document.msExitFullscreen) {
	                            document.msExitFullscreen();
	                        }
	                    }

	                    if (playerManager.endCard) {
	                        verbose("showing EndCard.");
	                        playerManager.endCard.show();
	                    }
	                };

	                if (html5PlayerSelf.options.vpaid) {
	                    callbackFunctionAfterVideoComplete();//JSVPAID has it's own logic to invoke html5PlayerSelf.dispatchEventToAdunit for "video_complete", so it doesn't need to be invoked twice here
	                } else {

	                    html5PlayerSelf.dispatchEventToAdunit({"name": "video_complete"}, function () {
	                        callbackFunctionAfterVideoComplete();//must destroy adunit if disableCollapse false only
	                    });//this callback will be invoked after video_complete
	                }
	            });


	        }
	    };
	};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_Fullscreen]";
	var APN_Logger = __webpack_require__(9);

	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};

	var verbose = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};

	/**
	 * Fullscreen handler
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {

	    return {
	        "init": function (videojsAPI, floatingAdIndicator, adIndicatorTextObj) {

	            debug("init");

	            //for VID-2558 VID-2554 Desktop Safari, Firefox response lately from fullscreen change event so additional flag isFullscreenToggled will cover the situation. and it is used by Outstream AdUnit
	            if (html5PlayerSelf.isMobile() === false) {
	                videojsAPI.controlBar.fullscreenToggle.on("click", function () {
	                    //isFullscreenToggled flag will use for sideStream to have more accurate fullscreen status on desktop safari and firefox
	                    if (playerManager.isFullscreenToggled) {
	                        //do nothing because a part to handle "fullscreenchange" will set false
	                    } else {
	                        playerManager.isFullscreenToggled = true;
	                    }

	                });
	            }

	            videojsAPI.on("fullscreenchange", function () {
	                verbose("fullscreenchange");

	                if (html5PlayerSelf.isIos() && playerManager.isFullscreen) {
	                    playerManager.play();
	                }

	                if (playerManager.isFullscreen) {
	                    html5PlayerSelf.pendingFullscreenExit = true;
	                    if(html5PlayerSelf.isIos() && !html5PlayerSelf.options.fixedSizePlayer){
	                      videojsAPI.controlBar.el().style['bottom'] = "0.0em";
	                      if (!html5PlayerSelf.options.disableTopBar) {
	                        floatingAdIndicator.style.display = "block";
	                        if (html5PlayerSelf.floatingSkipButton) {
	                          if (html5PlayerSelf.readyForSkip) {
	                             html5PlayerSelf.floatingSkipButton.style.display = "block";
	                             html5PlayerSelf.floatingAdSkipText.style.display = "none";
	                          } else {
	                              html5PlayerSelf.floatingSkipButton.style.display = "none";
	                              html5PlayerSelf.floatingAdSkipText.style.display = "block";
	                          }
	                        }

	                    }
	                  }else {
	                    videojsAPI.controlBar.el().style['bottom'] = '';
	                    if (!html5PlayerSelf.options.disableTopBar) {
	                        adIndicatorTextObj.style.display = "block";
	                        floatingAdIndicator.style.display = "none";
	                        if (html5PlayerSelf.floatingSkipButton) {
	                            html5PlayerSelf.floatingSkipButton.style.display = "none";
	                            html5PlayerSelf.floatingAdSkipText.style.display = "none";
	                        }
	                    }
	                  }


	                    var delayForSuppressingMouseoutEvent;
	                    if (html5PlayerSelf.isMobile() === false) {
	                        delayForSuppressingMouseoutEvent = 1000;
	                    } else {
	                        delayForSuppressingMouseoutEvent = 0;//mobile (Android) doesn't need to delay to set isFullscreen flag for the mouseout event - it doesn't have a mouse
	                    }

	                    setTimeout(function () {
	                        html5PlayerSelf.pendingFullscreenExit = false;
	                        playerManager.isFullscreen = false;
	                        playerManager.isFullscreenToggled = false;//for sideStream activation


	                        html5PlayerSelf.dispatchEventToAdunit({
	                            name: "fullscreenchange",
	                            fullscreenStatus: "exit"
	                        });

	                        //Send notification of fullscreen enter and exit to HTML5 player.  2/9/2018, Mobile Engineering.
	                        playerManager.callbackForAdUnit.cbCoreVideoEvent("AdHandler", "video_fullscreen_exit");
	                    }, delayForSuppressingMouseoutEvent);//this delay must be required for supressing mouseout event when exit fullscreen


	                } else {
	                    playerManager.isFullscreen = !playerManager.isFullscreen;
	                    videojsAPI.controlBar.el().style['bottom'] = "0.0em";


	                    if (!html5PlayerSelf.options.disableTopBar) {
	                        floatingAdIndicator.style.display = "block";
	                        adIndicatorTextObj.style.display = "none";
	                        if (html5PlayerSelf.floatingSkipButton) {
	                            if (html5PlayerSelf.readyForSkip) {
	                                html5PlayerSelf.floatingSkipButton.style.display = "block";
	                                html5PlayerSelf.floatingAdSkipText.style.display = "none";
	                            } else {
	                                html5PlayerSelf.floatingSkipButton.style.display = "none";
	                                html5PlayerSelf.floatingAdSkipText.style.display = "block";
	                            }
	                        }
	                    }
	                    html5PlayerSelf.dispatchEventToAdunit({
	                        name: "fullscreenchange",
	                        fullscreenStatus: "enter"
	                    });

	                    //Send notification of fullscreen enter and exit to HTML5 player.  2/9/2018, Mobile Engineering.
	                    playerManager.callbackForAdUnit.cbCoreVideoEvent("AdHandler", "video_fullscreen_enter");
	                }


	            });

	        }
	    };
	};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_Controls]";
	var APN_Logger = __webpack_require__(9);

	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};

	/**
	 * Show / Hide ControlBar
	 * @param html5PlayerSelf
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf) {
	    return {
	        "init": function (videojsAPI) {

	            debug("init");

	            // custom vjs events to hide/show all controls on the control bar without hiding/showing the control bar itself
	            videojsAPI.on("concealControls", function () {
	                var _controlBar = videojsAPI.player().controlBar;

	                if (_controlBar && !_controlBar.concealed) {
	                    if (_controlBar.currentTimeDisplay) {
	                        _controlBar.currentTimeDisplay.hide();
	                    }
	                    if (_controlBar.durationDisplay) {
	                        _controlBar.durationDisplay.hide();
	                    }
	                    if (_controlBar.timeDivider) {
	                        _controlBar.timeDivider.hide();
	                    }
	                    if (_controlBar.muteToggle) {
	                        _controlBar.muteToggle.hide();
	                    }
	                    if (_controlBar.playToggle) {
	                        _controlBar.playToggle.hide();
	                    }
	                    if (_controlBar.fullscreenToggle) {
	                        _controlBar.fullscreenToggle.hide();
	                    }
	                    if (_controlBar.progressControl) {
	                        _controlBar.progressControl.hide();
	                    }
	                    if (_controlBar.volumeControl) {
	                        _controlBar.volumeControl.hide();
	                    }
	                    _controlBar.concealed = true;
	                }
	            });

	            videojsAPI.on("revealControls", function () {
	                var _controlBar = videojsAPI.player().controlBar;

	                if (_controlBar && _controlBar.concealed) {
	                    if (html5PlayerSelf.options.showProgressBar !== "bar" && html5PlayerSelf.options.showProgressBar !== false) {
	                        if (_controlBar.currentTimeDisplay) {
	                            _controlBar.currentTimeDisplay.show();
	                        }
	                        if (_controlBar.durationDisplay) {
	                            _controlBar.durationDisplay.show();
	                        }
	                        if (_controlBar.timeDivider) {
	                            _controlBar.timeDivider.show();
	                        }
	                    }

	                    if (_controlBar.muteToggle && html5PlayerSelf.options.showMute) {
	                        _controlBar.muteToggle.show();
	                    }

	                    if (_controlBar.playToggle && html5PlayerSelf.options.showPlayToggle) {
	                        _controlBar.playToggle.show();
	                    }

	                    if (_controlBar.fullscreenToggle && html5PlayerSelf.options.allowFullscreen) {
	                        _controlBar.fullscreenToggle.show();
	                    }

	                    if (html5PlayerSelf.options.showProgressBar !== false && html5PlayerSelf.options.showProgressBar !== "text") {
	                        if (_controlBar.progressControl) {
	                            _controlBar.progressControl.show();
	                        }
	                    }

	                    if (_controlBar.volumeControl && html5PlayerSelf.options.showVolume && html5PlayerSelf.displayVolumeControls()) {
	                        _controlBar.volumeControl.show();
	                    }

	                    _controlBar.concealed = false;
	                }
	            });


	        }
	    };
	};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_Orientation]";
	var APN_Logger = __webpack_require__(9);
	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};

	/**
	 * Orientation Handler
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {

	    return {
	        "init": function () {

	            debug("init");

	            var waterfallStepId = html5PlayerSelf.options.isWaterfall ? html5PlayerSelf.options.waterfallStepId : null;

	            // Handle orientation change on Device to resize the player
	            window.addEventListener("orientationchange", function () {
	            	// VIDLA-2065 (don't change player size for overlay player)
	                if (!html5PlayerSelf.options.overlayPlayer && playerManager.isReadyToExpandForMobile) {//for VID-1515
	                    if (waterfallStepId && waterfallStepId !== html5PlayerSelf.options.waterfallStepId) {
	                        // Ignore the events as these are from previous ad attempts;
	                        return;
	                    }
	                    var shouldNotResizeWhenSideStreamActivated = html5PlayerSelf.options.sideStreamObject && typeof(html5PlayerSelf.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated) === "function" ? html5PlayerSelf.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated() : false;
	                    if (shouldNotResizeWhenSideStreamActivated) {
	                        return;
	                    }
	                    html5PlayerSelf.refreshVideoLookAndFeel(html5PlayerSelf.options, playerManager);
	                }
	            });

	            window.addEventListener("resize", function() {
	    // For mobile we need to resize the player to fill fullscreen on resize
	    if (playerManager.options.shouldResizeVideoToFillMobileWebview) {
	      playerManager.options.width = window.innerWidth;
	      playerManager.options.height = window.innerHeight;
	      playerManager.resizeVideo(playerManager.options.aspectRatio, true);
	    }
	            });



	        }
	    };
	};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_BigPlayButton]";
	var APN_Logger = __webpack_require__(9);

	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};

	var verbose = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};

	/**
	 * Handler BigPlayButton
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {
	    return {
	        "init": function (videojsAPI) {

	            debug("init");

	            var bigPlayButtonHandler = function () {
	                playerManager.explicitPlay();
	                if (playerManager.isEnded === true) {
	                    playerManager.replay();
	                    videojsAPI.player().bigPlayButton.removeClass("vjs-big-play-button-replay");
	                    if (html5PlayerSelf.options.showBigPlayButton === false && videojsAPI.bigPlayButton) {
	                        videojsAPI.bigPlayButton.hide();
	                    }
	                }
	                //this timeout is due to a limitation in videojs
	                setTimeout(function () {
	                    playerManager.unmute();
	                }, html5PlayerSelf.bigbuttonUnmuteTimeout);
	            };

	            videojsAPI.player().bigPlayButton.on("click", function () {
	                verbose("big play button click");
	                bigPlayButtonHandler();
	            });

	            videojsAPI.player().bigPlayButton.on("touchend", function () {
	                verbose("big play button touchend");
	                bigPlayButtonHandler();
	            });


	        }
	    };
	};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_VideoPlay]";
	var APN_Logger = __webpack_require__(9);
	var UA_Parser = __webpack_require__(13)();
	var utils = __webpack_require__(8);

	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};

	var verbose = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};

	/**
	 * Handle Video Play Back
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {
	    return {
	        "init": function (videojsAPI) {

	            debug("init");

	            //set explictPaused
	            videojsAPI.controlBar.playToggle.on("click", function () {
	                verbose("play button click");
	                playerManager.explicitPaused = !playerManager.explicitPaused;
	            });

	            //set explictPaused
	            videojsAPI.controlBar.playToggle.on("touchend", function () {
	                verbose("play button touchend");
	                playerManager.explicitPaused = !playerManager.explicitPaused;
	            });

	            videojsAPI.on("durationchange", function () {
	                html5PlayerSelf.dispatchEventToAdunit({"name": "durationchange"});
	            });

	            videojsAPI.on("firstplay", function () {
	                html5PlayerSelf.dispatchEventToAdunit({"name": "firstplay"});
	                // VIDLA-126
	                // we have to update the volume controls ui
	                // since videojs doesn't seem to register above mute/unmute on the ui
	                // VIDLA-307 If mute visual is updated before the Ad Playback then this causes Safari issues for diagonally sliding button.
	                if (videojsAPI.controlBar.muteToggle) {
	                    videojsAPI.controlBar.muteToggle.update();
	                }
	                if (videojsAPI.controlBar.volumeControl && videojsAPI.controlBar.volumeControl.volumeBar) {
	                    videojsAPI.controlBar.volumeControl.volumeBar.update();
	                }
	                handleVolumeChange();
	            });

	            var handleVolumeChange = function () {
	                html5PlayerSelf.dispatchEventToAdunit({
	                    "name": "volume-change",
	                    "obj": {"volume": playerManager.isMuted ? 0 : videojsAPI.volume()},
	                    "eventType": "AdUnit"
	                });
	            };

	            videojsAPI.on("volumechange", handleVolumeChange);


	            //handle click toggle manually
	            videojsAPI.controlBar.playToggle.on("click", function () {
	                verbose("play button click");
	                if (playerManager.isPlayingVideo === true) {
	                    playerManager.explicitPause();
	                } else {
	                    playerManager.explicitPlay();
	                    playerManager.unmute();
	                }
	            });

	            videojsAPI.controlBar.playToggle.on("touchend", function () {
	                verbose("play button touchend");
	                if (playerManager.isPlayingVideo === true) {
	                    playerManager.explicitPause();
	                } else {
	                    playerManager.explicitPlay();
	                    playerManager.unmute();
	                }
	            });

	            videojsAPI.on("loadstart", function () {
	                html5PlayerSelf.dispatchEventToAdunit({"name": "loadstart"});
	            });

	            videojsAPI.on("pause", function () {
	                //html5PlayerSelf.dispatchEventToAdunit({"name": "video_pause"});
	                // VIDLA-1628,1687 - click to play button can be seen momentarily after Ad ends
	            	if (html5PlayerSelf.options.overlayPlayer &&
	            		Math.abs(videojsAPI.player().duration() - videojsAPI.player().currentTime()) < 0.5) {
	                    verbose("hiding big play button for overlay player at the end of the video");
	                    videojsAPI.player().bigPlayButton.el().style.display = "none";
	            	}
	            	else {
	                    verbose("showing big play button");
	                    videojsAPI.player().bigPlayButton.el().style.display = "block";
	            	}
	                playerManager.isPlayingVideo = false;
	                // VIDLA-1330-1331 For native fullscreen on iOS the native controls take over,
	                // hence the play-pause evetns do not get triggered via video js controls and
	                // even though the video pauses and plays the trackers do not fire and needs
	                // to handled specially. For iphone 9 isFullscreen is not set by videojs but by default
	                // on phones it is always fullscreen.
	                if(html5PlayerSelf.options.hasOwnProperty('overlayPlayer') &&
	                    ((utils.isIphone() && parseInt(utils.getIOSVersion()) < 10) ||
	                    (utils.isIos() && videojsAPI.isFullscreen()))
	                ){
	                    html5PlayerSelf.dispatchEventToAdunit({"name": "video_pause"});
	                }
	            });

	            videojsAPI.on("play", function () {
	                videojsAPI.player().bigPlayButton.el().style.display = "";

	                //html5PlayerSelf.dispatchEventToAdunit({"name": "video_resume"});
	                //html5PlayerSelf.dispatchEventToAdunit({"name": "impression"});
	                //html5PlayerSelf.dispatchEventToAdunit({"name": "video_start"});
	                if (playerManager.options.shouldResizeVideoToFillMobileWebview) {
	    							playerManager.options.width = window.innerWidth;
	    							playerManager.options.height = window.innerHeight;
	    							playerManager.resizeVideo(playerManager.options.aspectRatio, true);
	    						}

	                playerManager.isPlayingVideo = true;
	                // VIDLA-1330-1331 - Comments same as pause.
	                if(html5PlayerSelf.options.hasOwnProperty('overlayPlayer') &&
	                    ((utils.isIphone() && parseInt(utils.getIOSVersion()) < 10) ||
	                    (utils.isIos() && videojsAPI.isFullscreen()))
	                ){
	                    html5PlayerSelf.dispatchEventToAdunit({"name": "video_resume"});
	                }
	            });

	            videojsAPI.on("error", function (e) {
	                debug("error in video js");
	                var browser = UA_Parser.browser.name.toLowerCase();
	                // VIDLA-1009-1025-1032 videojs in IE11 sends non fatal errors which need to ignored.
	                var ignore_error_which_are_not_fatal = (e && e.target && html5PlayerSelf.options) &&
	                    (html5PlayerSelf.options.vpaid || (browser === "ie" && html5PlayerSelf.options.isWaterfall));
	                if (ignore_error_which_are_not_fatal &&
	                    (
	                        (e.target.toString().indexOf("poster=\"null\"") > 0) ||
	                        (e.target.nodeName.toLowerCase() === "video" && e.target.networkState <= 2) ||
	                        (e.target.nodeName.toLowerCase() === "div")
	                    )
	                ) {
	                    //do nothing here, this issue caused by js-vpaid player (mail online's)
	                    //do nothing, when video js's video element throws errors but which are not fatal
	                } else {
	                    verbose("destroying due to error in video js");
	                    playerManager.destroyWithoutSkip(true, html5PlayerSelf.CONST_MESSAGE_GENERAL_ERROR, null, 900);
	                }
	            });


	            /**
	             * invoke "callbackForAdUnit.cbWhenReady" to continute a flow of video player this is asynchoronous action
	             * and Outstream will wait this callback to start doing something (expanding...)
	             */
	            if (html5PlayerSelf.options.vpaid === false) {//for regular html5 video player
	                videojsAPI.one("loadedmetadata", function (e) {
	                    var obj = e.currentTarget;
	                    playerManager.videoObjectId = obj.id;
	                    playerManager.isReadyToExpandForMobile = true;

	                    debug("loadedmetadata video.js is ready to play");
	                    //disable click to play
	                    videojsAPI.tech.removeControlsListeners();

	                    //get real video size
	                    var realVideoWidth = obj.videoWidth;
	                    var realVideoHeight = obj.videoHeight;
	                    var aspectRatio = realVideoWidth / realVideoHeight;

	                    if (realVideoWidth > 0) {
	                        playerManager.resizeVideo(aspectRatio);

	                        if (typeof html5PlayerSelf.callbackForAdUnit.cbWhenReady === "function") {
	                            html5PlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
	                        }
	                    } else {
	                        //if the event doesn't return a videoWidth
	                        playerManager.resizeVideo(0);
	                        html5PlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
	                    }
	                });
	            }

	        }
	    };
	};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_PostProcess]";
	var APN_Logger = __webpack_require__(9);

	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};

	/**
	 * Post Process while will be called after video load
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {

	    return {
	        "init": function (videojsAPI, utils, topBarHeight) {

	            debug("init");

	            //enable ad icon if it's rquired
	            __webpack_require__(33)(html5PlayerSelf, playerManager).init(videojsAPI, utils, topBarHeight);

	            // VIDLA-40/1145 (hide control bar in Overlay Player for click-to-play/mouse-over ad)
	            if (html5PlayerSelf.isMobile() && html5PlayerSelf.options.hasOwnProperty('overlayPlayer') &&
	                (html5PlayerSelf.options.initialPlayback === 'click' || html5PlayerSelf.options.initialPlayback === 'mouseover')) {
	            	if (videojsAPI) {
	            		videojsAPI.controlBar.el_.style.setProperty('display', 'none', 'important');
		                html5PlayerSelf.options.hiddenControls = true;
	            	}
	            }
	            // VIDLA-1145 (hide control bar in Overlay Player for autoplay ad for iOS 9)
	            else if (html5PlayerSelf.options.hasOwnProperty('overlayPlayer') && html5PlayerSelf.isIos() && parseInt(utils.getIOSVersion()) < 10 &&
	                html5PlayerSelf.options.initialPlayback === 'auto') {
	            	if (videojsAPI) {
	            		videojsAPI.controlBar.el_.style.setProperty('display', 'none', 'important');
		                html5PlayerSelf.options.hiddenControls = true;
	            	}
	            }


	        }
	    };
	};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var prefixOfLog = "[PlayerManager_SettingAdIcons]";
	var APN_Logger = __webpack_require__(9);
	var adIconHandler = __webpack_require__(34);

	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};


	/**
	 * Setup Ad Icon
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{init: init}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {
	    return {
	        "init": function (videojsAPI, utils, topBarHeight) {

	            debug("init");
	            var bottomBarHeight = playerManager.options.playerSkin.controlBarHeight;

	            //VAST3.0 Ad Icon Support
	            var icons = new adIconHandler();
	            icons.init(playerManager.options.data.adIcons);
	            var iconList = icons.getIcons();

	            if (!iconList || (iconList && iconList.length === 0)) {
	                return;
	            }

	            var topMarginForIcon = playerManager.options.disableTopBar ? 0 : topBarHeight;
	            var bottomMarginForIcon = (utils.isMobile() || playerManager.options.controlBarPosition === "below") ? bottomBarHeight : 0;

	            videojsAPI.controlBar.el_.style.zIndex = 10;//cotrolbar will have higher z-index

	            // @exclude
	            playerManager.test("adIconOffset", icons);
	            // @endexclude


	            //only desktop has dynamic control bar, so ad icon should move on desktop by appearance of control bar
	            if (!utils.isMobile()) {

	                var el_wholeArea_video = document.getElementById(html5PlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(html5PlayerSelf.an_video_ad_player_id);

	                var moveDownAdIcon = function () {
	                    // VIDLA-1010 (redraw ad icons for vast/overlay player also)
	                    if (playerManager.isExpanded && playerManager.options.controlBarPosition !== "below") {//ad units other than Outstream will have true for this flag by a default value of playerManager
	                        var finalSize = playerManager.getFinalSize();
	                        var limitOfHeight = finalSize.height - topBarHeight - bottomBarHeight - 10;
	                        var offsetHeightForAdIcon = 0;
	                        icons.redraw(offsetHeightForAdIcon, limitOfHeight);
	                    }
	                };

	                var moveUpAdIcon = function () {
	                    // VIDLA-1010 (redraw ad icons for vast/overlay player also)
	                    if (playerManager.isExpanded && playerManager.options.controlBarPosition !== "below") {//ad units other than Outstream will have true for this flag by a default value of playerManager
	                        var finalSize = playerManager.getFinalSize();
	                        var limitOfHeight = finalSize.height - topBarHeight - bottomBarHeight - 10;
	                        icons.redraw(bottomBarHeight, limitOfHeight);
	                    }
	                };

	                //check bottom control bar active
	                videojsAPI.on("useractive", function () {
	                    moveUpAdIcon();
	                });

	                //check bottom control bar inactive
	                videojsAPI.on("userinactive", function () {
	                    if (videojsAPI.paused() === false) {
	                        moveDownAdIcon();
	                    }

	                });

	                el_wholeArea_video.addEventListener("mouseenter", function () {
	                    moveUpAdIcon();
	                });

	                el_wholeArea_video.addEventListener("mousemove", function () {
	                    moveUpAdIcon();
	                });

	                // el_wholeArea_video.addEventListener("mouseleave",function() {
	                //     moveDownAdIcon();
	                // });

	            }


	            videojsAPI.on("timeupdate", function () {
	                if (playerManager.options.vpaid && !playerManager.options.showVpaidIcons) {
	                    return;
	                }
	                var currentTime = Math.round(videojsAPI.player().currentTime());
	                var _currentTimeMsec = currentTime * 1000;
	                var videoDuration = Math.round(videojsAPI.player().duration());
	                var _videoDurationMsec = videoDuration * 1000;
	                if (iconList && iconList.length > 0) {

	                    icons.renderIcons(
	                        function (_eventKey) {
	                            var obj = {};
	                            obj.name = _eventKey;
	                            playerManager.dispatchEventToAdunit(obj);
	                        },
	                        function (clickUrl) {
	                            playerManager.click(clickUrl, false);
	                        },
	                        videojsAPI.player().el_,
	                        topMarginForIcon,
	                        bottomMarginForIcon,
	                        _currentTimeMsec,
	                        _videoDurationMsec);
	                }
	            });
	        }
	    };
	};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var prefixOfLog = "[AdIcon]";

	var utils = __webpack_require__(8);
	var APN_Logger = __webpack_require__(9);
	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};

	var AdIcon = function () {

	    var safetyPixel = 5;
	    var setContents = function (icons) {
	        for (var i = 0; i < icons.length; i++) {
	            var imageTypes = ["image/gif", "image/jpeg", "image/png"];
	            // var scriptTypes = ["application/x-javascript"];
	            var swfTypes = ["application/x-shockwave-flash"];
	            var icon = icons[i].StaticResource;//concerns about only static resource for first implementation
	            if (icon && icon.type) {

	                debug("setContents for " + icons[i].program);

	                var width = icons[i].width;
	                var height = icons[i].height;
	                if (imageTypes.indexOf(icon.type.toLowerCase()) >= 0) {
	                    icons[i].content = "<img src='" + icon.src + "' width='" + width + "' height='" + height + "'>";
	                }
	                // we will not create javascript static resource by a decision from Jeff Apr 19, 2017
	                // if (scriptTypes.indexOf(icon.type.toLowerCase()) >= 0) {
	                //     //static resource
	                //     icons[i].content = "<script src='" + icon.src + "'></script>";
	                //     //maybe we have to create iframe and inject script into it? but not in spec on IAB VAST3.0
	                // }
	                if (swfTypes.indexOf(icon.type.toLowerCase()) >= 0) {
	                    //static resource
	                    icons[i].content = "<object type='application/x-shockwave-flash' data='" + icon.src + "' width='" + width + "' height='" + height + "' style='width:" + width + ";height:" + height + ";'><param name='allowScriptAccess' value='always'><param name='allowNetworking' value='all'><param name='allowNetworking' value='all'><param name='mode' value='opaque'><param name='allowFullScreen' value='true'></object>";
	                }

	                icons[i].isDisplay = false;
	            }
	        }
	        return icons;
	    };

	    this.icons = [];

	    this.init = function (_icons) {
	        debug("initalize ad icon");
	        if (_icons) {
	            this.icons = setContents(_icons);
	        }
	    };

	    this.getIcons = function () {
	        return this.icons;
	    };

	    //concept of this method : IAB spec said the ad icon should be displayed when it's required by offset - no pre-cache allowed, so this method will create static resource when it's time to show
	    this.renderIcons = function (callbackForTracking, callbackForClickThrough, targetElement, _topMargin, _bottomMargin, currentTimeMsec, durationMsec) {

	        var icons = this.getIcons();
	        var that = this;

	        _bottomMargin = (_bottomMargin !== 0) ? _bottomMargin + safetyPixel : _bottomMargin;

	        if (!icons || icons.length < 1) {
	            return;
	        }

	        var handleClick = function (targetIcon) {
	            return function () {//to decouple closure situation
	                callbackForClickThrough(targetIcon.IconClickThrough);
	                callbackForTracking("IconClickTracking_" + targetIcon.program);
	                debug("fire IconClickTracking for " + targetIcon.program);
	            };
	        };

	        var handleCollision = function (icons) {
	            // if (currentTimeMsec <= durationMsec) {
	            //     that.resolveCollision(icons);
	            //     debug("start to check a collision of ad icon");
	            // }

	            setTimeout(function () {
	                that.resolveCollision(icons);
	                debug("start to check a collision of ad icon");
	            }, 500);

	        };

	        //start to handle multiple icons
	        var idx_icon;
	        for (idx_icon = 0; idx_icon < icons.length; idx_icon++) {
	            var targetIcon = icons[idx_icon];
	            var iconDuration;
	            var iconOffset;
	            var elem = targetIcon.htmlReference;

	            if (targetIcon) {
	                if (targetIcon.duration) {
	                    iconDuration = utils.getMsecTime(targetIcon.duration);
	                }
	                if (targetIcon.offset) {
	                    iconOffset = utils.getMsecTime(targetIcon.offset);
	                }
	            }

	            //reasons to skip showing
	            if (iconDuration <= 0) {
	                continue;
	            }

	            //reasons to skip showing
	            if (currentTimeMsec < iconOffset) {
	                continue;
	            }

	            if (currentTimeMsec === 0) {
	                continue;
	            }

	            //reason to hide whole ad icon
	            var idx_icon_hide;
	            if (durationMsec > 0 && currentTimeMsec >= durationMsec) {
	                for (idx_icon_hide = 0; idx_icon_hide < icons.length; idx_icon_hide++) {
	                    var targetIcon_hide = icons[idx_icon_hide];
	                    var elem_hide = targetIcon_hide.htmlReference;
	                    //hide icon
	                    if (elem_hide) {
	                        elem_hide.style.display = "none";
	                        targetIcon_hide.isDisplay = false;
	                    }
	                }
	                debug("hide whole ad icons because video is finished by " + currentTimeMsec + "ms");
	                return;
	            }

	            //reasons to hide ad icon
	            if ((currentTimeMsec > (iconOffset + iconDuration))) {
	                if (targetIcon.isDisplay) {
	                    //hide icon
	                    if (elem) {
	                        elem.style.display = "none";
	                        continue;
	                    }
	                }
	            }

	            //reasons to skip showing
	            if (targetIcon.isDisplay) {
	                continue;
	            }


	            ///start rendering icon


	            //position by offset
	            var xPosition = "left";//or right
	            var xPositionOffset = Number(xPositionOffset) < 0 ? 0 : xPositionOffset;
	            var yPosition = "top";//or bottom
	            var yPositionOffset = Number(xPositionOffset) < 0 ? 0 : xPositionOffset;
	            var topMargin = Number(_topMargin) > 0 ? _topMargin : 0;
	            var bottomMargin = Number(_bottomMargin) > 0 ? _bottomMargin : 0;

	            if (targetIcon && targetIcon.xPosition === "left") {
	                xPosition = "left";
	                xPositionOffset = 0;
	            }
	            if (targetIcon && targetIcon.xPosition === "right") {
	                xPosition = "right";
	                xPositionOffset = 0;
	            }
	            if (targetIcon && Number(targetIcon.xPosition) >= 0) {
	                xPosition = "left";
	                xPositionOffset = Number(targetIcon.xPosition);
	            }
	            if (targetIcon && targetIcon.yPosition === "bottom") {
	                yPosition = "bottom";
	                yPositionOffset = 0;
	                yPositionOffset = yPositionOffset + bottomMargin;
	            }
	            if (targetIcon && targetIcon.yPosition === "top") {
	                yPosition = "top";
	                yPositionOffset = 0;
	                yPositionOffset = yPositionOffset + topMargin;
	            }
	            if (targetIcon && Number(targetIcon.yPosition) >= 0) {
	                yPosition = "top";
	                yPositionOffset = Number(targetIcon.yPosition);
	                yPositionOffset = yPositionOffset + topMargin;
	            }

	            var displayIcon;
	            if (elem) {
	                displayIcon = elem;
	                debug("reuse ad icon for " + targetIcon.program);
	            } else {
	                displayIcon = targetElement.ownerDocument.createElement("div");
	                debug("create ad icon for " + targetIcon.program);
	            }

	            targetElement.appendChild(displayIcon);

	            displayIcon.setAttribute("name", "adicon");
	            displayIcon.id = "adicon_" + targetIcon.program;
	            displayIcon.innerHTML = targetIcon.content;
	            displayIcon.style.position = "fixed";
	            displayIcon.style.cursor = "hand";
	            displayIcon.style[xPosition] = xPositionOffset + "px";
	            displayIcon.style[yPosition] = yPositionOffset + "px";
	            displayIcon.style.zIndex = 2147483647;//top most of 32bit //VIDLA-802
	            displayIcon.style.display = "block";

	            //set width,height of div element for VIDLA-934
	            displayIcon.style.width = targetIcon.width + "px";
	            displayIcon.style.height = targetIcon.height + "px";

	            //if it's already displayed it deosn't need to be shown up again
	            targetIcon.isDisplay = true;
	            targetIcon.htmlReference = displayIcon;//store reference to reuse when it needs to be hide
	            targetIcon.document = targetElement.ownerDocument;//store target element
	            targetIcon.originalStyle = {};
	            targetIcon.originalStyle[xPosition] = xPositionOffset;
	            targetIcon.originalStyle[yPosition] = yPositionOffset;

	            //register click event
	            if (!targetIcon.clickRegisterd) {
	                displayIcon.addEventListener("click", handleClick(targetIcon));//get function reference to decouple clousure situation
	                targetIcon.clickRegisterd = true;
	                debug("ad icon click handler registered for " + targetIcon.program);
	            }

	            //make sure targetIcon saved on icons object
	            icons[idx_icon] = targetIcon;

	            //fire icon view tracking
	            if (callbackForTracking && typeof callbackForTracking === "function") {
	                callbackForTracking("IconViewTracking_" + targetIcon.program);
	                debug("check and fire IconViewTracking for " + targetIcon.program);
	            }

	            // if end of loop and all icon displayed
	            if (idx_icon === icons.length - 1) {
	                handleCollision(icons);
	            }

	        }//end for

	        //handleCollision(icons);

	    };

	    this.elementsFromPoint = function (x, y, _document) {
	        try {
	            //if there's native elementsFromPoint then use it
	            if (_document.elementsFromPoint) {
	                return _document.elementsFromPoint(x, y);
	            } else {
	                var parents = [];
	                var parent = void 0;
	                do {
	                    if (parent !== _document.elementFromPoint(x, y)) {
	                        parent = _document.elementFromPoint(x, y);
	                        parents.push(parent);
	                        if (parent && parent.style) {
	                            parent.style.pointerEvents = 'none';
	                        }
	                    } else {
	                        parent = false;
	                    }
	                } while (parent);
	                parents.forEach(function (parent) {
	                    var res;
	                    if (parent && parent.style) {
	                        res = parent.style.pointerEvents = 'all';
	                    }
	                    return res;
	                });
	                return parents;
	            }
	        } catch (ex) {
	            debug(ex);
	            return null;
	        }
	    };

	    var getIntFromPixel = function (str) {
	        var res = 0;

	        if (str && Number(str) >= 0) {
	            res = Number(str);
	        }
	        if (str && typeof(str) === "string" && str.toLowerCase() && str.indexOf("px")) {
	            res = Number(str.replace("px", ""));
	            res = (res > 0) ? res : 0;
	        }
	        return res;
	    };

	    //reposition to avoid collision of ad icons
	    this.resolveCollision = function (icons) {
	        var that = this;
	        var idx;

	        var checkOverlapped = function (elements, currentIcon) {
	            var idx;
	            for (idx = 0; idx < elements.length; idx++) {
	                var currentElement = elements[idx];
	                if (currentElement && currentElement.getAttribute("name") === "adicon" && currentIcon != currentElement) {
	                    var width = getIntFromPixel(currentElement.clientWidth);
	                    var height = getIntFromPixel(currentElement.clientHeight);

	                    var left = getIntFromPixel(currentElement.style.left);
	                    var right = getIntFromPixel(currentElement.style.right);

	                    return {result: true, width: width, height: height, left: left, right: right};
	                }
	            }

	            return {result: false, width: 0, height: 0, left: 0, right: 0};
	        };

	        var checkCollisionOnLeftOrRight = function (whichWay, left, right, top, bottom, width, height, _document, htmlReference) {

	            var next_left;
	            var next_right;

	            if (whichWay === "left") {
	                next_left = left - width - 1;
	                next_right = right - width - 1;
	            }

	            if (whichWay === "right") {
	                next_left = left + width + 1;
	                next_right = right + width + 1;
	            }

	            var allTopLeftElements = that.elementsFromPoint(next_left, top, _document);
	            var allTopRightElements = that.elementsFromPoint(next_right, top, _document);
	            var allBottomRightElements = that.elementsFromPoint(next_right, bottom, _document);
	            var allBottomLeftElements = that.elementsFromPoint(next_left, bottom, _document);

	            var newSpaceOwner_topLeft = checkOverlapped(allTopLeftElements, htmlReference);
	            var newSpaceOwner_topRight = checkOverlapped(allTopRightElements, htmlReference);
	            var newSpaceOwner_bootomRight = checkOverlapped(allBottomRightElements, htmlReference);
	            var newSpaceOwner_bootomLeft = checkOverlapped(allBottomLeftElements, htmlReference);

	            return {
	                newSpaceOwner_topLeft: newSpaceOwner_topLeft,
	                newSpaceOwner_topRight: newSpaceOwner_topRight,
	                newSpaceOwner_bootomRight: newSpaceOwner_bootomRight,
	                newSpaceOwner_bootomLeft: newSpaceOwner_bootomLeft,
	                next_left: next_left,
	                next_right: next_right
	            };

	        };

	        //start from seconds icon
	        for (idx = 1; idx < icons.length; idx++) {
	            var idxIcon = icons[idx];

	            if (idxIcon.htmlReference) {
	                var rectData = idxIcon.htmlReference.getBoundingClientRect();

	                var left = rectData.left;
	                var top = rectData.top;
	                var right = rectData.right;
	                var bottom = rectData.bottom;

	                var allTopLeftElements = that.elementsFromPoint(left, top, idxIcon.document);
	                var allTopRightElements = that.elementsFromPoint(right, top, idxIcon.document);
	                var allBottomRightElements = that.elementsFromPoint(right, bottom, idxIcon.document);
	                var allBottomLeftElements = that.elementsFromPoint(left, bottom, idxIcon.document);

	                var newSpaceOwner_topLeft = checkOverlapped(allTopLeftElements, idxIcon.htmlReference);
	                var newSpaceOwner_topRight = checkOverlapped(allTopRightElements, idxIcon.htmlReference);
	                var newSpaceOwner_bootomRight = checkOverlapped(allBottomRightElements, idxIcon.htmlReference);
	                var newSpaceOwner_bootomLeft = checkOverlapped(allBottomLeftElements, idxIcon.htmlReference);


	                var program = idxIcon.program;

	                //check for edge of icon is overlapped with another icon
	                if (newSpaceOwner_topLeft.result || newSpaceOwner_bootomRight.result || newSpaceOwner_topRight.result || newSpaceOwner_bootomLeft.result) {
	                    //if it's overllapped
	                    debug("collision detection starts for ad icon program - " + program);


	                    // debugger;
	                    var newSpaceWidth = newSpaceOwner_topLeft.width || newSpaceOwner_bootomRight.width || newSpaceOwner_topRight.width || newSpaceOwner_bootomLeft.width;
	                    var newSpaceHeight = newSpaceOwner_topLeft.height || newSpaceOwner_bootomRight.height || newSpaceOwner_topRight.height || newSpaceOwner_bootomLeft.height;
	                    // var newSpaceRight = newSpaceOwner_topLeft.right || newSpaceOwner_bootomRight.right || newSpaceOwner_topRight.right || newSpaceOwner_bootomLeft.right;
	                    var newSpaceLeft = newSpaceOwner_topLeft.left || newSpaceOwner_bootomRight.left || newSpaceOwner_topRight.left || newSpaceOwner_bootomLeft.left;

	                    newSpaceWidth = newSpaceWidth + newSpaceLeft;

	                    var collisionResolved = false;

	                    ////////////////////////////////////////////////////////////
	                    //try move icon to left
	                    ////////////////////////////////////////////////////////////
	                    var res = checkCollisionOnLeftOrRight("left", left, right, top, bottom, newSpaceWidth, newSpaceHeight, idxIcon.document, idxIcon.htmlReference);
	                    //if no collision on candidate space
	                    if (collisionResolved === false && res.newSpaceOwner_topLeft.result === false && res.newSpaceOwner_topRight.result === false && res.newSpaceOwner_bootomRight.result === false && res.newSpaceOwner_bootomLeft.result === false && res.next_left >= 0) {

	                        debug("collision resolved by moving icon to left for ad icon program - " + program);
	                        idxIcon.htmlReference.style.left = res.next_left + "px";//add 1px space for look&feel
	                        collisionResolved = true;
	                    }

	                    ////////////////////////////////////////////////////////////
	                    //try move icon to right
	                    ////////////////////////////////////////////////////////////
	                    res = checkCollisionOnLeftOrRight("right", left, right, top, bottom, newSpaceWidth, newSpaceHeight, idxIcon.document, idxIcon.htmlReference);
	                    //if no collision on candidate space
	                    if (collisionResolved === false && res.newSpaceOwner_topLeft.result === false && res.newSpaceOwner_topRight.result === false && res.newSpaceOwner_bootomRight.result === false && res.newSpaceOwner_bootomLeft.result === false) {
	                        debug("collision resolved by moving icon to right for ad icon program - " + program);
	                        idxIcon.htmlReference.style.left = res.next_left + "px";//add 1px space for look&feel
	                        collisionResolved = true;
	                    }


	                    //if no way to avoid collision hide it.
	                    if (collisionResolved === false) {
	                        debug("hide ad-icon due to no way to avoid collision for ad icon program - " + program);
	                        idxIcon.htmlReference.style.display = "none";
	                    }


	                    debug("collision detection end for ad icon program - " + program);


	                }

	            }


	        }

	    };

	    //redraw adicon for having dynamic position
	    this.redraw = function (offsetHeight) {
	        // debug("start reposition");
	        // debug("offsetHeight: " + offsetHeight);

	        var idx;
	        for (idx = 0; idx < this.icons.length; idx++) {
	            var icon = this.icons[idx];
	            var iconElement = icon.htmlReference;
	            var position = icon.originalStyle;

	            if (position) {
	                var bottom = position["bottom"];

	                //check only bottom margin to be dynamic position with bottom control bar
	                if (bottom || bottom === 0) {
	                    if (bottom === "bottom") {
	                        bottom = 0;
	                    }
	                    iconElement.style.bottom = (bottom + offsetHeight) + "px";
	                }

	            }

	        }
	        // debug("end reposition");
	    };


	};
	module.exports = AdIcon;



/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var _logger = __webpack_require__(9);

	var debug = function (message) {
	    _logger.debug("Video Player: " + message);
	};

	module.exports = function (html5PlayerSelf) {

	    debug('init: displayVolumeControls');

	    return {
	        "displayVolumeControls": function () {
	            if (html5PlayerSelf.isAndroid()) {
	                if (typeof html5PlayerSelf.options.enableAndroidVolumeControls === "boolean" && html5PlayerSelf.options.enableAndroidVolumeControls === true) {
	                    return true;
	                } else {
	                    return false;
	                }
	            } else {
	                return true;
	            }
	        }
	    };

	    
	};



/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var APN_InlineVideoPlayerForiOS = __webpack_require__(37);//new inline video player which is rendering a video signal into canvas and generating audio and sync with video
	var utils = __webpack_require__(8);
	var _logger = __webpack_require__(9);
	var debug = function (message) {
	    _logger.debug("iOSInlineVideoPlayer: " + message);
	};

	var error = function (message) {
	    _logger.error("iOSInlineVideoPlayer: " + message);
	};

	/**
	 * This module adopts new inline video player for iOS version 8 and 9 for iphone and ipad, no gurranted to be used in other OS and other version.
	 *
	 * the player will be genrated by using "new" keyword to support multiple instance,
	 * the player will be injected into a div which is inside video.js area in the screen
	 * this module generates html5 video as usual as our framework did in AdVideoPlayerHtml5.js,
	 * but the video object will be passed to the inline player to be used as a source of video frame capturing
	 *
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 */
	var iOSInlineVideoPlayer = function (playerManager, cbInjectEventToPlayer) {

	    var iOSInlinePlayerSelf = this;

	    this.options = playerManager.options;//getting required object from adVideoPlayerManager
	    this.topChromeHeight = 24;
	    this.iOSVideoPlayer = new APN_InlineVideoPlayerForiOS();
	    this.videojsOrigin = playerManager.videoPlayerObj;
	    this.dispatchEventToAdunit = playerManager.dispatchEventToAdunit.bind(playerManager);
	    this.callbackForAdUnit = playerManager.callbackForAdUnit;
	    this.UUID = new Date().getTime() + Math.floor(Math.random() * 10000);

	    var divIdForVideo = "an_video_ad_player_" + iOSInlinePlayerSelf.UUID;
	    var videoId = "an_video_ad_player_" + iOSInlinePlayerSelf.UUID + "_html5_api";

	    this.an_video_ad_player_id = divIdForVideo;
	    this.an_video_ad_player_html5_api_id = videoId;

	    //keep div id and video id for playerManager
	    playerManager.divIdForVideo = divIdForVideo;
	    playerManager.videoId = videoId;

	    this.refreshVideoLookAndFeel = utils.refreshVideoLookAndFeel;
	    this.shouldConsiderHeightOfDevice = true;
	    this.isDoneiOSInitialPlay = false;
	    this.isTogglePaused = false;
	    this.enabledAudio = false;//flag to enable audio (one time action)
	    this.isFullscreen = false;
	    this.enableFullscreen = true;//add custom fullscreeen icon
	    this.fromFullscreen = false;
	    this.isAlreadyDoneVideoComplete = false;
	    this.customPlayToggle = {};
	    this.customFullscreenBtn = {};
	    this.eventSizeChange = {};//event id for size change when addressbar appears
	    this.eventOrientationChange = {};//event id for orientation change
	    this.floatingAdIndicator = null;
	    this.floatingSkipButton = null;
	    this.floatingAdSkipText = null;
	    this.readyForSkip = false;
	    this.videojsPlayer = null;

	    //loading module with injecting a dependancy
	    var EmulateHtml5Video = __webpack_require__(38)(iOSInlinePlayerSelf,playerManager);
	    var Events = __webpack_require__(39)(iOSInlinePlayerSelf,playerManager, cbInjectEventToPlayer);
	    var InitializeElements = __webpack_require__(41)(iOSInlinePlayerSelf,playerManager);

	    //interfaces
	    this.createIframeAndRequiredObject = InitializeElements.createIframeAndRequiredObject;
	    this.fnMainProcess = Events.fnMainProcess;
	    this.handleFullScreen = EmulateHtml5Video.handleFullScreen;
	    this.handleNormalScreen = EmulateHtml5Video.handleNormalScreen;
	    this.resizeIosCanvas = EmulateHtml5Video.resizeIosCanvas;
	    this.cbWhenVideoComplete = EmulateHtml5Video.cbWhenVideoComplete;

	    this.savedBackgroundForBottomBar = "";
	    this.savedBackgroundColorForBottomBar = "";


	    this.start = function() {
	        debug("start");

	        //test interface
	        if (iOSInlinePlayerSelf.test() === false) {
	            error("initialize error");
	            return;
	        }

	        var UID = new Date().getTime() + Math.floor(Math.random() * 10000);//define iframe's uniqueu id
	        iOSInlinePlayerSelf.options.iframeVideoWrapperId = "iframeVideoWrapper_" + UID;
	        iOSInlinePlayerSelf.options.techOrder = ["html5"];//force to use html5 for video.js because flash will be handled by diffrent swf owned by us
	        iOSInlinePlayerSelf.createIframeAndRequiredObject(iOSInlinePlayerSelf.fnMainProcess);//invoke method with a parameter defined next execution.
	    };

	    this.test = function() {
	        if (this.createIframeAndRequiredObject && this.fnMainProcess && this.handleFullScreen && this.handleNormalScreen && this.resizeIosCanvas && this.cbWhenVideoComplete) {
	            return true;
	        } else {
	            return false;
	        }
	    };




	};
	module.exports = iOSInlineVideoPlayer;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	//Inline video player module for iOS by kyungsuk (ksong@appnexus.com)
	/*
	 This player code includes following items.

	 0. Inline video in iPhone instead of native fullscreen
	 1. No AJAX call for audio and video
	 2. Using javascript only
	 3. Sync with audio
	 4. Multiple instance
	 5. Adjustable fullscreen instead of native one
	 6. Support Safari mobile browser of iOS8, iOS9 (phone / tablet)
	 */
	var _logger = __webpack_require__(9);
	var log = function (message) {
	    _logger.log("iOSInlineVideoPlayer: " + message);
	};
	var debug = function (message) {
	    _logger.debug("iOSInlineVideoPlayer :: iOSInlineCore: " + message);
	};
	var verbose = function (message) {
	    _logger.verbose("iOSInlineVideoPlayer :: iOSInlineCore: " + message);
	};



	/**
	 * Javascript class for Inline Video Player for iOS (this class should be instiantiated by using new keyword)
	 * @constructor
	 */
	var APN_InlineVideoPlayerForiOS = function () {

	    //major required html5 object
	    var canvas;//html5 canvas object to render video signal
	    var video;//html5 video object to capture video signal
	    var videoSource;//source object to be injected into video object
	    var audio;//html5 audio object to sound
	    var audioSource;//source object to be injected into audio object
	    var mediaUrl;//media url to be used by video
	    var canvasContext;//2d context(surface) to render video


	    //major flags
	    var lastTime;//time to get lasttime
	    var handleAnimation;//reference of loop for requestAnimation
	    var framesPerSecond;//define frame rate
	    var isAudioStarted;
	    var canvasPause;//flag to pause video/audio
	    var isAudioMute;//if it's false player start sync with audio and video
	    var initialSyncValue;//const variable to define initial sync gap. if gap of time between audio and video exceed this value, player resync video to have same position with audio (audio's always playing without changing position)
	    var initialSyncValueAfter;//same with initialSyncValue, but initialSyncValue value will use only one time at the first synchronization
	    var videoAspectRatio;//variable to keep video aspect ratio this will have real width & height of video after got metadata from video asset
	    var isAudioCreated;//flag to block to generate audio tag over twice
	    var isFullscreen;
	    var limitSyncValue;
	    var cbWhenVideoComplete;
	    var isTerminated = false;
	    var isRunningForCanvas = false;
	    var previousLoopIndex = 0;//for keeping current loop index to get difference between current and previous one. this will be used as elapsed time to increase video timeline

	    //areas
	    var divArea;//div element to render this player
	    var targetElement;//div element of Outstream
	    var cssTextOf_targetElement;//keep css of targetElement
	    var iframeVideoWrapper;//reference for iframe that video.js generates
	    var cssTextOf_iframeVideoWrapper;//css text to keep orignal value of iframeVideoWrapper
	    var el_wholeArea;//first div in iframe
	    var cssTextOf_el_wholeArea;//css text to keep orignal value of el_wholeArea
	    var cssTextOf_canvas;//css text to keep orignal value of canvas
	    var cbTimeUpdate;

	    var pubOptions;

	    //const
	    var heightOfToolbar = 30;//height of toolbar which will be added to video area. this is required to show whole area of video with controlbar

	    /**
	     * status object to keep original value
	     * @type {{keepWidth: null, keepHeight: null}}
	     */
	    var status = {
	        keepWidth: null, keepHeight: null
	    };

	    this.setPubOptions = function (options) {
	        pubOptions = options;
	    };

	    /**
	     * check if it's mobile
	     * @returns {boolean}
	     */
	    var isWorkableDeviceForInlineVideo = function () {
	        var index = navigator.appVersion.indexOf("Mobile");
	        return (index > -1);
	    };


	    /**
	     * external interface : render & prepare a video,canvas,audio reference. audio will be set when user click "unmute"
	     * @param options
	     * @param callback
	     */
	    this.renderVideo = function (options, callback) {

	        log("renderVideo");

	        if (!isWorkableDeviceForInlineVideo()) {
	            callback(false);
	            return;
	        }

	        cbTimeUpdate = options.cbTimeUpdate;
	        mediaUrl = options.mediaUrl;
	        divArea = options.divArea;
	        cbWhenVideoComplete = options.cbWhenVideoComplete;

	        //binding reference of elements
	        targetElement = options.targetElement;
	        iframeVideoWrapper = options.iframeVideoWrapper;
	        el_wholeArea = options.el_wholeArea;


	        //generate intial object
	        verbose("generating initial canvas object");
	        canvas = document.createElement("canvas");
	        divArea.appendChild(canvas);
	        divArea.style.width = "100%";//to fix alignment issue in normall screen if it's vpaid
	        divArea.style.height = "100%";


	        status.keepWidth = canvas.style.width;
	        status.keepHeight = canvas.style.height;


	        if (typeof options.videoElement !== "undefined") {
	            video = options.videoElement;
	        } else {
	            //create and inject video tag
	            verbose("creating video tag");
	            video = document.createElement("video");
	            videoSource = document.createElement("source");
	            video.style.display = "none";
	            video.autoplay = false;
	            video.preload = "auto";
	            video.controls = true;
	            videoSource.src = mediaUrl;//it will be replace if it's JSVPAID and when VPAID returns adStarted
	            video.appendChild(videoSource);

	            //inject video to divArea
	            divArea.appendChild(video);
	        }


	        //preparing audio tag but not render it
	        verbose("preparing audio tag");
	        audio = document.createElement("audio");
	        audioSource = document.createElement("source");

	        if (pubOptions.preloadInlineAudioForIos && !pubOptions.vpaid) {//vpaid will invoke this at playerHtml5Ios.js
	            this.activateAudio();
	        }


	        //getting context from canvas
	        canvasContext = canvas.getContext('2d');

	        lastTime = Date.now();//time to get lasttime
	        framesPerSecond = 35;//define frame rate
	        isAudioStarted = false;
	        canvasPause = false;
	        isAudioMute = true;
	        initialSyncValue = 0.3;
	        initialSyncValueAfter = 0.3;
	        videoAspectRatio = 0.1;
	        isAudioCreated = false;//flag to verfiy audio is already generated
	        isFullscreen = false;
	        limitSyncValue = 99999999;//if gap has bigger value than this, it won't be synchroinized

	        verbose("renderVideo callback");
	        callback(true);


	    };

	    //new logic for storing css this will store only required value
	    var saveCSS = function (targetElement) {
	        verbose("saveCSS");
	        var result = {};
	        var cssStorage = {position: "", width: "", height: "", top: "", left: "", marginRight: "", transform: "", background: ""};//only this attributes will be handled by save/load css method
	        for (var el in cssStorage) {
	            result[el] = targetElement.style[el];
	        }
	        return result;
	    };

	    //new logic for load CSS this will load only required value
	    var loadCSS = function (targetElement, storedCSSObject) {
	        verbose("loadCSS");
	        for (var el in storedCSSObject) {
	            targetElement.style[el] = storedCSSObject[el];
	        }
	    };

	    var getCalculatedWidthHeight = function (isFullscreen) {
	        //this is in a constant loop so I am commenting it out
	        //verbose("getCalculatedWidthHeight");
	        var aspectRatio = video.videoWidth / video.videoHeight;
	        var calculatedWidth = 0;
	        var calculatedHeight = 0;


	        if (!isFullscreen) {
	            var isSideStreamActivated = pubOptions.sideStream && pubOptions.sideStream.enabled && pubOptions.sideStreamObject && pubOptions.sideStreamObject.isActivated;
	            if (isSideStreamActivated) {

	                //for VID-2144
	                var frameWidth = pubOptions.sideStream.width;
	                var frameHeight = pubOptions.sideStream.height;
	                var width;
	                var height;
	                var topOffset = 0;
	                var bottomOffset = 30; //iOS alwasys need topBar

	                if (!pubOptions.disableTopBar) {
	                    topOffset = 24; //default height for topBar
	                }
	                frameHeight = frameHeight - (bottomOffset + topOffset);//consider topbar and controlBar size

	                if (!frameWidth && !frameHeight) {//using default value if sideStream doesn't have width,height
	                    frameWidth = pubOptions.width;
	                    frameHeight = pubOptions.mediaHeight;
	                }

	                if (frameWidth && frameHeight) {
	                    width = frameWidth;
	                    height = frameHeight;
	                } else {
	                    width = frameWidth ? frameWidth : frameHeight / aspectRatio;
	                    height = frameHeight ? frameHeight : frameWidth / aspectRatio;
	                }
	                calculatedWidth = Math.round(Math.min((height) * aspectRatio, width));
	                calculatedHeight = Math.round(Math.min(width / aspectRatio, height));
	            } else {
	                calculatedWidth = Math.round(Math.min((pubOptions.mediaHeight) * aspectRatio, pubOptions.width));
	                calculatedHeight = Math.round(Math.min(pubOptions.width / aspectRatio, pubOptions.mediaHeight));
	            }

	        } else {
	            //fullscreen case
	            calculatedWidth = window.innerWidth;
	            calculatedHeight = Math.round(window.innerWidth / aspectRatio);
	        }

	        //this is in a constant loop so I'm commenting it out
	        //verbose("calculated width: " + calculatedWidth + ", calculated height: " + calculatedHeight);
	        return {"width": calculatedWidth, "height": calculatedHeight};
	    };

	    var getStartXY = function (isFullscreen) {
	        //this is in a constant loop so I'm commenting it out
	        //verbose("getStartXY");

	        var startX = 0;
	        var startY = 0;

	        if (!isFullscreen) {
	            startX = 0;
	            startY = Math.abs(pubOptions.mediaHeight - getCalculatedWidthHeight(isFullscreen).height) / 2;
	        }

	        return {"x": startX, "y": startY};
	    };

	    var resizeCanvas = function (isFullscreen) {
	        //this is in a constant loop so I'm commenting it out
	        //verbose("resizeCanvas");

	        var calculatedWidth = getCalculatedWidthHeight(isFullscreen).width;
	        var calculatedHeight = getCalculatedWidthHeight(isFullscreen).height;

	        if (!isFullscreen) {
	            canvas.width = calculatedWidth;
	            canvas.height = pubOptions.mediaHeight;
	        } else {
	            canvas.width = calculatedWidth;
	            canvas.height = calculatedHeight;
	        }
	    };

	    var redrawCanvas = function (isFullscreen) {

	        var startX = getStartXY(isFullscreen).x;
	        var startY = getStartXY(isFullscreen).y;
	        var calculatedWidth = getCalculatedWidthHeight(isFullscreen).width;
	        var calculatedHeight = getCalculatedWidthHeight(isFullscreen).height;

	        if (!isFullscreen) {
	            canvasContext.drawImage(video, startX, startY, calculatedWidth, calculatedHeight);
	        } else {
	            canvasContext.drawImage(video, 0, 0, calculatedWidth, calculatedHeight);
	        }
	    };

	    //render 1 key frame of video
	    var renderVideoIntoCanvas = function (videoForwardOffset) {

	        var gap = 0;


	        //debug
	        //top.window.document.getElementsByName("debug")[1].innerHTML = video.currentTime + "<br>" + previousLoopIndex + "<br>" + videoForwardOffset;

	        //forcely advanced key-frame of video by manual tick
	        video.currentTime = video.currentTime + videoForwardOffset;

	        var calculatedWidth = getCalculatedWidthHeight(isFullscreen).width;
	        var calculatedHeight = getCalculatedWidthHeight(isFullscreen).height;
	        var startX = getStartXY(isFullscreen).x;
	        var startY = getStartXY(isFullscreen).y;

	        resizeCanvas(isFullscreen);

	        //time gap between audio and video's key-frame(currentTime)
	        gap = Math.abs(audio.currentTime - video.currentTime);

	        //this will be start after user click un-mute to generate audio tag in the background
	        if (isAudioMute === false) {
	            //resync if exceed over x seconds
	            if (gap >= initialSyncValue && gap <= limitSyncValue) {
	                //synchorinize key-frame of video to match with audio's key-frame
	                video.currentTime = audio.currentTime + videoForwardOffset;
	            }
	        }

	        //render video signal to canvas
	        if (!isFullscreen) {
	            canvasContext.drawImage(video, startX, startY, calculatedWidth, calculatedHeight);
	        } else {
	            canvasContext.drawImage(video, 0, 0, calculatedWidth, calculatedHeight);
	        }
	        cbTimeUpdate();
	    };


	    /**
	     * render video and sync with audio, this method force to advance key-frame by time-based, and render video signal into canvas
	     * time gap between audio and video calculates every time, and if the gap will exceed over specific value, video will have new key-frame of audio's current playing.
	     * @param currentLoopIndex
	     */
	    function renderingLoop(currentLoopIndex) {//the currentLoopIndex will keep increasing from 0 ms after window is rendered regardless calling of this method. window.requestAnimationFrame will keep passing milliseconds from 0 as a currentLoopIndex parameter, the time tick is based on a device and browser, normally iOS will fire this loop every about 10ms but it's depending on device's capability. if it's under 100ms the video will look smooth.

	        var videoForwardOffset = 0;//a value for increasing currentTime of video element


	        var gapOfIndexs = currentLoopIndex - previousLoopIndex;
	        var peakOfGapMilliSeconds = 500;//if gapOfIndex is greater than this variable it will be ignored to have proper pause/resume status
	        isRunningForCanvas = true;

	        if (previousLoopIndex === 0 || gapOfIndexs > peakOfGapMilliSeconds) {
	            //if this loop's first time will use 0 because requestAnimationFrame will return currentLoopIndex as some number greater than 0 based on when this page is rendered.
	            videoForwardOffset = 0;
	        } else {
	            videoForwardOffset = gapOfIndexs;//get difference between current and previous index
	        }

	        previousLoopIndex = currentLoopIndex;//keep current index
	        videoForwardOffset = videoForwardOffset / 1000;//convert index to second

	        renderVideoIntoCanvas(videoForwardOffset);//actual video rendring

	        var currentTime = video.currentTime;//allow to have decimals to precisely calculate
	        var duration = video.duration;//allow to have decimals to precisely calculate

	        //complete when audio and video both finished
	        if (currentTime >= duration) {
	            verbose("close checking by iOSInlinePlayer");
	            if (isAudioMute === false) {//when unmute a logic should check audio completion even if the video completed
	                var currentTimeOfAudio = audio.currentTime;
	                var durationOfAudio = audio.duration;
	                if (currentTimeOfAudio >= durationOfAudio) {
	                    verbose("closed with audio by iOSInlinePlayer");
	                    cbWhenVideoComplete();
	                    isRunningForCanvas = false;//not allowing to re-enter this loop
	                    window.cancelAnimationFrame(handleAnimation);
	                    return;
	                }
	            } else {
	                verbose("closed by iOSInlinePlayer");
	                cbWhenVideoComplete();
	                isRunningForCanvas = false;//not allowing to re-enter this loop
	                window.cancelAnimationFrame(handleAnimation);
	                return;
	            }
	        }

	        //if canvasPause is false, cavas animation will start until it set to true, pause/resume will work like that
	        if (canvasPause === false) {
	            handleAnimation = window.requestAnimationFrame(renderingLoop);
	        } else {
	            isRunningForCanvas = false;
	            window.cancelAnimationFrame(handleAnimation);
	        }

	    }

	    /**
	     * check screen is under portrait mode.
	     * @returns {boolean}
	     */
	    var isPortrait = function () {
	        return window.innerHeight > window.innerWidth;//check viewport is portrait state
	    };


	    /**
	     * check exit fullscreen in iPhone
	     */
	    var onVideoEndsFullScreen = function () {
	        this.resumeVideo();
	    };
	    /**
	     * calculate height to remain aspect ratio of video's
	     * @returns {{width: number, height: number}}
	     */
	    var getSizeOfVideoArea = function (isPortrait) {

	        //var windowWidth = window.document.body.clientWidth;
	        var windowWidth = window.innerWidth;
	        var windowHeight = 0;

	        windowHeight = window.innerHeight;//height considering iOS's addressbar
	        windowHeight = window.innerHeight;


	        var height;
	        var width;
	        var top;
	        var left;

	        //comment out some video having specfic aspectratio like 4:3 it will be broken in the fullscreen
	        if (!isPortrait) {

	            if (!isFullscreen) {
	                //for normal screen

	                //TODO hava a diffrent size matched with aspec ration of video
	                //height = windowHeight - heightOfToolbar;
	                //width = Math.round(height * videoAspectRatio);
	                //top = 0;
	                //left = Math.round((windowWidth / 2) - (width / 2));//calculate middle position

	                //TODO to have a same size of window in landscape mode
	                //width = windowWidth;
	                //height = windowHeight - heightOfToolbar;
	                //top = 0;
	                //left = Math.round((windowWidth / 2) - (width / 2));//calculate middle position


	                //TODO supporting iPAD
	                width = windowWidth;
	                height = pubOptions.height;

	                if (height >= windowHeight) {
	                    height = windowHeight - heightOfToolbar;
	                    top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
	                    left = 0;
	                } else {
	                    top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
	                    left = 0;
	                }
	            } else {
	                //for fullscreen
	                //TODO supporting iPAD
	                width = windowWidth;
	                height = Math.round(width / videoAspectRatio);

	                if (height >= windowHeight) {
	                    height = windowHeight - heightOfToolbar;
	                    width = Math.round(height * videoAspectRatio);
	                    top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
	                    left = Math.round((windowWidth / 2) - (width / 2));//calculate middle position
	                } else {
	                    height = height - heightOfToolbar;
	                    top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
	                    left = 0;
	                }


	            }


	        } else {

	            //portrait mode
	            if (!isFullscreen) {
	                //normal screen
	                width = windowWidth;
	                //height = pubOptions.height - heightOfToolbar;
	                height = pubOptions.mediaHeight;
	                top = Math.round((windowHeight / 2)) + 100;//calculate middle position
	                left = 0;
	            } else {
	                //fullscreen
	                width = windowWidth;
	                height = Math.round(windowWidth / videoAspectRatio);
	                top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
	                left = 0;
	            }


	        }


	        //debug("*** : " + width + "," + height + "," + top + "," + left);


	        return {
	            "width": width,
	            "height": height,
	            "top": top,
	            "left": left
	        };
	    };

	    /**
	     * make fulll screen background. html5 fullscreen api doesn't work since iOS8 also has some problem inside of iframe, so it needs to be improved
	     */
	    var makeBackgroundScreen = function () {


	        targetElement.style.backgroundColor = "black";
	        targetElement.style.width = "100%";
	        targetElement.style.height = "100%";
	        targetElement.style.position = "fixed";
	        //targetElement.style.position = "absolute";
	        targetElement.style.top = "0px";
	        targetElement.style.left = "0px";
	        targetElement.style.zIndex = "999999";
	        targetElement.style.background = "rgba(0,0,0,1)";

	        targetElement.style.transition = "height 0s ease";

	        //make background transparent
	        el_wholeArea.style.background = "rgba(0,0,0,1)";
	        canvas.style.background = "rgba(0,0,0,1)";
	        iframeVideoWrapper.style.background = "rgba(0,0,0,1)";


	    };

	    /**
	     * hide background and rolling back css kept
	     */
	    var hideBackgroundScreen = function () {
	        //targetElement.style.cssText = cssTextOf_targetElement;
	        loadCSS(targetElement, cssTextOf_targetElement);

	        targetElement.style.height = getSizeOfVideoArea().height + "px";
	    };


	    /**
	     * start video for initial play
	     * @param e
	     */
	    var handleMetadata = function (e) {
	        videoAspectRatio = e.target.videoWidth / e.target.videoHeight;
	    };


	    var resizeFullscreenConsideringRotation = function () {

	        var isPortrait_ = isPortrait();
	        var sizeObject = getSizeOfVideoArea(isPortrait_);

	        var width = sizeObject.width;
	        var height = sizeObject.height;
	        var top = sizeObject.top;
	        var left = sizeObject.left;

	        //video in canvas can't have automatic flexible size becuase it's painted as a pixel(x,y) so need to recalculate size of video whenever rotation changed
	        iframeVideoWrapper.style.position = "absolute";
	        iframeVideoWrapper.style.width = width;
	        iframeVideoWrapper.style.height = height;
	        iframeVideoWrapper.style.top = top + "px";
	        iframeVideoWrapper.style.left = left + "px";

	        iframeVideoWrapper.style.marginRight = "";
	        iframeVideoWrapper.style.transform = "";

	        //change size for div under iframe
	        el_wholeArea.style.width = width + "px";
	        el_wholeArea.style.height = height + heightOfToolbar + "px";


	        //change size for canvase
	        canvas.style.width = width + "px";
	        canvas.style.height = height + "px";

	        //for VID-1903
	        el_wholeArea.style.marginLeft = "";
	        el_wholeArea.style.marginRight = "";


	    };


	    var _exitFullscreeenAsCanvas = function () {
	        //set full screen flag to avoid to enter resize for fullscreen when rotation change
	        isFullscreen = false;

	        //to release scroll in fullscreen
	        targetElement.ontouchmove = function () {
	            return true;
	        };
	        canvas.ontouchmove = function () {
	            return true;
	        };
	        el_wholeArea.ontouchmove = function () {
	            return true;
	        };


	        hideBackgroundScreen();

	        //rolback css attribute to original one
	        loadCSS(targetElement, cssTextOf_targetElement);
	        loadCSS(iframeVideoWrapper, cssTextOf_iframeVideoWrapper);
	        loadCSS(el_wholeArea, cssTextOf_el_wholeArea);
	        loadCSS(canvas, cssTextOf_canvas);
	    };


	    /**
	     * external interface : exit out of fullscreen
	     */
	    this.exitFullscreeenAsCanvas = function () {
	        _exitFullscreeenAsCanvas();
	    };


	    /**
	     * external interface : enter full screen (actually draw div layer to have 100% width and height) //TODO need to have
	     */
	    this.enterFullscreenAsCanvas = function () {

	        //to avoid scroll in fullscreen
	        targetElement.ontouchmove = function () {
	            return false;
	        };
	        canvas.ontouchmove = function () {
	            return false;
	        };
	        el_wholeArea.ontouchmove = function () {
	            return false;
	        };


	        //store original css attributes
	        cssTextOf_targetElement = saveCSS(targetElement);
	        cssTextOf_iframeVideoWrapper = saveCSS(iframeVideoWrapper);
	        cssTextOf_el_wholeArea = saveCSS(el_wholeArea);
	        cssTextOf_canvas = saveCSS(canvas);

	        //fix VID-2240
	        targetElement.style.marginLeft = "0px";
	        targetElement.style.marginRight = "0px";
	        targetElement.style.marginTop = "0px";
	        targetElement.style.marginBottom = "0px";


	        isFullscreen = true;
	        makeBackgroundScreen();


	        resizeFullscreenConsideringRotation();


	    };

	    /**
	     * external interface to playce intial play
	     */
	    this.initialPlay = function (enabledAudio) {
	        this.play(enabledAudio);
	    };

	    this.play = function(enabledAudio) {
	        if (!isRunningForCanvas) {
	            canvasPause = false;
	            if (enabledAudio && audio && audio.play) {
	                audio.play();
	            }
	            handleAnimation = window.requestAnimationFrame(renderingLoop);
	        }
	    };

	    /**
	     * external interface to resume video
	     */
	    this.resumeVideo = function () {
	        canvasPause = false;
	        if (audio && audio.play) {
	            audio.play();
	        }
	        handleAnimation = window.requestAnimationFrame(renderingLoop);
	    };

	    /**
	     * external interface to pause video
	     */
	    this.pauseVideo = function () {
	        canvasPause = true;
	        audio.pause();
	        window.cancelAnimationFrame(handleAnimation);
	        isRunningForCanvas = false;
	    };


	    this.activateAudio = function () {
	        debug("activateAudio : " + video.src);

	        //activate audio
	        audio.style.display = "none";
	        audio.autoplay = false;
	        audio.preload = "auto";
	        audio.controls = true;
	        audioSource.src = video.src;//this should be required for vpaid

	        audio.appendChild(audioSource);
	        divArea.appendChild(audio);//this should be required for preload audio

	        audio.load();
	    };

	    /**
	     * external inrerface to activate audio
	     */
	    this.hearAudio = function () {//play audio should be started by human activity

	        //don't need to re-create audio tag if it's already there.
	        if (isAudioCreated) {
	            debug("resume audio");
	            isAudioMute = false;
	            audio.currentTime = video.currentTime;//first sync between audio and video
	            if (!canvasPause) { // if video paused wait until resume to play audio
	                audio.play();
	            }
	            return;
	        }

	        audio.addEventListener("playing", function () {
	            debug("first playing audio");
	            audio.currentTime = video.currentTime + initialSyncValue;
	            isAudioMute = false;
	            isAudioCreated = true;
	        });

	        if (pubOptions.preloadInlineAudioForIos === false) {//if it's already loaded doesn't need to load again
	            this.activateAudio();
	        }
	        audio.currentTime = video.currentTime;//first sync between audio and video
	        if (!canvasPause) { // if video paused wait until resume to play audio
	            audio.play();
	        }
	    };

	    /**
	     * kill the audio instance
	     */
	    this.stopAudio = function () {
	        debug("pausing audio");
	        audio.pause();
	        isAudioMute = true;
	    };

	    /**
	     * external interface to resize when orientation changed
	     */
	    this.checkOrientation = function () {

	        if (isTerminated && !pubOptions.disableCollapse.enabled) {
	            return;
	        }

	        if (!isFullscreen) {
	            //normal screen
	            resizeCanvas(isFullscreen);
	            redrawCanvas(isFullscreen);


	        } else {
	            //fullscreen
	            //_exitFullscreeenAsCanvas();
	            hideBackgroundScreen();
	            makeBackgroundScreen();
	            resizeFullscreenConsideringRotation();
	        }
	    };


	    /**
	     * external interface to intialize and initiate rendering
	     */
	    this.initiate = function () {
	        video.addEventListener("canplaythrough", handleMetadata.bind(this));//handle metadata to set aspectratio
	        video.addEventListener('webkitendfullscreen', onVideoEndsFullScreen, false);

	        //preload
	        video.load();
	        video.pause();
	    };


	    /**
	     * external interface to return canvas object to define click-to-browseout event
	     * @returns {object}
	     */
	    this.getCanvas = function () {
	        return canvas;
	    };


	    this.destroy = function () {

	        window.cancelAnimationFrame(handleAnimation);//stop animation loop

	        if (isFullscreen) {
	            _exitFullscreeenAsCanvas();
	        }

	        isTerminated = true;


	    };

	    this.resizeCanvas = resizeCanvas;

	    this.redrawCanvas = redrawCanvas;


	};
	module.exports = APN_InlineVideoPlayerForiOS;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(8);
	var _logger = __webpack_require__(9);
	var debug = function (message) {
	    _logger.debug("iOSInlineVideoPlayer :: EmulateHtml5Video: " + message);
	};
	var verbose = function (message) {
	    _logger.verbose("iOSInlineVideoPlayer :: EmulateHtml5Video: " + message);
	};


	/**
	 * EmulateHtml5Video
	 * @param iOSInlinePlayerSelf
	 * @param playerManager
	 * @returns {{handleFullScreen: "handleFullScreen", handleNormalScreen: "handleNormalScreen", resizeIosCanvas: "resizeIosCanvas", cbWhenVideoComplete: "cbWhenVideoComplete"}}
	 */
	module.exports = function (iOSInlinePlayerSelf, playerManager) {
	    return {
	        "handleFullScreen": function (iframeVideoWrapper) {
	            playerManager.isFullscreen = true;
	            debug("handleFullScreen");
	            var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");
	            iOSInlinePlayerSelf.dispatchEventToAdunit({
	                name: "fullscreenchange",
	                fullscreenStatus: "enter"
	            });
	            iOSInlinePlayerSelf.iOSVideoPlayer.enterFullscreenAsCanvas();
	            iOSInlinePlayerSelf.isFullscreen = true;
	            if (topChrome) {
	                topChrome.style.display = "none";//VIDLA-780 - the height should be remaining for the right calculation of resize
	                // topChrome.style.opacity = 0;
	            }
	            if (!iOSInlinePlayerSelf.options.disableTopBar) {
	                verbose("Hiding ad text for fullscreen");
	                iOSInlinePlayerSelf.floatingAdIndicator.style.display = "block";
	                if (iOSInlinePlayerSelf.floatingSkipButton) {
	                    if (iOSInlinePlayerSelf.readyForSkip) {
	                        iOSInlinePlayerSelf.floatingSkipButton.style.display = "block";
	                        iOSInlinePlayerSelf.floatingAdSkipText.style.display = "none";
	                    } else {
	                        iOSInlinePlayerSelf.floatingSkipButton.style.display = "none";
	                        iOSInlinePlayerSelf.floatingAdSkipText.style.display = "block";
	                    }
	                }
	            }
	            utils.makeIframeFlexbileSize(playerManager);
	        },
	        "handleNormalScreen": function (iframeVideoWrapper) {

	            playerManager.isFullscreen = false;
	            debug("handleNormalScreen");
	            var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");

	            iOSInlinePlayerSelf.dispatchEventToAdunit({
	                name: "fullscreenchange",
	                fullscreenStatus: "exit"
	            });

	            //iOSInlinePlayerSelf.options.targetElement.style.transition = "height 0s ease";
	            if (topChrome) {
	                topChrome.style.display = "block";//VIDLA-780 - the height should be remaining for the right calculation of resize
	                // topChrome.style.opacity = 100;
	            }
	            if (!iOSInlinePlayerSelf.options.disableTopBar) {
	                verbose("Showing ad text for fullscreen");
	                iOSInlinePlayerSelf.floatingAdIndicator.style.display = "none";
	                if (iOSInlinePlayerSelf.floatingSkipButton) {
	                    iOSInlinePlayerSelf.floatingSkipButton.style.display = "none";
	                    iOSInlinePlayerSelf.floatingAdSkipText.style.display = "none";
	                }
	            }
	            iOSInlinePlayerSelf.iOSVideoPlayer.exitFullscreeenAsCanvas();


	            iOSInlinePlayerSelf.isFullscreen = false;


	            var shouldNotResizeWhenSideStreamActivated = playerManager.options.sideStream && playerManager.options.sideStream.enabled && playerManager.options.sideStreamObject && playerManager.options.sideStreamObject.isActivated;
	            if (shouldNotResizeWhenSideStreamActivated === false) {
	                iOSInlinePlayerSelf.refreshVideoLookAndFeel(iOSInlinePlayerSelf.options, playerManager);//resizePlayer and change height of targetElement to have same value with video
	            }
	            iOSInlinePlayerSelf.resizeIosCanvas(iOSInlinePlayerSelf.isFullscreen);//resize canvase size and redraw 1 frame of the video which is cuurently playing or paused, this should be performed after video.js UI has changed


	            var videoObject = document.getElementById(playerManager.videoObjectId);
	            if (videoObject && typeof(videoObject) !== "undefined") {
	                videoObject.style.width = iOSInlinePlayerSelf.options.width;
	                videoObject.style.height = iOSInlinePlayerSelf.options.height;
	            }

	            //VID-2143
	            var isSideStreamEnabled = playerManager.options.sideStream && playerManager.options.sideStream.enabled;
	            var isSideStreamStarted = playerManager.options.sideStreamObject && typeof(playerManager.options.sideStreamObject.moveAdUnitBack) === "function";
	            if (isSideStreamEnabled && isSideStreamStarted) {
	                playerManager.options.sideStreamObject.moveAdUnitBack();
	            }

	            utils.makeIframeFlexbileSize(playerManager);

	        },
	        "resizeIosCanvas": function (isFullscreen_) {
	            /**
	             * resizeIosCanvas : this will resize canvas and redraw last position of the iOS inline video
	             * @param isFullscreen_
	             */
	            iOSInlinePlayerSelf.iOSVideoPlayer.resizeCanvas(isFullscreen_);
	            iOSInlinePlayerSelf.iOSVideoPlayer.redrawCanvas(isFullscreen_);
	        },
	        "cbWhenVideoComplete": function (iframeVideoWrapper, el_videoArea) {

	            debug("cbWhenVideoComplete");

	            if (iOSInlinePlayerSelf.isFullscreen) {
	                iOSInlinePlayerSelf.fromFullscreen = true;
	                iOSInlinePlayerSelf.handleNormalScreen(iframeVideoWrapper);
	            }

	            // Disable sidestream after ad is done if we aren't collapsing it
	            if (iOSInlinePlayerSelf.options.disableCollapse.enabled === true) {
	                if (playerManager.options.sideStreamObject) {
	                    if (playerManager.options.sideStreamObject.isActivated) {
	                        playerManager.options.sideStreamObject.moveAdUnitBack();
	                    }
	                }

	                playerManager.options.sideStream.wasEnabled = playerManager.options.sideStream.enabled;
	                playerManager.options.sideStream.enabled = false;
	            }

	            if (iOSInlinePlayerSelf.options.disableCollapse.enabled === true && (iOSInlinePlayerSelf.options.disableCollapse.replay === true || iOSInlinePlayerSelf.options.endCard.enabled === true)) {
	                if (iOSInlinePlayerSelf.options.endCard.enabled && playerManager.endCard) {
	                    // Hide control bar and show end card screen
	                    iOSInlinePlayerSelf.videojsPlayer.trigger("concealControls");
	                    iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video_complete"});
	                    playerManager.endCard.show();
	                } else {
	                    // Display replay button
	                    iOSInlinePlayerSelf.videojsPlayer.bigPlayButton.addClass("vjs-big-play-button-replay");
	                    // Pause video and set time to 0
	                    playerManager.explicitPause();
	                    iOSInlinePlayerSelf.videojsPlayer.currentTime(0);
	                    iOSInlinePlayerSelf.videojsPlayer.bigPlayButton.show();
	                    iOSInlinePlayerSelf.videojsPlayer.player().bigPlayButton.el().style.display = "block";
	                    // Send out video_complete event but don't use the callback that destroys player
	                    iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video_complete"});
	                }
	            } else if (iOSInlinePlayerSelf.isAlreadyDoneVideoComplete) {//VID-1510
	                return;
	            } else {
	                iOSInlinePlayerSelf.isAlreadyDoneVideoComplete = true;

	                // remove control bar items
	                verbose("removing control bar items");
	                iOSInlinePlayerSelf.videojsPlayer.trigger("concealControls");

	                verbose("destroying iOSVideoPlayer");
	                iOSInlinePlayerSelf.iOSVideoPlayer.destroy();
	                iOSInlinePlayerSelf.resizeIosCanvas(iOSInlinePlayerSelf.isFullscreen);


	                if (!iOSInlinePlayerSelf.options.disableCollapse.enabled) {
	                    window.removeEventListener("orientationchange", iOSInlinePlayerSelf.eventOrientationChange);
	                    window.removeEventListener("resize", iOSInlinePlayerSelf.eventSizeChange);
	                }

	                var callbackFunctionAfterVideoComplete = function () {
	                    //following all flags should set after "video_complete" tracking triggered. if it's earlier triggered video_complete will be ignored.
	                    if (!iOSInlinePlayerSelf.options.disableCollapse.enabled) {
	                        playerManager.isFullscreen = true;//Outstream will check this flag to select way of termination
	                        playerManager.destroyWithoutSkip();//this actual termination logic should be invoked after video_complete triggered. so this callbackFunctionAfterVideoComplete is being passed into eventHandling logic
	                    }
	                    playerManager.isCompleted = true;
	                    if (iOSInlinePlayerSelf.options.vpaid) {
	                        utils.fireEvent(el_videoArea, "ended");// Fire ended event on video for VID-1367
	                    }
	                };
	                iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video_complete"}, callbackFunctionAfterVideoComplete);//this callback will be invoked after video_complete
	            }

	            // Let manager know that video has been completed and all subsequent plays are replay
	            playerManager.isEnded = true;
	        }
	    };
	};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	

	var utils = __webpack_require__(8);
	var JSVPAIDConfigure = __webpack_require__(12);
	var _logger = __webpack_require__(9);
	var log = function (message) {
	    _logger.log("iOSInlineVideoPlayer: " + message);
	};
	var debug = function (message) {
	    _logger.debug("iOSInlineVideoPlayer :: Events: " + message);
	};
	var error = function (message) {
	    _logger.error("iOSInlineVideoPlayer :: Events: " + message);
	};


	var adIconHandler = __webpack_require__(34);
	var endCardHandler = __webpack_require__(19);
	var topBarHeight = 24;



	/**
	 * Events
	 * @param iOSInlinePlayerSelf
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 * @returns {{fnMainProcess: "fnMainProcess"}}
	 */
	module.exports = function (iOSInlinePlayerSelf, playerManager, cbInjectEventToPlayer) {
	    return {
	        fnMainProcess: function (iframeVideoWrapper) {

	            /**
	             * seconds step excutes after createIframe
	             * @param iframeVideoWrapper
	             */
	            log("fnMainProcess");

	            //expose video object in iframe
	            var an_video_ad_player = iframeVideoWrapper.contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_id);
	            playerManager.iframeVideoWrapper = iframeVideoWrapper;

	            //activate JSVPAID plug-in this should be actiavated before video.js intialized
	            if (iOSInlinePlayerSelf.options.vpaid) {
	                try {
	                    playerManager.options.showVpaidIcons = false;
	                    JSVPAIDConfigure(playerManager);
	                } catch (ex) {
	                    error(ex);
	                }
	            } else {
	                //Cleanup previous plugin reference.
	                if(iOSInlinePlayerSelf.options.isWaterfall && iOSInlinePlayerSelf.options.plugins){
	                    iOSInlinePlayerSelf.options.plugins = null;
	                }
	            }

	            iOSInlinePlayerSelf.options.nativeControlsForTouch = false;
	            iOSInlinePlayerSelf.options.customControlsOnMobile = false;
	            //create player object from video.js. this is required to have same code with regular one which is not iOS inline video
	            iOSInlinePlayerSelf.videojsPlayer = iOSInlinePlayerSelf.videojsOrigin(an_video_ad_player, iOSInlinePlayerSelf.options, function () {
	            });


	            __webpack_require__(40)(iOSInlinePlayerSelf, playerManager, cbInjectEventToPlayer, iOSInlinePlayerSelf.videojsPlayer, iframeVideoWrapper).run();

	            playerManager.adVideoPlayer = iOSInlinePlayerSelf.videojsPlayer;//inject video.js API reference to outside. this object includes all methods supported by video.js and html objects generated by video.js for example) controlbar, volume controls etc..

	            var el_wholeArea = document.getElementById(iOSInlinePlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_id);//whole video area inside iframe
	            var el_videoArea = document.getElementById(iOSInlinePlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_html5_api_id);//html5 video object inside iframe

	            if (iOSInlinePlayerSelf.options.enableInlineVideoForIos === true) {
	                //el_videoArea.style.visibility = "hidden";//html5 video should be hidden when ios-inline-player activated and it should be set before video.load() because of iOS limitation see this ticket https://jira.corp.appnexus.com/browse/VID-2096
	                el_videoArea.style.width = "0.1px";
	                el_videoArea.style.height = "0.1px";
	            }

	            var tmp = document.createElement("div");
	            tmp.style.position = "absolute";
	            tmp.style.top = "0px";
	            tmp.style.left = "0px";
	            if (!iOSInlinePlayerSelf.options.vpaid) {
	                tmp.className = "vjs-tech";//if some div uses 'vjs-tech' as a CSS className, JSVPAID will regard that must be video object
	            }
	            tmp.style.textAlign = "center";
	            el_wholeArea.insertBefore(tmp, el_videoArea);//inject target div defore video tag






	            //register this resize function to be invked by sideStream
	            iOSInlinePlayerSelf.options.targetElement.addEventListener("IOS_INLINE_RESIZE", function () {
	                iOSInlinePlayerSelf.resizeIosCanvas(false);
	            });

	            iOSInlinePlayerSelf.options.targetElement.addEventListener("IOS_INLINE_REFERESH", function () {
	                iOSInlinePlayerSelf.refreshVideoLookAndFeel(iOSInlinePlayerSelf.options, playerManager);
	                iOSInlinePlayerSelf.iOSVideoPlayer.checkOrientation();
	                iOSInlinePlayerSelf.customFullscreenBtn.style.visibility = "hidden";//hide fullscreen because iOS custom fullscreen feature doesn't work over unfriendly iframe - it only expands on the iframe area and that's not what we expect.
	            });

	            //iOSInlinePlayerSelf.options to render ios inline video
	            /**
	             * mediaURl : url of video
	             * divArea : div element to render canvas
	             * width : width of video player
	             * videoElement : video object to be used as source of video capturing
	             * cbWhenVideoComplete : callback when video completes
	             * targetElement : div element of publisher's site
	             * cbClickToBrowse : callback when click the video areas
	             * @type {{mediaUrl: (string|*), divArea: Element, width: *, videoElement: Element, cbWhenVideoComplete: Function, targetElement: (*|string), cbClickToBrowse: (*|adVideoPlayerManager.click|Function|x.event.special.click|{trigger, _default}|SCOPE.reportAnalytics.click)}}
	             */

	            var optionForInlineVideo = {
	                "mediaUrl": iOSInlinePlayerSelf.options.videoUrl,
	                "divArea": tmp,
	                "width": iOSInlinePlayerSelf.options.width,
	                "height": iOSInlinePlayerSelf.options.height,
	                "videoElement": el_videoArea,
	                "cbWhenVideoComplete": function() {iOSInlinePlayerSelf.cbWhenVideoComplete(iframeVideoWrapper,el_videoArea);},
	                "targetElement": iOSInlinePlayerSelf.options.targetElement,
	                "iframeVideoWrapper": iframeVideoWrapper,
	                "el_wholeArea": el_wholeArea,
	                "cbTimeUpdate": function () {
	                    iOSInlinePlayerSelf.videojsPlayer.trigger("timeupdate");
	                }
	            };

	            var waterfallStepId = iOSInlinePlayerSelf.options.isWaterfall ? iOSInlinePlayerSelf.options.waterfallStepId : null;

	            iOSInlinePlayerSelf.iOSVideoPlayer.setPubOptions(iOSInlinePlayerSelf.options);

	            /**
	             * render inline video with options callback will invoke with flag(isAcceptable) after it preapred to start
	             */
	            iOSInlinePlayerSelf.iOSVideoPlayer.renderVideo(optionForInlineVideo, function (isAcceptable) {
	                if (!isAcceptable) {
	                    debug("only works in iOS");
	                    return;
	                } else {

	                    iOSInlinePlayerSelf.eventOrientationChange = function () {//event handler whenever change rotation completed

	                        if(waterfallStepId && waterfallStepId !== iOSInlinePlayerSelf.options.waterfallStepId){
	                            // Ignore the events as these are from previous ad attempts;
	                            return;
	                        }
	                        if (playerManager.isReadyToExpandForMobile) {//for VID-1515

	                            var shouldNotResizeWhenSideStreamActivated = playerManager.options.sideStreamObject  && typeof(playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated) === "function" ? playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated() : false;
	                            if (shouldNotResizeWhenSideStreamActivated) {
	                                return;
	                            }
	                            iOSInlinePlayerSelf.refreshVideoLookAndFeel(iOSInlinePlayerSelf.options, playerManager);
	                            iOSInlinePlayerSelf.iOSVideoPlayer.checkOrientation();
	                            utils.makeIframeFlexbileSize(playerManager);
	                        }
	                    };

	                    iOSInlinePlayerSelf.eventSizeChange = function () {//event handler to catch a moment when ios addressbar appears
	                        if(waterfallStepId && waterfallStepId !== iOSInlinePlayerSelf.options.waterfallStepId){
	                            // Ignore the events as these are from previous ad attempts;
	                            return;
	                        }
	                        if (iOSInlinePlayerSelf.isFullscreen) {//resize all when iOS h/w addressbar appears
	                            playerManager.resizeVideo(-1, iOSInlinePlayerSelf.shouldConsiderHeightOfDevice);
	                            iOSInlinePlayerSelf.iOSVideoPlayer.checkOrientation();
	                            utils.makeIframeFlexbileSize(playerManager);
	                        }
	                    };

	                    window.addEventListener("resize", iOSInlinePlayerSelf.eventSizeChange);
	                    window.addEventListener("orientationchange", iOSInlinePlayerSelf.eventOrientationChange);

	                    el_videoArea.onseeked = function () {
	                        return false;
	                    };
	                    if(iOSInlinePlayerSelf.options.initialPlayback === "auto"){
	                        iOSInlinePlayerSelf.videojsPlayer.player().loadingSpinner.show();
	                    }else{
	                        iOSInlinePlayerSelf.videojsPlayer.player().loadingSpinner.hide();
	                    }
	                    iOSInlinePlayerSelf.videojsPlayer.player().off('seeked');//stop seeking because we don't use html5 video tag playing


	                    iOSInlinePlayerSelf.iOSVideoPlayer.initiate();//generate required tag and initiate

	                    //draw first frame of video
	                    if (iOSInlinePlayerSelf.options.initialPlayback === "click") {
	                        el_videoArea.addEventListener("canplay",function() {
	                            iOSInlinePlayerSelf.iOSVideoPlayer.checkOrientation();
	                        });
	                    }
	                }
	            });


	            iOSInlinePlayerSelf.videojsPlayer.controlBar.fullscreenToggle.dispose();//dispose exisitng fullscreen icon which has lots of issue causing by event bubbleing from video.js in its Component block

	            if (iOSInlinePlayerSelf.options.allowFullscreen === true && iOSInlinePlayerSelf.enableFullscreen) {

	                iOSInlinePlayerSelf.customFullscreenBtn = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                    'id': 'customFullscreenToggle',
	                    'role': 'button',
	                    //'innerHTML': 'FullScreen',
	                    'innerHTML': '<div class="vjs-control-content"><span class="vjs-control-text">Fullscreen</span></div>'
	                });
	                iOSInlinePlayerSelf.customFullscreenBtn.style.cssText = "text-align:right;float:right;margin-right:0em;font-size:1em;line-height:3em;outline:0;position:relative;padding:0;height:3em";

	                iOSInlinePlayerSelf.customFullscreenBtn.className = "vjs-fullscreen-control vjs-control";

	                iOSInlinePlayerSelf.videojsPlayer.controlBar.addChild('button', {
	                    'el': iOSInlinePlayerSelf.customFullscreenBtn
	                });

	                /**
	                 * handle fullscreen on inline inveo
	                 */
	                iOSInlinePlayerSelf.customFullscreenBtn.addEventListener("touchend", function (e) {
	                    setTimeout(function() {
	                        if (!iOSInlinePlayerSelf.isFullscreen) {
	                            iOSInlinePlayerSelf.handleFullScreen(iframeVideoWrapper);
	                        } else {
	                            var videoElement = document.getElementById(iOSInlinePlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_html5_api_id);//html5 video object inside iframe
	                            var originalVisibilityOfVideo = videoElement.style.visibility;
	                            videoElement.style.visibility = "hidden";//for VID-2793, some of jsvpaid creative can have unexpected event from windows during this switching if video deosn't have hidden attribute at this short moment in iOS10 with inline module, but it will be restored immediately
	                            setTimeout(function() {
	                                iOSInlinePlayerSelf.handleNormalScreen(iframeVideoWrapper);
	                                videoElement.style.visibility = originalVisibilityOfVideo;//restore previous visilibity state
	                            },0);//block async execution
	                        }
	                        e.preventDefault();
	                    },200);//add safety time to have right fullscreen status on ios
	                });

	                //comment out - why do we need click on IOS browser?
	                // iOSInlinePlayerSelf.customFullscreenBtn.addEventListener("click", function () {
	                //     if (!iOSInlinePlayerSelf.isFullscreen) {
	                //         iOSInlinePlayerSelf.handleFullScreen(iframeVideoWrapper);
	                //     } else {
	                //         iOSInlinePlayerSelf.handleNormalScreen(iframeVideoWrapper);
	                //     }
	                // });
	            }


	            /**
	             * click to browse, this will get canvas object through getCanvas() interface of ios inline video player and dispatch signal to API
	             */
	            iOSInlinePlayerSelf.iOSVideoPlayer.getCanvas().onclick = function () {
	                if (iOSInlinePlayerSelf.options.learnMore.enabled === false) {

	                    if (!playerManager.options.expandable) {
	                        //if it's not Outstream - Outstream has it's own resume/pause feature when leave or have a focus of window
	                        playerManager.explicitPause();
	                    }

	                    playerManager.click();
	                } else if (iOSInlinePlayerSelf.options.learnMore.clickToPause === true) {
	                    if (iOSInlinePlayerSelf.isTogglePaused === false) {
	                        playerManager.explicitPause();
	                    } else {
	                        playerManager.explicitPlay();
	                    }
	                }
	            };

	            //function to switch an playtoggle icon
	            var havePauseStatusIcon = function (isPaused) {
	                if (isPaused) {
	                    iOSInlinePlayerSelf.customPlayToggle.innerHTML = '<div><span>&#xe001;</span></div>';//icon to pause video
	                } else {
	                    iOSInlinePlayerSelf.customPlayToggle.innerHTML = '<div><span>&#xe002;</span></div>';//icon to play video
	                }
	            };


	            var simulateHtml5VideoPlay = function () {
	                /**
	                 * this is for overriding play method in html5 video
	                 * it support intial play and resume video by "isPlayingVideo" flag
	                 * if it's true it will resume a video, if else it will do initial play a video
	                 */
	                //hide play button
	                iOSInlinePlayerSelf.videojsPlayer.player().bigPlayButton.hide();
	                iOSInlinePlayerSelf.videojsPlayer.player().loadingSpinner.hide();//hide loading spinner

	                iOSInlinePlayerSelf.videojsPlayer.player().addClass("vjs-has-started");
	                iOSInlinePlayerSelf.videojsPlayer.player().removeClass('vjs-paused');
	                iOSInlinePlayerSelf.videojsPlayer.player().addClass('vjs-playing');

	                //play video when its fist play
	                try {
	                    havePauseStatusIcon(false);

	                    var enabledAudio = iOSInlinePlayerSelf.enabledAudio;
	                    iOSInlinePlayerSelf.iOSVideoPlayer.initialPlay(enabledAudio);//invoke initialPlay in iOSVideoPlayer, this initialPlay will set a required value for initial playing
	                    debug("override play method");

	                    if (!iOSInlinePlayerSelf.isDoneiOSInitialPlay) {
	                        utils.fireEvent(el_videoArea, "play");//for VID-1331, VIDLA-1099
	                        utils.fireEvent(el_videoArea, "playing");//for VID-1331, VIDLA-1099
	                        iOSInlinePlayerSelf.isDoneiOSInitialPlay = true;
	                    } else {
	                        utils.fireEvent(el_videoArea, "play");//for VID-1331, VIDLA-1099
	                        utils.fireEvent(el_videoArea, "playing");//for VID-1331, VIDLA-1099
	                    }

	                    playerManager.isPlayingVideo = true;
	                    iOSInlinePlayerSelf.isTogglePaused = false;
	                } catch (ex) {
	                    error(ex);
	                }
	            };

	            /**
	             * pause
	             */
	            var simulateHtml5VideoPause = function () {

	                if (iOSInlinePlayerSelf.isTogglePaused) {

	                    return;//don't need to do again when it's already paused.
	                }

	                if (playerManager.isCompleted || playerManager.isEnded) {
	                    return;
	                }

	                if (iOSInlinePlayerSelf.options.showBigPlayButton !== false) {
	                    //show big play button
	                    var isSideStreamActivated = playerManager.options.sideStream && playerManager.options.sideStream.enabled && playerManager.options.sideStreamObject && playerManager.options.sideStreamObject.isActivated;
	                    if (isSideStreamActivated === true && playerManager.options.showPlayToggle === true && playerManager.options.sideStream.dynamicBigPlayButtonOnSideStream == true) {
	                        //do nothing for VIDLA-2188
	                    } else {
	                        iOSInlinePlayerSelf.videojsPlayer.bigPlayButton.show();
	                        iOSInlinePlayerSelf.videojsPlayer.player().bigPlayButton.el().style.display = "block";
	                    }

	                }

	                iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();//actual pause for canvas redraw on ios inline player
	                debug("override pause method");

	                havePauseStatusIcon(true);
	                playerManager.isPlayingVideo = false;
	                iOSInlinePlayerSelf.isTogglePaused = true;

	                utils.fireEvent(el_videoArea, "pause");//for VID-1331,VID-1510

	            };


	            //override play & pause method which is under html5 object to intercept flow in html5
	            var overrideNativeMethodForVideo = function () {
	                var checkAndLoadVideo = function (el) {
	                    if (el && el.readyState === 0) {
	                        el.load();//this is required for start inline video player
	                    }
	                };

	                el_videoArea.play = function () {
	                    checkAndLoadVideo(el_videoArea);
	                    simulateHtml5VideoPlay();
	                };
	                el_videoArea.pause = function () {
	                    simulateHtml5VideoPause();
	                };

	                iOSInlinePlayerSelf.videojsPlayer.one("vpaid.AdStarted", function () {//after vpaid returns "AdStarted" the video object would have a src attribute to be able to load immediately
	                    checkAndLoadVideo(el_videoArea);
	                });

	                iOSInlinePlayerSelf.videojsPlayer.one("an.readytogovpaid", function () {//after vpaid returns "AdStarted" the video object would have a src attribute to be able to load immediately
	                    iOSInlinePlayerSelf.iOSVideoPlayer.activateAudio();
	                    checkAndLoadVideo(el_videoArea);
	                });


	            };


	            if (iOSInlinePlayerSelf.options.vpaid) {
	                overrideNativeMethodForVideo();
	            } else {
	                el_videoArea.play = simulateHtml5VideoPlay;
	                el_videoArea.pause = simulateHtml5VideoPause;
	            }

	            /**
	             * //TODO for ios limiation we can't use html5 standard full screen api, so for several reason related human's behavoir we will need to igonre gesture in the full screen of ios video player
	             */
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.el().ontouchend = function () {
	            };


	            /**
	             * handle pause / resume
	             */
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.playToggle.dispose();//dispose to disconnect video.js event
	            iOSInlinePlayerSelf.customPlayToggle = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                'id': 'customPlayToggle',
	                'role': 'button',
	                'aria-live': 'polite',
	                'tabindex': '0',
	                'innerHTML': '<div><span>&#xe002;</span></div>',
	                'width': '5em'
	            });
	            iOSInlinePlayerSelf.customPlayToggle.style.cssText = "float:left;font-family:VideoJS;font-size:1.5em;line-height:2;width:3em;height:100%;text-align:center";
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.addChild('button', {
	                'el': iOSInlinePlayerSelf.customPlayToggle
	            });
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.el().insertBefore(iOSInlinePlayerSelf.customPlayToggle, iOSInlinePlayerSelf.videojsPlayer.controlBar.currentTimeDisplay.el());

	            iOSInlinePlayerSelf.customPlayToggle.ontouchend = function (e) {

	                if (iOSInlinePlayerSelf.isTogglePaused === false) {
	                    playerManager.explicitPause();
	                } else {
	                    playerManager.explicitPlay();
	                }

	                e.preventDefault();
	            };
	            iOSInlinePlayerSelf.customPlayToggle.onclick = function () {

	                if (iOSInlinePlayerSelf.isTogglePaused === false) {
	                    playerManager.explicitPause();
	                } else {
	                    playerManager.explicitPlay();
	                }
	            };

	            /**
	             * handle unmute to initiaite audio
	             */
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el().ontouchend = function () {


	                if (!iOSInlinePlayerSelf.enabledAudio) {
	                    iOSInlinePlayerSelf.iOSVideoPlayer.hearAudio();
	                    iOSInlinePlayerSelf.enabledAudio = true;
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "1";
	                    playerManager.dispatchEventToAdunit({"name": "video_unmute"});

	                    if (iOSInlinePlayerSelf.isTogglePaused === true) {//if paused, not playing audio
	                        //iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();//comment out explicit-pause will be more suitable here
	                        playerManager.explicitPause();
	                    }
	                } else {
	                    iOSInlinePlayerSelf.iOSVideoPlayer.stopAudio();
	                    iOSInlinePlayerSelf.enabledAudio = false;
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "0.3";
	                    playerManager.dispatchEventToAdunit({"name": "video_mute"});
	                }
	            };
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el().onclick = function () {


	                if (!iOSInlinePlayerSelf.enabledAudio) {
	                    iOSInlinePlayerSelf.iOSVideoPlayer.hearAudio();
	                    iOSInlinePlayerSelf.enabledAudio = true;
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "1";

	                    if (iOSInlinePlayerSelf.isTogglePaused === true) {//if paused, not playing audio
	                        // iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();//comment out explicit-pause will be more suitable here
	                        playerManager.explicitPause();
	                    }
	                } else {
	                    iOSInlinePlayerSelf.iOSVideoPlayer.stopAudio();
	                    iOSInlinePlayerSelf.enabledAudio = false;

	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "0.3";
	                }
	            };

	            //invoke cbWhenReady immediately for jspaid
	            iOSInlinePlayerSelf.videojsPlayer.one("loadedmetadata", function (e) {//one time handlers because iOS core also invoke .load so we have to supress seconds event
	                if (iOSInlinePlayerSelf.options.showPlayToggle === false) {
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.playToggle.hide();
	                }

	                if (iOSInlinePlayerSelf.options.showBigPlayButton === false) {
	                    iOSInlinePlayerSelf.videojsPlayer.bigPlayButton.hide();
	                }


	                //set showMute
	                if (iOSInlinePlayerSelf.options.showMute === false) {
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.hide();
	                } else {
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.show();//always show unmute
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "0.3";
	                }


	                if (playerManager.options.vpaid) {
	                    return;//VID1707 - vapid creative shouldn't be handled by loadedmetata. it only works with vpaid event
	                }

	                playerManager.isReadyToExpandForMobile = true;

	                playerManager.videoObjectId = e.currentTarget.id;

	                debug("loadedmetadata");
	                debug("video.js is ready to play");

	                //disable click to play
	                iOSInlinePlayerSelf.videojsPlayer.tech.removeControlsListeners();

	                //get real video size
	                var realVideoWidth = e.currentTarget.videoWidth;
	                var realVideoHeight = e.currentTarget.videoHeight;
	                var aspectRatio = realVideoWidth / realVideoHeight;


	                if (realVideoWidth > 0) {
	                    playerManager.resizeVideo(aspectRatio, iOSInlinePlayerSelf.shouldConsiderHeightOfDevice);

	                    if (typeof iOSInlinePlayerSelf.callbackForAdUnit.cbWhenReady === "function") {
	                        iOSInlinePlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
	                    }
	                } else {
	                    //if the event doesn't return a videoWidth
	                    playerManager.resizeVideo(0, iOSInlinePlayerSelf.shouldConsiderHeightOfDevice);
	                    iOSInlinePlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
	                }

	            });

	            //custom skinning
	            playerManager.customSkinning.render(iOSInlinePlayerSelf,iOSInlinePlayerSelf.videojsPlayer,iframeVideoWrapper.contentWindow.document,true);



	            var setupAdIconForIos = function() {

	                var bottomBarHeight = playerManager.options.playerSkin.controlBarHeight;
	                var videojsPlayer = iOSInlinePlayerSelf.videojsPlayer;
	                //adicon
	                //VAST3.0 Ad Icon Support
	                var icons = new adIconHandler();
	                icons.init(playerManager.options.data.adIcons);
	                var iconList = icons.getIcons();

	                if (!iconList || (iconList && iconList.length === 0)) {
	                    return;
	                }

	                var topMarginForIcon = playerManager.options.disableTopBar ? 0 : topBarHeight;
	                var bottomMarginForIcon = bottomBarHeight;//ios player always has bottom bar


	                videojsPlayer.controlBar.el_.style.zIndex = 10;//cotrolbar will have higher z-index

	                // @exclude
	                playerManager.test("adIconOffset",icons);
	                // @endexclude

	                videojsPlayer.on("timeupdate", function () {
	                    if(playerManager.options.vpaid && !playerManager.options.showVpaidIcons){
	                        return;
	                    }
	                    var currentTime = Math.round(videojsPlayer.player().currentTime());
	                    var _currentTimeMsec = currentTime * 1000;
	                    var videoDuration = Math.round(videojsPlayer.player().duration());
	                    var _videoDurationMsec = videoDuration * 1000;
	                    if (iconList && iconList.length > 0) {
	                        icons.renderIcons(
	                            function (_eventKey) {
	                                var obj = {};
	                                obj.name = _eventKey;
	                                playerManager.dispatchEventToAdunit(obj);
	                            },
	                            function (clickUrl) {
	                                if (!playerManager.options.expandable) {
	                                    //if it's not Outstream - Outstream has it's own resume/pause feature when leave or have a focus of window
	                                    playerManager.explicitPause();
	                                }
	                                playerManager.click(clickUrl, false);
	                            },
	                            videojsPlayer.player().el_,
	                            topMarginForIcon,
	                            bottomMarginForIcon,
	                            _currentTimeMsec,
	                            _videoDurationMsec);
	                    }
	                });
	            };

	            cbInjectEventToPlayer(el_wholeArea, el_videoArea);//inject generate html object to next step of video player manager

	            setupAdIconForIos();

	            if (iOSInlinePlayerSelf.options.vpaid) {
	                iOSInlinePlayerSelf.videojsPlayer.trigger("an.doneInitialize");
	            }

	            if (iOSInlinePlayerSelf.options.endCard.enabled) {
	                playerManager.endCard = new endCardHandler(iOSInlinePlayerSelf.options.endCard, iOSInlinePlayerSelf.videojsPlayer, playerManager);
	            }

	            // custom vjs events to hide/show all controls on the control bar without hiding/showing the control bar itself
	            iOSInlinePlayerSelf.videojsPlayer.on("concealControls", function() {

	                var _controlBar = iOSInlinePlayerSelf.videojsPlayer.player().controlBar;

	                if (_controlBar && !_controlBar.concealed) {
	                    if (_controlBar.currentTimeDisplay) {
	                        _controlBar.currentTimeDisplay.hide();
	                    }
	                    if (_controlBar.durationDisplay) {
	                        _controlBar.durationDisplay.hide();
	                    }
	                    if (_controlBar.timeDivider) {
	                        _controlBar.timeDivider.hide();
	                    }
	                    if (_controlBar.muteToggle) {
	                        _controlBar.muteToggle.hide();
	                    }
	                    if (_controlBar.playToggle) {
	                        _controlBar.playToggle.hide();
	                    }
	                    if (_controlBar.fullscreenToggle) {
	                        _controlBar.fullscreenToggle.hide();
	                    }
	                    if (_controlBar.progressControl) {
	                        _controlBar.progressControl.hide();
	                    }
	                    if (_controlBar.volumeControl) {
	                        _controlBar.volumeControl.hide();
	                    }
	                    if (utils.isEmptyAndObject(iOSInlinePlayerSelf.customPlayToggle) === false) {
	                        iOSInlinePlayerSelf.customPlayToggle.style.display = 'none';
	                    }
	                    if (utils.isEmptyAndObject(iOSInlinePlayerSelf.customFullscreenBtn) === false) {
	                        iOSInlinePlayerSelf.customFullscreenBtn.style.display = 'none';
	                    }

	                    //fix VIDLA-2180;
	                    iOSInlinePlayerSelf.savedBackgroundColorForBottomBar = _controlBar.el_.style.backgroundColor;
	                    iOSInlinePlayerSelf.savedBackgroundForBottomBar = _controlBar.el_.style.background;
	                    _controlBar.el_.style.background = iOSInlinePlayerSelf.options.playerSkin.videoBackgroundColor;
	                    _controlBar.el_.style.backgroundColor = iOSInlinePlayerSelf.options.playerSkin.videoBackgroundColor;


	                    _controlBar.concealed = true;
	                }
	            });

	            iOSInlinePlayerSelf.videojsPlayer.on("revealControls", function() {
	                var _controlBar = iOSInlinePlayerSelf.videojsPlayer.player().controlBar;

	                if (_controlBar && _controlBar.concealed) {
	                    if (iOSInlinePlayerSelf.options.showProgressBar !== "bar" && iOSInlinePlayerSelf.options.showProgressBar !== false) {
	                        if (_controlBar.currentTimeDisplay) {
	                            _controlBar.currentTimeDisplay.show();
	                        }
	                        if (_controlBar.durationDisplay) {
	                            _controlBar.durationDisplay.show();
	                        }
	                        if (_controlBar.timeDivider) {
	                            _controlBar.timeDivider.show();
	                        }
	                    }
	                    if (_controlBar.muteToggle && iOSInlinePlayerSelf.options.showMute) {
	                        _controlBar.muteToggle.show();
	                    }
	                    if (_controlBar.playToggle && iOSInlinePlayerSelf.options.showPlayToggle) {
	                        _controlBar.playToggle.show();
	                    }
	                    if (_controlBar.fullscreenToggle && iOSInlinePlayerSelf.options.allowFullscreen) {
	                        _controlBar.fullscreenToggle.show();
	                    }
	                    if (iOSInlinePlayerSelf.options.showProgressBar !== false && iOSInlinePlayerSelf.options.showProgressBar !== "text") {
	                        if (_controlBar.progressControl) {
	                            _controlBar.progressControl.show();
	                        }
	                    }
	                    // I'm not sure how exactly, but on iOS the volumeControl is never shown even when options.showVolume is true
	                    //if (_controlBar.volumeControl && iOSInlinePlayerSelf.options.showVolume) {
	                    //    _controlBar.volumeControl.show();
	                    //}
	                    if (utils.isEmptyAndObject(iOSInlinePlayerSelf.customPlayToggle) === false) {
	                        iOSInlinePlayerSelf.customPlayToggle.style.display = 'block';
	                    }
	                    if (utils.isEmptyAndObject(iOSInlinePlayerSelf.customFullscreenBtn) === false) {
	                        iOSInlinePlayerSelf.customFullscreenBtn.style.display = 'block';
	                    }

	                    //fix VIDLA-2180;
	                    _controlBar.el_.style.backgroundColor = iOSInlinePlayerSelf.savedBackgroundColorForBottomBar;
	                    _controlBar.el_.style.background = iOSInlinePlayerSelf.savedBackgroundForBottomBar;


	                    _controlBar.concealed = false;
	                }
	            });
	        },
	    };

	};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */



	var _logger = __webpack_require__(9);
	var debug = function (message) {
	    _logger.debug("iOSInlineVideoPlayer :: CustomizeVideoArea: " + message);
	};
	var verbose = function (message) {
	    _logger.verbose("Video Player: " + message);
	};

	var Utils = __webpack_require__(8);

	var CONST_MESSAGE_GENERAL_ERROR = "General error reported from HTML5 video player (iOS inline)";

	/**
	 * CustomizeVideoArea
	 * @param iOSInlinePlayerSelf
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 * @param videojsPlayer
	 * @param iframeVideoWrapper
	 * @returns {{run: "run"}}
	 */
	module.exports = function(iOSInlinePlayerSelf,playerManager, cbInjectEventToPlayer,videojsPlayer, iframeVideoWrapper) {
	    return {
	        "run": function () {

	            debug("run");

	            /**
	             * customize video.js UI by by options coming from impbus or publisher's site
	             */

	            if(iOSInlinePlayerSelf.options.isWaterfall && iOSInlinePlayerSelf.options.vpaid){
	                //For vpaid ads in waterfall hide controls until the impression occurs to avoid flicker during failed attempts.
	                videojsPlayer.controlBar.hide();
	                if(iOSInlinePlayerSelf.options.firstAdAttempted) {
	                    videojsPlayer.bigPlayButton.hide();
	                }
	            }

	            if (typeof iOSInlinePlayerSelf.options.customButton.enabled === "boolean" && iOSInlinePlayerSelf.options.customButton.enabled === true) {
	                var controlBarHeight = iOSInlinePlayerSelf.options.playerSkin.controlBarHeight || 30;
	                var imgWidth = Math.min(50,iOSInlinePlayerSelf.options.customButton.imgWidth);
	                var imgHeight = Math.min(controlBarHeight,iOSInlinePlayerSelf.options.customButton.imgHeight);
	                var topMargin = Math.floor((controlBarHeight-imgHeight)/2);

	                var customButton = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                    'innerHTML': '<span ><img style="height:'+imgHeight+'px;width:'+imgWidth+'px;margin-top:'+topMargin+'px" class="home-button-image" src="'+iOSInlinePlayerSelf.options.customButton.imageSrc+'" alt="'+iOSInlinePlayerSelf.options.customButton.altText+'"></span>',
	                    'role': 'button',
	                    'aria-live': 'polite',
	                    'tabindex': '0'
	                });

	                customButton.style.cssText = "float:right;font-family:VideoJS;font-size:1.5em;line-height:2;width:50px;height:100%;text-align:center";
	                videojsPlayer.controlBar.addChild('button', {
	                    'el': customButton
	                });
	                videojsPlayer.controlBar.el().insertBefore(customButton, videojsPlayer.controlBar.fullscreenToggle.el());
	            }

	            //set showProgressBar
	            videojsPlayer.controlBar.progressControl.seekBar.seekHandle.hide();
	            videojsPlayer.controlBar.progressControl.seekBar.el_.style.pointerEvents = 'none';
	            if (typeof iOSInlinePlayerSelf.options.showProgressBar === "boolean") {
	                if (iOSInlinePlayerSelf.options.showProgressBar === false) {
	                    verbose("removing progress bar");
	                    videojsPlayer.controlBar.currentTimeDisplay.hide();
	                    videojsPlayer.controlBar.timeDivider.hide();
	                    videojsPlayer.controlBar.durationDisplay.hide();
	                }
	                videojsPlayer.controlBar.progressControl.seekBar.hide();
	            } else {
	                if (iOSInlinePlayerSelf.options.showProgressBar === "text") {
	                    verbose("removing progress text");
	                    videojsPlayer.controlBar.progressControl.seekBar.hide();
	                } else if (iOSInlinePlayerSelf.options.showProgressBar === "bar") {
	                    verbose("removing progress bar");
	                    videojsPlayer.controlBar.currentTimeDisplay.hide();
	                    videojsPlayer.controlBar.timeDivider.hide();
	                    videojsPlayer.controlBar.durationDisplay.hide();
	                }
	            }

	            //set showVolumee
	            if (iOSInlinePlayerSelf.options.showVolume === false) {
	                videojsPlayer.controlBar.volumeControl.dispose();
	            }

	            //options.bottomDividerColor and iOSInlinePlayerSelf.options.bottomDividerWidth is gurantted by ExtendDefaultOpions.js to have a some default value
	            //create custom divider
	            var customDivider = iOSInlinePlayerSelf.videojsOrigin.createEl('div');
	            customDivider.className = "vjs-control-bar-divider";
	            //minthe : comment out beacuse "customDividerColor" is defined but never used
	            /*
	             var customDividerColor = (function () {
	             return "#" + iOSInlinePlayerSelf.options.bottomDividerColor.toLowerCase().replace("0x", "");
	             })(iOSInlinePlayerSelf.options.customDividerColor);
	             */
	            //set css for divider
	            customDivider.style['position'] = "absolute";
	            customDivider.style['left'] = "0";
	            customDivider.style['right'] = "0";
	            //add divder to controlbar
	            videojsPlayer.controlBar.addChild('button', {
	                'el': customDivider
	            });

	            var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");

	            var adIndicatorText = iframeVideoWrapper.contentWindow.document.createElement("div");
	            adIndicatorText.id = "ad_indicator_text";

	            var adIndicatorTextContent = iOSInlinePlayerSelf.options.adText;
	            var learnMore = iOSInlinePlayerSelf.options.learnMore.enabled;
	            if (!iOSInlinePlayerSelf.options.clickUrls[0]) {
	                learnMore = false;
	            }
	            if (learnMore) {
	                if (iOSInlinePlayerSelf.options.skippable.skipLocation === "top-right") {
	                    adIndicatorTextContent = iOSInlinePlayerSelf.options.learnMore.text + " " + iOSInlinePlayerSelf.options.learnMore.separator + " " + adIndicatorTextContent;
	                } else {
	                    adIndicatorTextContent += " " + iOSInlinePlayerSelf.options.learnMore.separator + " " + iOSInlinePlayerSelf.options.learnMore.text;
	                }
	            }

	            adIndicatorText.innerHTML = adIndicatorTextContent;
	            adIndicatorText.className = 'top-bar-text';
	            adIndicatorText.role = 'button';

	            adIndicatorText.style['text-align'] = "right";
	            adIndicatorText.style['margin-right'] = "1em";
	            adIndicatorText.style['margin-left'] = "1em";
	            adIndicatorText.style['font-size'] = "1em";
	            adIndicatorText.style['right'] = "0px";
	            adIndicatorText.style['left'] = "";
	            adIndicatorText.style['line-height'] = "24px";
	            adIndicatorText.style['outline'] = "0";
	            adIndicatorText.style['position'] = "absolute";
	            adIndicatorText.style['padding'] = "0";
	            adIndicatorText.style['height'] = "auto";
	            adIndicatorText.style['width'] = "auto";
	            adIndicatorText.style['max-width'] = "35%";
	            adIndicatorText.style['white-space'] = "nowrap";
	            adIndicatorText.style['overflow'] = "hidden";
	            adIndicatorText.style['text-overflow'] = "ellipsis";

	            iOSInlinePlayerSelf.floatingAdIndicator = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                'role': 'button',
	                'innerHTML': adIndicatorTextContent,
	                'className': "top-bar-text"
	            });

	            iOSInlinePlayerSelf.floatingAdIndicator.style['text-align'] = "right";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['margin-right'] = "1em";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['margin-left'] = "1em";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['font-size'] = "1em";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['right'] = "0px";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['left'] = "";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['line-height'] = "3em";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['outline'] = "0";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['position'] = "absolute";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['padding'] = "0";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['height'] = "3em";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['max-width'] = "35%";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['width'] = "auto";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['text-overflow'] = "ellipsis";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['white-space'] = "nowrap";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['overflow'] = "hidden";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['display'] = "none";
	            videojsPlayer.addChild('button', {
	                'el': iOSInlinePlayerSelf.floatingAdIndicator
	            });

	            if (learnMore) {
	                var learnMoreHandler = function(e) {
	                    iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();
	                    playerManager.click();
	                    e.stopPropagation();
	                    e.preventDefault(); // prevents a touch event from also triggering a click event
	                };

	                adIndicatorText.addEventListener("click", learnMoreHandler);
	                iOSInlinePlayerSelf.floatingAdIndicator.addEventListener("click", learnMoreHandler);

	            }


	            var skipButton;
	            var adSkipText;

	            //set skip button
	            if (iOSInlinePlayerSelf.options.skippable.enabled === true) {

	                var videoThreshold = iOSInlinePlayerSelf.options.skippable.videoThreshold;
	                var skipText = iOSInlinePlayerSelf.options.skippable.skipText;
	                var skipButtonText = iOSInlinePlayerSelf.options.skippable.skipButtonText;

	                skipButton = iframeVideoWrapper.contentWindow.document.createElement("div");
	                skipButton.id = "skip_button";

	                skipButton.innerHTML = skipButtonText;
	                skipButton.className = 'top-bar-text';
	                skipButton.role = 'button';

	                skipButton.style['display'] = "none";
	                skipButton.style['cursor'] = "pointer";
	                skipButton.style['font-weight'] = "bold";
	                skipButton.style['margin-right'] = "1em";
	                skipButton.style['margin-left'] = "1em";
	                skipButton.style['font-size'] = "1em";
	                skipButton.style['right'] = "";
	                skipButton.style['left'] = "0px";
	                skipButton.style['line-height'] = "24px";
	                skipButton.style['outline'] = "0";
	                skipButton.style['position'] = "absolute";
	                skipButton.style['padding'] = "0";
	                skipButton.style['height'] = "5em";
	                skipButton.style['width'] = "auto";
	                skipButton.style['min-width'] = "5em";
	                skipButton.style['text-align'] = "left";

	                //skip button
	                iOSInlinePlayerSelf.floatingSkipButton = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                    className: 'top-bar-text',
	                    'role': 'button',
	                    'innerHTML': skipButtonText
	                });

	                iOSInlinePlayerSelf.floatingSkipButton.style['display'] = "none";
	                iOSInlinePlayerSelf.floatingSkipButton.style['cursor'] = "pointer";
	                iOSInlinePlayerSelf.floatingSkipButton.style['font-weight'] = "bold";
	                iOSInlinePlayerSelf.floatingSkipButton.style['margin-right'] = "1em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['margin-left'] = "1em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['font-size'] = "1em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['right'] = "";
	                iOSInlinePlayerSelf.floatingSkipButton.style['left'] = "0px";
	                iOSInlinePlayerSelf.floatingSkipButton.style['line-height'] = "3em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['outline'] = "0";
	                iOSInlinePlayerSelf.floatingSkipButton.style['position'] = "absolute";
	                iOSInlinePlayerSelf.floatingSkipButton.style['padding'] = "0";
	                iOSInlinePlayerSelf.floatingSkipButton.style['height'] = "5em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['min-width'] = "5em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['width'] = "auto";
	                iOSInlinePlayerSelf.floatingSkipButton.style['display'] = "none";
	                iOSInlinePlayerSelf.floatingSkipButton.style['text-align'] = "left";
	                videojsPlayer.addChild('button', {
	                    'el': iOSInlinePlayerSelf.floatingSkipButton
	                });

	                var handleSkip = function(e) {
	                    window.removeEventListener("orientationchange", iOSInlinePlayerSelf.eventOrientationChange);
	                    window.removeEventListener("resize", iOSInlinePlayerSelf.eventSizeChange);
	                    iOSInlinePlayerSelf.iOSVideoPlayer.destroy();
	                    playerManager.pause();
	                    playerManager.isFullscreen = iOSInlinePlayerSelf.isFullscreen;//to propogate iOS full screen state to VideoManager
	                    playerManager.forceToSkip = true;
	                    playerManager.destroy();
	                    playerManager.isCompleted = true;//added for VID-1035 moved for vid-1171
	                    e.stopPropagation();
	                    e.preventDefault();
	                    // videoObserver.disconnect();
	                };

	                skipButton.addEventListener("touchend", handleSkip);
	                skipButton.addEventListener("click", handleSkip);

	                iOSInlinePlayerSelf.floatingSkipButton.addEventListener("touchend", handleSkip);
	                iOSInlinePlayerSelf.floatingSkipButton.addEventListener("click", handleSkip);

	                adSkipText = iframeVideoWrapper.contentWindow.document.createElement("div");
	                adSkipText.id = "ad_skip_text";

	                adSkipText.innerHTML = skipButtonText;
	                adSkipText.className = 'top-bar-text';
	                adSkipText.role = 'button';

	                adSkipText.style['margin-left'] = "1em";
	                adSkipText.style['margin-right'] = "1em";
	                adSkipText.style['right'] = "";
	                adSkipText.style['left'] = "0px";
	                adSkipText.style['font-size'] = "1em";
	                adSkipText.style['line-height'] = "24px";
	                adSkipText.style['outline'] = "0";
	                adSkipText.style['position'] = "absolute";
	                adSkipText.style['text-align'] = "left";
	                adSkipText.style['padding'] = "0";
	                adSkipText.style['height'] = "3em";
	                adSkipText.style['width'] = "auto";
	                adSkipText.style['pointer-events'] = "none";
	                adSkipText.style['display'] = "none";



	                //skip text
	                iOSInlinePlayerSelf.floatingAdSkipText = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                    'role': 'button',
	                    'className': 'top-bar-text',
	                    'innerHTML': ""
	                });

	                iOSInlinePlayerSelf.floatingAdSkipText.style['margin-left'] = "1em";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['margin-right'] = "1em";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['right'] = "";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['left'] = "0px";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['font-size'] = "1em";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['line-height'] = "3em";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['outline'] = "0";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['position'] = "absolute";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['text-align'] = "left";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['padding'] = "0";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['height'] = "3em";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['width'] = "auto";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['pointer-events'] = "none";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['display'] = "none";
	                videojsPlayer.addChild('button', {
	                    'el': iOSInlinePlayerSelf.floatingAdSkipText
	                });

	                //switch position by option
	                switch (iOSInlinePlayerSelf.options.skippable.skipLocation) {
	                    case "top-right":
	                        skipButton.style['right'] = "0px";
	                        skipButton.style['left'] = "";
	                        skipButton.style['text-align'] = "right";

	                        adSkipText.style['right'] = "0px";
	                        adSkipText.style['left'] = "";

	                        iOSInlinePlayerSelf.floatingSkipButton.style['right'] = "0px";
	                        iOSInlinePlayerSelf.floatingSkipButton.style['left'] = "";
	                        iOSInlinePlayerSelf.floatingSkipButton.style['text-align'] = "right";

	                        iOSInlinePlayerSelf.floatingAdSkipText.style['right'] = "0px";
	                        iOSInlinePlayerSelf.floatingAdSkipText.style['left'] = "";
	                        break;
	                    default :
	                        break;
	                }

	                //quartile status to invoke only once
	                var quartile1status = false;
	                var quartile2status = false;
	                var quartile3status = false;

	                var _trackedProgressOffsetSorted = {};

	                var renderSkip = function() {
	                    var videoDuration = Math.round(videojsPlayer.player().duration());
	                    var currentTime = Math.round(videojsPlayer.player().currentTime());
	                    var offsetTime;

	                    if (playerManager.options.skippable.allowOverride) {
	                        offsetTime = Math.round(iOSInlinePlayerSelf.options.data.skipOffsetMsec / 1000);//trust vast3 setting
	                    } else {
	                        offsetTime = iOSInlinePlayerSelf.options.skippable.videoOffset;
	                    }

	                    var remainTime = offsetTime - currentTime;
	                    var needToShowSkip = (iOSInlinePlayerSelf.options.skippable.allowOverride) ? iOSInlinePlayerSelf.options.data.isVastVideoSkippable : true;
	                    needToShowSkip = (offsetTime > videoDuration) ? false :  needToShowSkip;

	                    // @exclude
	                    playerManager.test("VIDLA163_needToShowSkip",needToShowSkip);
	                    // @endexclude

	                    if (videoThreshold < videoDuration && !iOSInlinePlayerSelf.options.disableTopBar && needToShowSkip) {
	                        if (remainTime > 0 && !playerManager.startedReplay && !playerManager.isEnded) {
	                            iOSInlinePlayerSelf.floatingAdSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);
	                            skipButton.style.display = "none";
	                            adSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);
	                            adSkipText.style.display = "block";
	                            if (Utils.elementsOverlap(adSkipText, adIndicatorText)) {
	                                adSkipText.style.display = "none";
	                            }
	                        } else {
	                            // @exclude
	                            if (!iOSInlinePlayerSelf.readyForSkip) {
	                                playerManager.test("log", currentTime);
	                                playerManager.test("VIDLA163_skip", currentTime);
	                            }
	                            // @endexclude

	                            iOSInlinePlayerSelf.readyForSkip = true;

	                            if (iOSInlinePlayerSelf.isFullscreen) {
	                                iOSInlinePlayerSelf.floatingAdSkipText.style.display = "none";
	                                iOSInlinePlayerSelf.floatingSkipButton.style.display = "block";
	                            }

	                            adSkipText.style.display = "none";
	                            skipButton.style.display = "block";
	                        }
	                    }
	                };

	                videojsPlayer.on("resize", function () {
	                    renderSkip();
	                });

	                //handle tick event from video.js
	                videojsPlayer.on("timeupdate", function () {
	                    var _vastProgressEvent = playerManager.options.data.vastProgressEvent;

	                    if(iOSInlinePlayerSelf.options.isWaterfall && iOSInlinePlayerSelf.options.vpaid && !iOSInlinePlayerSelf.options.vpaidImpressionFired){
	                        return;
	                    }
	                    var currentTime = Math.round(videojsPlayer.player().currentTime());
	                    var _currentTimeMsec = currentTime * 1000;

	                    //handle vast3 progress event
	                    if (_vastProgressEvent && typeof(_vastProgressEvent) === "object") {

	                        var _progressCallback = function () {
	                            // @exclude
	                            playerManager.test("VIDLA163_Tracking", _trackedProgressOffsetSorted);
	                            // @endexclude
	                        };
	                        for (var _eventKey in _vastProgressEvent) {
	                            var _progressMsec = _vastProgressEvent[_eventKey];
	                            if (_progressMsec && _progressMsec >= 0 && _currentTimeMsec >= _progressMsec && Object.keys(_trackedProgressOffsetSorted).indexOf(_eventKey) === -1) {
	                                _trackedProgressOffsetSorted[_eventKey] = _progressMsec;
	                                var obj = {};
	                                obj.name = _eventKey;
	                                if (obj.name) {
	                                    playerManager.dispatchEventToAdunit(obj, _progressCallback);
	                                }
	                            }
	                        }
	                    }

	                    renderSkip();
	                });
	            }

	            //switch position by option
	            if (iOSInlinePlayerSelf.options.skippable && iOSInlinePlayerSelf.options.skippable.skipLocation) {
	                switch (iOSInlinePlayerSelf.options.skippable.skipLocation) {
	                    case "top-right":
	                        adIndicatorText.style['right'] = "";
	                        adIndicatorText.style['left'] = "0px";

	                        iOSInlinePlayerSelf.floatingAdIndicator.style['right'] = "";
	                        iOSInlinePlayerSelf.floatingAdIndicator.style['left'] = "0px";
	                        break;
	                    default :
	                        break;
	                }
	            }

	            if (!iOSInlinePlayerSelf.options.disableTopBar && topChrome) {
	                if (iOSInlinePlayerSelf.options.skippable.enabled === true) {
	                    topChrome.appendChild(skipButton);
	                    topChrome.appendChild(adSkipText);
	                }
	                topChrome.appendChild(adIndicatorText);
	            }


	            //set quartile event
	            videojsPlayer.on("timeupdate", function () {
	                if (iOSInlinePlayerSelf.options.vpaid) {
	                    return;
	                }
	                var currentTime = Math.round(videojsPlayer.player().currentTime());
	                var videoDuration = videojsPlayer.player().duration();

	                var quartile1 = videoDuration / 4;
	                var quartile2 = videoDuration / 4 * 2;
	                var quartile3 = videoDuration / 4 * 3;


	                if (!quartile1status && currentTime >= quartile1 && currentTime < quartile2) {
	                    iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video-first-quartile"});
	                    quartile1status = true;
	                }

	                if (!quartile2status && currentTime >= quartile2 && currentTime < quartile3) {
	                    iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video-mid"});
	                    quartile2status = true;
	                }

	                if (!quartile3status && currentTime >= quartile3) {
	                    iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video-third-quartile"});
	                    quartile3status = true;
	                }
	            });

	            var handleBigPlayButton = function() {
	                if (playerManager.isEnded && iOSInlinePlayerSelf.options.disableCollapse.replay) {
	                    playerManager.replay();
	                    if (iOSInlinePlayerSelf.options.showBigPlayButton === false) {
	                        videojsPlayer.player().bigPlayButton.hide();
	                    }
	                    videojsPlayer.player().bigPlayButton.removeClass("vjs-big-play-button-replay");
	                }
	                if (playerManager.isDoneInitialPlay) {
	                    playerManager.isPlayingVideo = false;
	                }
	                playerManager.explicitPlay();
	            };

	            //for mobile
	            videojsPlayer.player().bigPlayButton.on("touchend", function (e) {
	                handleBigPlayButton();
	                e.preventDefault();
	            });
	            videojsPlayer.player().bigPlayButton.on("click", function() {
	                handleBigPlayButton();
	            });

	            videojsPlayer.on("error", function () {
	                playerManager.destroyWithoutSkip(true, CONST_MESSAGE_GENERAL_ERROR,null, 900);
	            });


	            //change event handling part here for VID-1820, the issue is caused by that "firstplay" gets invoked earlier than "play" and that interferes with flags which will decide to invoke events
	            //and we were waiting this "firstplay" to fire VAST "start" but it's unnecessary because iOS inline fakes "play" method of video element and modules will invoke "video_start" explicitly.
	            //so it will be okay not to handle firstplay for iOS
	            // videojsPlayer.on("firstplay", function () {
	            //     iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "firstplay"});
	            // });

	            videojsPlayer.on("loadstart", function () {
	                iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "loadstart"});
	            });

	            videojsPlayer.on("pause", function () {
	                //iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video_pause"});


	                var isSideStreamActivated = playerManager.options.sideStream && playerManager.options.sideStream.enabled && playerManager.options.sideStreamObject && playerManager.options.sideStreamObject.isActivated;
	                if (isSideStreamActivated === true && playerManager.options.showPlayToggle === true && playerManager.options.sideStream.dynamicBigPlayButtonOnSideStream == true) {
	                    //do nothing for VIDLA-2207
	                } else {
	                    //show big resume
	                    if (!playerManager.isFullscreen) {
	                        videojsPlayer.player().bigPlayButton.el().style.display = "block";
	                    }
	                }



	            });


	        },
	    };
	};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	var _logger = __webpack_require__(9);
	var log = function (message) {
	    _logger.log("Video Player: " + message);
	};
	var debug = function (message) {
	    _logger.debug("Video Player: " + message);
	};

	/**
	 * InitializeElements
	 * @param iOSInlinePlayerSelf
	 * @param playerManager
	 * @returns {{acreateIframeAndRequiredObject: acreateIframeAndRequiredObject}}
	 */
	module.exports = function (iOSInlinePlayerSelf, playerManager) {


	    return {

	        createIframeAndRequiredObject: function (cbNextStep) {
	            /**
	             * first step to generate iframe and preapr all requried html objects
	             * @param cbNextStep
	             */

	            log("createIframeAndRequiredObject");

	            var options = iOSInlinePlayerSelf.options;

	            var iframeVideoWrapper = document.createElement("iframe");//generate iframe
	            iframeVideoWrapper.src = "about:blank";
	            options.targetElement.appendChild(iframeVideoWrapper);
	            iframeVideoWrapper.style.width = options.width + "px";
	            iframeVideoWrapper.style.height = options.height + "px";
	            iframeVideoWrapper.id = options.iframeVideoWrapperId;
	            iframeVideoWrapper.setAttribute("allowfullscreen", "true");//allow fullscreen in iframe
	            iframeVideoWrapper.setAttribute("webkitallowfullscreen", "true");
	            iframeVideoWrapper.setAttribute("mozallowfullscreen", "true");

	            //VIDLA-90 fix IAS viewability tracking issue to have proper Iframe.location.origin
	            //var defaultTemplate = "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body style=\"margin:0px;overflow:hidden;\">\n</body>\n</html>\n";
	            var defaultTemplate = "<html></html>";//fix VIDLA-320 to have null doctype like we did before - it means this is the same with not invoking .write("") like we did at the begining of this project

	            iframeVideoWrapper.contentWindow.document.open();
	            iframeVideoWrapper.contentWindow.document.write(defaultTemplate);
	            iframeVideoWrapper.contentWindow.document.close();

	            //temporary allowing setting of fullscreen video button to be enabled for QA and off for production
	            if (typeof options.enableInlineVideoFullscreenButton !== 'undefined') {
	                iOSInlinePlayerSelf.enableFullscreen = options.enableInlineVideoFullscreenButton;
	            }

	            var IframeDocument = iframeVideoWrapper.contentWindow.document;
	            var IframeWindow = iframeVideoWrapper.contentWindow.window;

	            //create top chrome bar
	            debug("Creating and styling top chrome bar");
	            var topChrome = IframeDocument.createElement("div");
	            topChrome.id = "top_chrome";
	            topChrome.style.height = (function () {
	                if (options.playerSkin && typeof options.playerSkin.dividerHeight === "number") {
	                    return iOSInlinePlayerSelf.topChromeHeight - options.playerSkin.dividerHeight + "px";
	                }
	                return iOSInlinePlayerSelf.topChromeHeight - 1 + "px";
	            })();
	            topChrome.style.width = options.width + "px";
	            topChrome.style.marginRight = "auto";
	            topChrome.style.marginLeft = "auto";
	            topChrome.className = "video-js vjs-default-skin";

	            //generate video object
	            debug("Generating and styling video object");
	            var videoEl = IframeDocument.createElement("video");
	            videoEl.id = iOSInlinePlayerSelf.an_video_ad_player_id;
	            videoEl.className = "video-js vjs-default-skin";//set default skin
	            videoEl.style.marginRight = "auto";
	            videoEl.style.marginLeft = "auto";
	            topChrome.style["z-index"] = videoEl.style["z-index"] + 1;

	            if (!options.vpaid) {
	                //generate source object
	                debug("Generating source object");
	                var mp4Source = IframeDocument.createElement("source");
	                mp4Source.type = "video/mp4";
	                mp4Source.src = options.videoUrl;
	                videoEl.appendChild(mp4Source);
	            }

	            //inject required object into iframe
	            debug("Injecting required elements into iframe");
	            if (!options.disableTopBar) {
	                IframeDocument.body.appendChild(topChrome);
	            }
	            IframeDocument.body.appendChild(videoEl);
	            IframeWindow.videojs = iOSInlinePlayerSelf.videojsOrigin;


	            IframeDocument.body.style.margin = "0px";
	            IframeDocument.body.style.overflow = "hidden";

	            if (options.vpaid) {
	                //inject javascript vpaid module to iframe
	                var videojsVpaidScript = IframeDocument.createElement("script");
	                videojsVpaidScript.innerHTML = playerManager.videojs_vpaid;
	                IframeDocument.head.appendChild(videojsVpaidScript);
	            }

	            cbNextStep(iframeVideoWrapper);//pass prepared iframe object


	        }

	    };
	};

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	/**
	 * flashVideoPlayer
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 */
	var flashVideoPlayer = function (playerManager, cbInjectEventToPlayer) {


	    //getting required object from adVideoPlayerManager
	    var options = playerManager.options;
	    var targetElement = options.targetElement;
	    var vpaidData = playerManager.vpaidData;


	    //handle VAST3
	    var vastSkipOffset = options.data.skipOffset;//skipOffset like 00:00:2.999999
	    var vastProgressEvents = options.data.vastProgressEvent;//comma separated progress event names like progress_00:00:01,progress_00:00:02.500
	    if (vastProgressEvents && typeof(vastProgressEvents) === "object") {
	        vastProgressEvents = Object.keys(vastProgressEvents).toString();

	        // @exclude
	        playerManager.test("VIDLA163_flash", vastProgressEvents);
	        // @endexclude

	        // VIDLA-513. Remove '%' chars because for '%' in flash vars we need encoding. 
	        // Flash player will added '%' by itself if needed.
	        vastProgressEvents = vastProgressEvents.replace(/%/g, '');
	    }
	    // @exclude
	    playerManager.test("VIDLA163_skipoffset", vastSkipOffset);
	    // @endexclude

	    //getting required object from adVideoPlayerManager (module using internal value)
	    var log = playerManager.log.bind(playerManager);


	    // preapare vpaid data
	    if (options.vpaid) {
	        vpaidData = {};
	        vpaidData.adParameters = options.adParameters ? options.adParameters : null;
	        vpaidData.extensions = options.extensions ? options.extensions : null;
	    }


	    log("WE ARE USING FLASH PLAYER");

	    //generate iframe
	    /*var iframeVideoWrapper = document.createElement("iframe");
	     iframeVideoWrapper.style.width = options.width + "px";
	     iframeVideoWrapper.style.height = options.height + "px";
	     iframeVideoWrapper.id = "iframeVideoWrapper";

	     targetElement.appendChild(iframeVideoWrapper);
	     iframeVideoWrapper.contentWindow.document.body.style.margin = "0px";*/



	    var uid = new Date().getTime() + Math.floor(Math.random() * 10000);

	    var flashObj = document.createElement("object");
	    flashObj.type = 'application/x-shockwave-flash';
	    flashObj.data = options.flash.swf;
	    flashObj.width = (playerManager.isChrome ? "0" : options.width) + "px";
	    flashObj.height = (playerManager.isChrome ? "0" : options.height) + "px";
	    flashObj.id = 'apn_flash_player_' + uid;

	    //flashObj.style.display = 'block';


	    //flashObj.style.position = 'absolute';
	    flashObj.style.top = '0';
	    flashObj.style.left = '0';
	    if (options.hasOwnProperty('overlayPlayer')) {
	        flashObj.style.width = options.width + "px";
	        flashObj.style.height = options.height + "px";
	    	
	    }
	    else {
	        flashObj.style.width = (playerManager.isChrome ? "0" : options.width) + "px";
	        flashObj.style.height = (playerManager.isChrome ? "0" : options.height) + "px";
	    }
	    /*var par1 = document.createElement('param');
	     par1.name = 'movie';
	     par1.value = options.flash.swf;
	     flashObj.appendChild(par1);*/
	    var par2 = document.createElement('param');
	    par2.name = 'flashvars';

	    // set options to flashvars
	    par2.value = 'video=' + encodeURIComponent(options.videoUrl) +
	        '&autoplay=' + options.autoplay +
	        '&initialPlayback=' + options.initialPlayback +
	        '&canScale=' + options.canScale +
	        '&maintainAspectRatio=' + options.maintainAspectRatio +
	        '&muted=' + options.muted +
	        '&showMute=' + options.showMute +
	        '&showVolume=' + options.showVolume +
	        '&showProgressBar=' + options.showProgressBar +
	        '&allowFullscreen=' + options.allowFullscreen +
	        '&playOnMouseover=false' +
	        '&audioOnMouseover=false' +
	        '&initialAudio=' + options.initialAudio +
	        '&adText=' + options.adText +
	        '&vpaid=' + options.vpaid + '&external=' + options.communicator;
	    
	    par2.value += ('&containerWidth=' + options.width + '&containerHeight=' + options.height);
	    
	    if (options.hasOwnProperty('overlayPlayer')) {
	    	par2.value += '&overlayPlayer=true';
	    }

	    if (options.hasOwnProperty('fullscreenMode')) {
	    	par2.value += ('&fullscreenMode=' + options.fullscreenMode);
	    }

	    if (options.vpaid && options.vpaidDuration) {
	        par2.value += ('&vpaidDuration=' + options.vpaidDuration);
	    }
	    if (options.terminateUnresponsiveVPAIDCreative) {
	        par2.value += ('&terminateUnresponsiveVPAIDCreative=' + options.terminateUnresponsiveVPAIDCreative);
	    }
	    if (options.vpaid && options.vpaidTimeout) {
	        par2.value += ('&vpaidTimeout=' + options.vpaidTimeout);
	    }
	    if (options.cbNotification) {
	    	par2.value += '&needFeedback=true';
	    }
	    if (options.disableCollapse && options.disableCollapse.hasOwnProperty('enabled')) {
	    	par2.value += ("&disableCollapse=" + options.disableCollapse.enabled);
	    }
	    if (options.playerSkin && options.playerSkin.topDividerColor) {
	    	par2.value += ("&dividerColor=" + options.playerSkin.topDividerColor);
	    }
	    if (options.playerSkin && options.playerSkin.topDividerWidth) {
	    	par2.value += ("&dividerWidth=" + options.playerSkin.topDividerWidth);
	    }
	    if (options.disableTopBar) {
	    	par2.value += ("&supressTopBar=" + options.disableTopBar);
	    }
	    if (options.hasOwnProperty('delayExpandUntilVPAIDImpression')) {
	    	par2.value += ("&delayExpandUntilVPAIDImpression=" + options.delayExpandUntilVPAIDImpression);
	    }
	    if (options.skippable && options.skippable.enabled === true) {
	        par2.value += ('&videoThreshhold=' + options.skippable.videoThreshold +
	        '&videoOffset=' + options.skippable.videoOffset +
	        '&skipLocation=' + options.skippable.skipLocation +
	        '&skipText=' + encodeURIComponent(options.skippable.skipText) +
	        '&skipButtonText=' + encodeURIComponent(options.skippable.skipButtonText) +
	        '&allowOverride=' + encodeURIComponent(options.skippable.allowOverride));
	    }
	    if (vastProgressEvents) {
	        par2.value += '&vastProgressEvents=' + vastProgressEvents;
	    }
	    if (vastSkipOffset) {
	        par2.value += '&vastSkipOffset=' + vastSkipOffset;
	    }
	    flashObj.appendChild(par2);
	    var par3 = document.createElement('param');
	    par3.name = 'allowScriptAccess';
	    par3.value = 'always';
	    flashObj.appendChild(par3);
	    var par4 = document.createElement('param');
	    par4.name = 'allowNetworking';
	    par4.value = 'all';
	    flashObj.appendChild(par4);
	    var par5 = document.createElement('param');
	    par5.name = 'allowNetworking';
	    par5.value = 'all';
	    flashObj.appendChild(par5);
	    var par6 = document.createElement('param');
	    par6.name = 'wmode';
	    par6.value = 'opaque';
	    flashObj.appendChild(par6);
	    if (options.allowFullscreen) {
	        var par7 = document.createElement('param');
	        par7.name = 'allowFullScreen';
	        par7.value = 'true';
	        flashObj.appendChild(par7);
	    }

		// protection against freezing by flash blockers
		var tm = options.hasOwnProperty('vpaidTimeout') && options.vpaidTimeout ? options.vpaidTimeout : 5000;
		playerManager.flashBlockerTimeout = setTimeout ( function() {
			clearTimeout(playerManager.flashBlockerTimeout);
			playerManager.flashBlockerTimeout = null;
			
			playerManager.isPlayingVideo = false;
	        var code = 405;		//VAST Error code - problem displaying MediaFile
	        if (options.hasOwnProperty('overlayPlayer')) {
	            playerManager.callbackForAdUnit.cbWhenDestroy({type: 1, code: code, message: 'Flash player blocked by browser'}, true);
	        }
	        else {
	            playerManager.destroyWithoutSkip(true, 'Flash player blocked by browser', null, code);
	        }
		}, tm);

	    targetElement.appendChild(flashObj);
	    
	    playerManager.adVideoPlayer = flashObj;
	    window[options.communicator] = playerManager;//re assign lastest object
	    cbInjectEventToPlayer(flashObj, null);


	};

	module.exports = flashVideoPlayer;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	var prefixOfLog = "[UserSync]";
	var APN_Logger = __webpack_require__(9);
	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog, message);
	};

	//VIDLA-1383
	var UserSync = function() {
	    debug("initiated");
	    this.isComplete = false;

	    this.run = function(options) {
	        debug("start UserSync");
	        try {
	            if (this.isComplete) {
	                debug("stop UserSync because it's already done");
	            } else {
	                var targetElement = options.userSyncTargetElement ? options.userSyncTargetElement : options.targetElement;
	                if (options && options.usersync_url && typeof(options.usersync_url) === "string" && options.usersync_url !== "" && 
	                	targetElement && typeof(targetElement) === "object") {
	                    this.executeUserSync(options, targetElement);
	                    this.isComplete = true;
	                    debug("done");
	                } else {
	                    debug("stop UserSync because it needs proper options.usersync_url and options.targetElement/options.userSyncTargetElement");
	                }
	            }
	        } catch (ex) {
	            debug("error: " + ex);
	        }

	    };

	    this.executeUserSync = function(options, targetElement) {
	        if (targetElement.ownerDocument && targetElement.ownerDocument.getElementById("apn_user_sync")) {
	            debug("stop UserSync because it's already done");
	        }
	        else {
		        debug("decode UserSync url");
		        var userSyncUrl = decodeURIComponent(options.usersync_url);
		        this.prepareIframeAndScript(userSyncUrl, targetElement);
	        }
	    };

	    this.prepareIframeAndScript = function(userSyncUrl, targetElement) {
	        debug("prepareIframeAndScript: " + userSyncUrl);

	        var iframe = document.createElement('iframe');
	        iframe.id = "apn_user_sync";

	        iframe.src = userSyncUrl;
	        iframe.width = "1";
	        iframe.height = "1";
	        iframe.frameborder = "0";
	        iframe.scrolling = "no";
	        iframe.marginheight = "0";
	        iframe.marginwidth = "0";
	        iframe.topmargin = "0";
	        iframe.leftmargin = "0";
	        iframe.style.position = "absolute";
	        iframe.style.overflow = "hidden";
	        iframe.style.clip = "rect(0 0 0 0)";
	        iframe.style.height = "1px";
	        iframe.style.width = "1px";
	        iframe.style.margin = "-1px";
	        iframe.style.padding = "0";
	        iframe.style.border = "0";

	        //iframe.style.display = "none";
	        targetElement.appendChild(iframe);

	        debug("UserSync iframe injected into target element: " + targetElement.id);
	    };
	};

	//singleton because this should be executed only onetime in life of adunits
	var UserSyncSingleton = (function () {
	    var instance;

	    var createInstance = function() {
	        var object = new UserSync();
	        return object;
	    };

	    return {
	        "sharedInstance": function () {
	            if (!instance) {
	                instance = createInstance();
	            }
	            return instance;
	        }
	    };
	})();

	module.exports = UserSyncSingleton;



/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	var Utils = __webpack_require__(8);

	var prefixOfLog = "PlayerManager_VideoSizeHandler";
	var APN_Logger = __webpack_require__(9);
	var debug = function (message) {
	    APN_Logger.verbose(message, prefixOfLog);
	};
	var warn = function (message) {
	    APN_Logger.warn(message, prefixOfLog);
	};
	// var error = function (message) {
	//     APN_Logger.error(message, prefixOfLog);
	// };
	// var info = function (message) {
	//     APN_Logger.info(message, prefixOfLog);
	// };



	/**
	 * resizeVideo
	 * @param aspectRatio
	 * @param shouldConsiderHeightOfDevice
	 * @param playerManager
	 */
	var resizeVideo = function(aspectRatio, shouldConsiderHeightOfDevice, playerManager, callback) {
	    debug("resizeVideo");
	    //handle playerManager's refernece
	    var options = playerManager.options;
	    var isIosInlineRequired = playerManager.isIosInlineRequired.bind(playerManager);
	    var decidePlayer = playerManager.decidePlayer.bind(playerManager);
	    var iframeVideoWrapper = playerManager.iframeVideoWrapper;
	    var adVideoPlayer = playerManager.adVideoPlayer;

	    //set internal variables
	    var calculatedWidth = options.width;
	    var mediaHeight;
	    var topOffset = 0;
	    var bottomOffset = 0;
	    var mediaAspectRatio;
	    var aspectRatioOption;
	    var wrapperHeight; //it was playerHeight but iframeHeight will be more clear
	    var hasStaticHeight = false;
	    var fixedSizePlayer = options.fixedSizePlayer;
	    var vastWidth = options.video.width; //VAST width came from rendition manager
	    var vastHeight = options.video.height; //VAST width came from rendition manager

	    var useStaticControlBar = function() {
	        return (Utils.isAndroid() || isIosInlineRequired() || options.controlBarPosition === "below");
	    };


	    //first step - resolve width
	    if (options.autoInitialSize) {

	        //VID-1788,1789
	        if (options.sideStream && options.sideStream.enabled === true && options.emptyDiv) {//if side stream is activated, resize will work with div of empty space injected by SideStream module
	            calculatedWidth = options.emptyDiv.offsetWidth;
	        } else {
	            calculatedWidth = options.targetElement.offsetWidth;
	            if( calculatedWidth === 0 ){
	                calculatedWidth = options.width;
	                warn("AutoInitialSize could not find parent element width, using tag width");
	            }
	        }

	    }


	    aspectRatioOption = options.aspectRatio || options.playerAspectRatio; // removed support for playerHeight and player_height here [deprecated]

	    debug("options.height : " + options.height);
	    if (Utils.isEmpty(aspectRatioOption)) {
	        if (Utils.isEmpty(options.height)) {
	            aspectRatioOption = "16:9";
	        } else {
	            aspectRatioOption = "none";
	        }
	    }

	    debug("aspectRatioOption : " + aspectRatioOption);

	    //set media aspect ratio by VAST value
	    //TODO: do we ever look at actual selected video metadata?
	    if (typeof vastWidth === "undefined" || typeof vastHeight === "undefined" || vastWidth === 0 || vastHeight === 0) {
	        mediaAspectRatio = (16 / 9); //aspect ratio for 16:9
	    } else {
	        mediaAspectRatio = vastWidth / vastHeight;
	    }

	    if (!options.disableTopBar) {
	        topOffset = 24; //default height for topBar
	    }

	    if (useStaticControlBar()) {
	        bottomOffset += options.playerSkin.controlBarHeight;

	        //remove this factor by a decision for VIDLA-1692
	        // if (playerManager.adVideoPlayer.controlBar && playerManager.adVideoPlayer.controlBar.progressControl) {
	            // bottomOffset += playerManager.adVideoPlayer.controlBar.progressControl.el_.offsetHeight;
	        // }
	    }

	    debug("initial VAST width : " + vastWidth);
	    debug("initial VAST height : " + vastHeight);
	    debug("initial topOffset : " + topOffset);
	    debug("initial bottomOffset : " + bottomOffset);
	    debug("initial mediaAspectRatio : " + mediaAspectRatio);

	    //if fixedSizePlayer is true, only use the width and height of the options for the player
	    //player will never be bigger than width and height in this case
	    if (fixedSizePlayer) {
	        wrapperHeight = options.height;
	        calculatedWidth = options.width;
	        mediaHeight = options.height - topOffset - bottomOffset;
	    } else {
	        //if not fixed size player (we calculate size)

	        //split aspect ratio option
	        var ratioArray = aspectRatioOption.split(":");
	        //if we have the right format aspect ratio, for example x:y
	        //calculatedWidth is either options width or autoInitialSize width
	        if (ratioArray.length === 2) {
	            try {
	                //For aspect ratio x:y
	                mediaAspectRatio = (ratioArray[0] / ratioArray[1]);
	            } catch (e) {
	                debug(e);
	            } //if we can't set media aspect ratio, use default value
	        }
	        //set media height
	        mediaHeight = Math.round(calculatedWidth / mediaAspectRatio);

	        debug("pure : " + calculatedWidth + "," + mediaAspectRatio);
	        debug("pure mediaHeight: " + mediaHeight);
	        var correctionHeightForAndroid = 0;

	        // if (Utils.isAndroid()) {
	        //     correctionHeightForAndroid = 3;
	        // }

	        wrapperHeight = (mediaHeight - correctionHeightForAndroid) + topOffset + bottomOffset;
	    }

	    options.height = wrapperHeight;
	    options.mediaHeight = mediaHeight;

	    if (decidePlayer(options.requiredPlayer) === "html5") {

	        if (iframeVideoWrapper && typeof iframeVideoWrapper === "object" && iframeVideoWrapper.style) {

	            //Browser user agent might add an iframe border
	            //This will overwrite it
	            iframeVideoWrapper.style.border = "none";
	            iframeVideoWrapper.style.width = calculatedWidth + "px";
	            iframeVideoWrapper.style.height = wrapperHeight + "px";
	            iframeVideoWrapper.style.position = "absolute";

	            if (options.shouldResizeVideoToFillMobileWebview && (mediaHeight + bottomOffset + topOffset) < window.innerHeight) {
	                iframeVideoWrapper.style.top = window.innerHeight / 2.0 - wrapperHeight / 2.0 + "px";
	            } else {
	                iframeVideoWrapper.style.top = "0" + "px";
	            }

	            if(iframeVideoWrapper.contentWindow){
	                var topChrome = iframeVideoWrapper.contentWindow.document && iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");//more safe way to access element which might not exists for VID-1923
	                if (topChrome) {
	                    topChrome.style.width = calculatedWidth +"px";

	                    //VID 1837 - restore original margin setting due to SideStream changed the margin, but it's important to restore it to original because of options.alignment feature on outstream, that alignement is only meaningful only on Outstream
	                    topChrome.style.marginLeft = "auto";
	                    topChrome.style.marginRight = "auto";
	                }
	            }

	            playerManager.adVideoPlayer.el_.style.marginLeft = "auto";
	            playerManager.adVideoPlayer.el_.style.marginRight = "auto";


	            debug("final wrapper width for html5 : " + calculatedWidth);
	            debug("final wrapper height for html5 : " + wrapperHeight);

	        }

	        //resize video
	        adVideoPlayer.width(calculatedWidth);

	        //VID-1790
	        if (options.sideStream && options.sideStream.enabled === true && options.emptyDiv) {//if SideStream is activated, targetElement should be changed to work properly at the corder of video
	            options.targetElement.style.width = calculatedWidth + "px";//VID-1808
	        } else {
	            options.targetElement.style.width = "";//VID-1808
	        }

	        debug("resize video.js width to : " + calculatedWidth);


	        debug("shouldConsiderHeightOfDevice : " + shouldConsiderHeightOfDevice);
	        debug("hasStaticHeight : " + hasStaticHeight);
	        debug("mediaHeight + bottomOffset + topOffset : " + (mediaHeight + bottomOffset + topOffset));
	        debug("window.innerHeight : " + window.innerHeight);

	        //VID-1020 if it's mobile(shouldConsiderHeightOfDevice = true)
	        if (shouldConsiderHeightOfDevice && (mediaHeight + bottomOffset + topOffset) > window.innerHeight) {
	            //resize height with considering viewport height

	            var mobileVideoJSHeight = window.innerHeight - topOffset - bottomOffset;
	            var mobileOptionsHeight = window.innerHeight;
	            var mobileMedieHeight = window.innerHeight - bottomOffset - topOffset;

	            adVideoPlayer.height(mobileVideoJSHeight);
	            options.height = mobileOptionsHeight;
	            options.mediaHeight = mobileMedieHeight;

	            debug("mobile set video.js height to : " + mobileVideoJSHeight);
	            debug("mobile options.height to : " + mobileOptionsHeight);
	            debug("mobile options.mediaHeight to : " + mobileMedieHeight);

	            debug("mobile set iframeVideoWrapper to : " + mobileVideoJSHeight);
	            iframeVideoWrapper.style.height = mobileVideoJSHeight + "px";//VIDLA-779


	        } else {
	            //resize video as usual
	            var desktopVideoJSHeight = mediaHeight;
	            if (!useStaticControlBar() || isIosInlineRequired()) {//iOS inline has to have bottomOffset
	                desktopVideoJSHeight += bottomOffset;
	            }

	            //correct to have proper height of whole area of adunit
	            // if (Utils.isAndroid()) {
	            // if (options.controlBarPosition === "below") {
	            //
	            //     //desktopVideoJSHeight += 5;//controlBarHeight 30 => 5
	            //     // desktopVideoJSHeight += 5 + 5;//controlBarHeight 35 => 10
	            //     // desktopVideoJSHeight += 5 + 5 + 5;//controlBarHeight 40 => 15
	            //     // desktopVideoJSHeight += 5 + 5 + 5 + 5;//controlBarHeight 45  => 20
	            //     // desktopVideoJSHeight += 5 + 5 + 5 + 5 + 5;//controlBarHeight 50 => 25
	            //     desktopVideoJSHeight += bottomOffset - topOffset - 3 - (options.playerSkin.controlBarHeight - 30);//3 pixel is borders and progress bar;
	            // }

	            //correct to have proper height of whole area of adunit
	            // if (Utils.isAndroid()) {
	            //     //desktopVideoJSHeight += 5;//controlBarHeight 30 => 5
	            //     // desktopVideoJSHeight += 5 + 5;//controlBarHeight 35 => 10
	            //     // desktopVideoJSHeight += 5 + 5 + 5;//controlBarHeight 40 => 15
	            //     // desktopVideoJSHeight += 5 + 5 + 5 + 5;//controlBarHeight 45  => 20
	            //     // desktopVideoJSHeight += 5 + 5 + 5 + 5 + 5;//controlBarHeight 50 => 25
	            //
	            //     desktopVideoJSHeight += bottomOffset - topOffset - 3;//3 pixel is borders and progress bar;
	            //
	            // }


	            // debugger;
	            adVideoPlayer.height(desktopVideoJSHeight);
	            debug("desktop set video.js height to : " + desktopVideoJSHeight);
	        }

	        if (playerManager.isEnded && playerManager.endCard) {
	            playerManager.endCard.onVideoResized(calculatedWidth, mediaHeight);
	        }
	    } else {
	        //flash
	        adVideoPlayer.width = calculatedWidth + "px";
	        adVideoPlayer.height = wrapperHeight + "px";
	        adVideoPlayer.style.width = calculatedWidth + "px";
	        adVideoPlayer.style.height = wrapperHeight + "px";

	        debug("flash width : " + calculatedWidth);
	        debug("flash height : " + wrapperHeight);


	    }

	    options.targetElement.style.visibility = "visible";
	    if (typeof(callback) === "function") {
	        callback();
	    }

	};

	/**
	 * resizeVideoForSideStream
	 * @param playerManager
	 * @param width
	 * @param height
	 */
	var resizeVideoForSideStream = function(playerManager, width, height,cb) {


	    var shouldConsiderHeightOfDevice = false;

	    debug("resizeVideo-sidestream");
	    //handle playerManager's refernece
	    var options = playerManager.options;
	    var isIosInlineRequired = playerManager.isIosInlineRequired.bind(playerManager);
	    var decidePlayer = playerManager.decidePlayer.bind(playerManager);
	    var iframeVideoWrapper = playerManager.iframeVideoWrapper;
	    var adVideoPlayer = playerManager.adVideoPlayer;


	    //set internal variables
	    var calculatedWidth = width;
	    var mediaHeight;
	    var topOffset = 0;
	    var bottomOffset = 0;
	    var mediaAspectRatio;
	    var aspectRatioOption;
	    var wrapperHeight; //it was playerHeight but iframeHeight will be more clear
	    var fixedSizePlayer = true;//this is for sideStream and sideStream only has fixedSizePlayer
	    var vastWidth = options.video.width; //VAST width came from rendition manager
	    var vastHeight = options.video.height; //VAST width came from rendition manager

	    var useStaticControlBar = function() {
	        return (Utils.isAndroid() || isIosInlineRequired() || options.controlBarPosition === "below");
	    };



	    aspectRatioOption = options.aspectRatio || options.playerAspectRatio; // removed support for playerHeight and player_height here [deprecated]

	    debug("options.height : " + height);
	    if (Utils.isEmpty(aspectRatioOption)) {
	        if (Utils.isEmpty(height)) {
	            aspectRatioOption = "16:9";
	        } else {
	            aspectRatioOption = "none";
	        }
	    }

	    debug("aspectRatioOption : " + aspectRatioOption);

	    //set media aspect ratio by VAST value
	    //TODO: do we ever look at actual selected video metadata?
	    if (typeof vastWidth === "undefined" || typeof vastHeight === "undefined" || vastWidth === 0 || vastHeight === 0) {
	        mediaAspectRatio = (16 / 9); //aspect ratio for 16:9
	    } else {
	        mediaAspectRatio = vastWidth / vastHeight;
	    }

	    if (!options.disableTopBar) {
	        topOffset = 24; //default height for topBar
	    }

	    if (useStaticControlBar()) {
	        bottomOffset += options.playerSkin.controlBarHeight;

	        //remove this factor by a decision for VIDLA-1692
	        //if (playerManager.adVideoPlayer.controlBar && playerManager.adVideoPlayer.controlBar.progressControl) {
	            // bottomOffset += playerManager.adVideoPlayer.controlBar.progressControl.el_.offsetHeight;
	        //}
	    }

	    debug("initial VAST width : " + vastWidth);
	    debug("initial VAST height : " + vastHeight);
	    debug("initial topOffset : " + topOffset);
	    debug("initial bottomOffset : " + bottomOffset);
	    debug("initial mediaAspectRatio : " + mediaAspectRatio);

	    //if fixedSizePlayer is true, only use the width and height of the options for the player
	    //player will never be bigger than width and height in this case
	    if (fixedSizePlayer) {
	        wrapperHeight = height;
	        calculatedWidth = width;
	        mediaHeight = height - topOffset - bottomOffset;
	    } else {
	        //if not fixed size player (we calculate size)

	        //split aspect ratio option
	        var ratioArray = aspectRatioOption.split(":");
	        //if we have the right format aspect ratio, for example x:y
	        //calculatedWidth is either options width or autoInitialSize width
	        if (ratioArray.length === 2) {
	            try {
	                //For aspect ratio x:y
	                mediaAspectRatio = (ratioArray[0] / ratioArray[1]);
	            } catch (e) {
	                debug(e);
	            } //if we can't set media aspect ratio, use default value
	        }
	        //set media height
	        mediaHeight = Math.round(calculatedWidth / mediaAspectRatio);
	        wrapperHeight = mediaHeight + topOffset + bottomOffset;
	    }

	    //for having a size defined by side stream options
	    if (height && width) {
	        options.mediaHeight = mediaHeight;
	    }

	    if (decidePlayer(options.requiredPlayer) === "html5") {

	        if (iframeVideoWrapper && typeof iframeVideoWrapper === "object" && iframeVideoWrapper.style) {

	            //Browser user agent might add an iframe border
	            //This will overwrite it
	            iframeVideoWrapper.style.border = "none";
	            iframeVideoWrapper.style.width = calculatedWidth + "px";
	            iframeVideoWrapper.style.height = wrapperHeight + "px";

	            if(iframeVideoWrapper.contentWindow){
	                var topChrome = iframeVideoWrapper.contentWindow.document && iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");//more safe way to access element which might not exists for VID-1923
	                if (topChrome) {
	                    topChrome.style.width = calculatedWidth;
	                    //VID 1837 - remove margin attribute here that it's unnecessary for sidestream and the auto value can make problem to position. but it will be restored when moveback to Oustream by resizeVideo()
	                    topChrome.style.marginLeft = "";
	                    topChrome.style.marginRight = "";
	                }
	            }

	            playerManager.adVideoPlayer.el_.style.marginLeft = "";
	            playerManager.adVideoPlayer.el_.style.marginRight = "";


	            debug("final wrapper width for html5 : " + calculatedWidth);
	            debug("final wrapper height for html5 : " + wrapperHeight);

	        }

	        //resize video
	        adVideoPlayer.width(calculatedWidth);

	        //VID-1790
	        if (options.sideStream && options.sideStream.enabled === true && options.emptyDiv) {//if SideStream is activated, targetElement should be changed to work properly at the corder of video
	            options.targetElement.style.width = calculatedWidth + "px";//VID-1808
	        } else {
	            options.targetElement.style.width = "";//VID-1808
	        }

	        debug("resize video.js width to : " + calculatedWidth);


	        debug("shouldConsiderHeightOfDevice : " + shouldConsiderHeightOfDevice);
	        debug("mediaHeight + bottomOffset + topOffset : " + (mediaHeight + bottomOffset + topOffset));
	        debug("window.innerHeight : " + window.innerHeight);

	        //VID-1020 if it's mobile(shouldConsiderHeightOfDevice = true)
	        if (shouldConsiderHeightOfDevice && (mediaHeight + bottomOffset + topOffset) > window.innerHeight) {
	            //resize height with considering viewport height

	            var mobileVideoJSHeight = window.innerHeight - topOffset;
	            var mobileOptionsHeight = window.innerHeight;
	            var mobileMedieHeight = window.innerHeight - bottomOffset - topOffset;

	            adVideoPlayer.height(mobileVideoJSHeight);
	            // options.height = mobileOptionsHeight;
	            // options.mediaHeight = mobileMedieHeight;

	            debug("mobile set video.js height to : " + mobileVideoJSHeight);
	            debug("mobile options.height to : " + mobileOptionsHeight);
	            debug("mobile options.mediaHeight to : " + mobileMedieHeight);

	            if (playerManager.isEnded && playerManager.endCard) {
	                playerManager.endCard.onVideoResized(calculatedWidth, mobileMedieHeight);
	            }

	        } else {
	            //resize video as usual
	            var desktopVideoJSHeight = mediaHeight;
	            if (!useStaticControlBar() || isIosInlineRequired()) {//iOS inline has to have bottomOffset
	                desktopVideoJSHeight += bottomOffset;
	            }
	            adVideoPlayer.height(desktopVideoJSHeight);
	            debug("desktop set video.js height to : " + desktopVideoJSHeight);

	            if (playerManager.isEnded && playerManager.endCard) {
	                playerManager.endCard.onVideoResized(calculatedWidth, mediaHeight);
	            }
	        }


	    } else {
	        //flash
	        adVideoPlayer.width = calculatedWidth + "px";
	        adVideoPlayer.height = wrapperHeight + "px";
	        adVideoPlayer.style.width = calculatedWidth + "px";
	        adVideoPlayer.style.height = wrapperHeight + "px";



	        debug("flash width : " + calculatedWidth);
	        debug("flash height : " + wrapperHeight);


	    }

	    // adVideoPlayer.style.marginLeft = "";
	    // adVideoPlayer.style.marginRight = "";

	    //options.targetElement.style.visibility = "visible";

	    if (typeof(cb) === "function") {
	        cb();
	    }

	};

	/**
	 * setSizeForInitialRender
	 * @param _options
	 */
	var setSizeForInitialRender = function(_options) {

	    debug("setSizeForInitialRender");
	    var calculatedWidth = _options.width;

	    //if auto initial size is set to true, and offsetWidth of the target element is non-zero,
	    //set the width of the contianer (if not, leave width as width in options)
	    if (_options.autoInitialSize) {
	        calculatedWidth = _options.targetElement.offsetWidth;

	        if( calculatedWidth <= 0){
	            calculatedWidth = _options.width;
	            warn("Width of target element was not set or zero, using tag width for player instead");
	        }
	    }

	    debug("setSizeForInitialRender using width: " + calculatedWidth);
	    _options.width = calculatedWidth;
	};

	/**
	 * getFinalSize including topbar and bottombar
	 * @param playerManager
	 * @returns {{width: number, height: number}}
	 */
	var getFinalSize = function(playerManager) {
	    var result = { width: 0, height: 0 };

	    //TODO this should return width x height including top and bottom bar
	    if (playerManager.decidePlayer(playerManager.options.requiredPlayer) === "flash") {
	        result = { width: playerManager.adVideoPlayer.offsetWidth, height: playerManager.adVideoPlayer.offsetHeight };
	    } else {
	        //html5
	        var _tmp = document.getElementById(playerManager.options.iframeVideoWrapperId);
	        result = { width: _tmp.offsetWidth, height: _tmp.offsetHeight };
	    }
	    return result;
	};

	/**
	 * resizePlayer
	 * @param width
	 * @param height
	 * @param playerManager
	 */
	var resizePlayer = function(width, height, playerManager) {
	    debug("resizePlayer");
	    //TODO who use this function? at least html5 player doesn't use this method

	    if (playerManager.overlayPlayer && playerManager.adVideoPlayer) {
	        if (playerManager.decidePlayer(playerManager.options.requiredPlayer) === "flash") {
	            playerManager.adVideoPlayer.width = width + "px";
	            playerManager.adVideoPlayer.height = height + "px";
	            playerManager.adVideoPlayer.style.width = width + "px";
	            playerManager.adVideoPlayer.style.height = height + "px";
	        } else {
	            playerManager.resizeVideoWithDimensions(width, height);
	            // below is specific code for Overlay/Vast player
	            if (playerManager.iframeVideoWrapper && typeof playerManager.iframeVideoWrapper === "object") {
	                //Browser user agent might add an iframe border
	                //This will overwrite it
	                playerManager.iframeVideoWrapper.style.border = "none";
	                playerManager.iframeVideoWrapper.style.width = width + "px";
	                playerManager.iframeVideoWrapper.style.height = height + "px";

	                var topChrome = playerManager && playerManager.iframeVideoWrapper && playerManager.iframeVideoWrapper.contentWindow && playerManager.iframeVideoWrapper.contentWindow.document && playerManager.iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");//more safe way to access element which might not exists for VID-1923
	                if (topChrome) {
	                    topChrome.style.width = width + "px";
	                    // VIDLA-331/VIDLA-1119 (invalid resizing when orientation changed for iOS)
	                    if (Utils.isIos()) {
	                        topChrome.style.marginLeft = "";
	                        topChrome.style.marginRight = "";
	                    }
	                }

	                // VIDLA-331/VIDLA-1119 (invalid resizing when orientation changed for iOS)
	                if (Utils.isIos()) {
	                    playerManager.adVideoPlayer.el_.style.marginLeft = "";
	                    playerManager.adVideoPlayer.el_.style.marginRight = "";
	                }
	            }

	            //resize video
	            playerManager.adVideoPlayer.width(width);
	            var topOffset = 0;
	            if (!playerManager.options.disableTopBar) {
	                topOffset = 24;
	            }
	            if (Utils.isAndroid() || playerManager.isIosInlineRequired() || playerManager.options.controlBarPosition === "below") {
	                topOffset += playerManager.options.playerSkin.controlBarHeight;
	                if (playerManager.adVideoPlayer.controlBar && playerManager.adVideoPlayer.controlBar.progressControl) {
	                    topOffset += playerManager.adVideoPlayer.controlBar.progressControl.el_.offsetHeight;
	                }
	            }
	            playerManager.adVideoPlayer.height(height - topOffset);
	        }
	    }
	};


	module.exports = {
	    resizeVideo: resizeVideo,
	    setSizeForInitialRender: setSizeForInitialRender,
	    getFinalSize: getFinalSize,
	    resizePlayer: resizePlayer,
	    resizeVideoForSideStream: resizeVideoForSideStream
	};


/***/ }),
/* 45 */
/***/ (function(module, exports) {

	module.exports = "/* jshint ignore:start */\n(function(window, document, vjs, undefined) {\n    (function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof require == \"function\" && require;\n                    if (!u && a) return a(o, !0);\n                    if (i) return i(o, !0);\n                    var f = new Error(\"Cannot find module '\" + o + \"'\");\n                    throw f.code = \"MODULE_NOT_FOUND\", f }\n                var l = n[o] = { exports: {} };\n                t[o][0].call(l.exports, function(e) {\n                    var n = t[o][1][e];\n                    return s(n ? n : e) }, l, l.exports, e, t, n, r) }\n            return n[o].exports }\n        var i = typeof require == \"function\" && require;\n        for (var o = 0; o < r.length; o++) s(r[o]);\n        return s })({\n        1: [function(require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n            var _createClass = (function() {\n                function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if ('value' in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor); } }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor; }; })();\n\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError('Cannot call a class as a function'); } }\n\n            //simple representation of the API\n\n            var IVPAIDAdUnit = (function() {\n                function IVPAIDAdUnit() {\n                    _classCallCheck(this, IVPAIDAdUnit);\n                }\n\n                _createClass(IVPAIDAdUnit, [{\n                    key: 'handshakeVersion',\n\n                    //all methods below\n                    //are async methods\n                    value: function handshakeVersion() {\n                        var playerVPAIDVersion = arguments[0] === undefined ? '2.0' : arguments[0];\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n                    }\n                }, {\n                    key: 'initAd',\n\n                    //creativeData is an object to be consistent with VPAIDHTML\n                    value: function initAd(width, height, viewMode, desiredBitrate) {\n                        var creativeData = arguments[4] === undefined ? { AdParameters: '' } : arguments[4];\n                        var environmentVars = arguments[5] === undefined ? { flashVars: '' } : arguments[5];\n                        var callback = arguments[6] === undefined ? undefined : arguments[6];\n                    }\n                }, {\n                    key: 'resizeAd',\n                    value: function resizeAd(width, height, viewMode) {\n                        var callback = arguments[3] === undefined ? undefined : arguments[3];\n                    }\n                }, {\n                    key: 'startAd',\n                    value: function startAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'stopAd',\n                    value: function stopAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'pauseAd',\n                    value: function pauseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'resumeAd',\n                    value: function resumeAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'expandAd',\n                    value: function expandAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'collapseAd',\n                    value: function collapseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'skipAd',\n                    value: function skipAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'getAdLinear',\n\n                    //properties that will be treat as async methods\n                    value: function getAdLinear(callback) {}\n                }, {\n                    key: 'getAdWidth',\n                    value: function getAdWidth(callback) {}\n                }, {\n                    key: 'getAdHeight',\n                    value: function getAdHeight(callback) {}\n                }, {\n                    key: 'getAdExpanded',\n                    value: function getAdExpanded(callback) {}\n                }, {\n                    key: 'getAdSkippableState',\n                    value: function getAdSkippableState(callback) {}\n                }, {\n                    key: 'getAdRemainingTime',\n                    value: function getAdRemainingTime(callback) {}\n                }, {\n                    key: 'getAdDuration',\n                    value: function getAdDuration(callback) {}\n                }, {\n                    key: 'setAdVolume',\n                    value: function setAdVolume(soundVolume) {\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n                    }\n                }, {\n                    key: 'getAdVolume',\n                    value: function getAdVolume(callback) {}\n                }, {\n                    key: 'getAdCompanions',\n                    value: function getAdCompanions(callback) {}\n                }, {\n                    key: 'getAdIcons',\n                    value: function getAdIcons(callback) {}\n                }]);\n\n                return IVPAIDAdUnit;\n            })();\n\n            exports.IVPAIDAdUnit = IVPAIDAdUnit;\n\n            Object.defineProperty(IVPAIDAdUnit, 'EVENTS', {\n                writable: false,\n                configurable: false,\n                value: ['AdLoaded', 'AdStarted', 'AdStopped', 'AdSkipped', 'AdSkippableStateChange', // VPAID 2.0 new event\n                    'AdSizeChange', // VPAID 2.0 new event\n                    'AdLinearChange', 'AdDurationChange', // VPAID 2.0 new event\n                    'AdExpandedChange', 'AdRemainingTimeChange', // [Deprecated in 2.0] but will be still fired for backwards compatibility\n                    'AdVolumeChange', 'AdImpression', 'AdVideoStart', 'AdVideoFirstQuartile', 'AdVideoMidpoint', 'AdVideoThirdQuartile', 'AdVideoComplete', 'AdClickThru', 'AdInteraction', // VPAID 2.0 new event\n                    'AdUserAcceptInvitation', 'AdUserMinimize', 'AdUserClose', 'AdPaused', 'AdPlaying', 'AdLog', 'AdError'\n                ]\n            });\n\n        }, {}],\n        2: [function(require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n            var _createClass = (function() {\n                function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if ('value' in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor); } }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor; }; })();\n\n            var _get = function get(_x15, _x16, _x17) {\n                var _again = true;\n                _function: while (_again) {\n                    var object = _x15,\n                        property = _x16,\n                        receiver = _x17;\n                    desc = parent = getter = undefined;\n                    _again = false;\n                    if (object === null) object = Function.prototype;\n                    var desc = Object.getOwnPropertyDescriptor(object, property);\n                    if (desc === undefined) {\n                        var parent = Object.getPrototypeOf(object);\n                        if (parent === null) {\n                            return undefined; } else { _x15 = parent;\n                            _x16 = property;\n                            _x17 = receiver;\n                            _again = true;\n                            continue _function; } } else if ('value' in desc) {\n                        return desc.value; } else {\n                        var getter = desc.get;\n                        if (getter === undefined) {\n                            return undefined; }\n                        return getter.call(receiver); } } };\n\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError('Cannot call a class as a function'); } }\n\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== 'function' && superClass !== null) {\n                    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); }\n                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });\n                if (superClass) subClass.__proto__ = superClass; }\n\n            var IVPAIDAdUnit = require('./IVPAIDAdUnit').IVPAIDAdUnit;\n            var ALL_VPAID_METHODS = Object.getOwnPropertyNames(IVPAIDAdUnit.prototype).filter(function(property) {\n                return ['constructor'].indexOf(property) === -1;\n            });\n\n            var VPAIDAdUnit = (function(_IVPAIDAdUnit) {\n                function VPAIDAdUnit(flash) {\n                    _classCallCheck(this, VPAIDAdUnit);\n\n                    _get(Object.getPrototypeOf(VPAIDAdUnit.prototype), 'constructor', this).call(this);\n                    this._destroyed = false;\n                    this._flash = flash;\n                }\n\n                _inherits(VPAIDAdUnit, _IVPAIDAdUnit);\n\n                _createClass(VPAIDAdUnit, [{\n                    key: '_destroy',\n                    value: function _destroy() {\n                        var _this = this;\n\n                        this._destroyed = true;\n                        ALL_VPAID_METHODS.forEach(function(methodName) {\n                            _this._flash.removeCallbackByMethodName(methodName);\n                        });\n                        IVPAIDAdUnit.EVENTS.forEach(function(event) {\n                            _this._flash.offEvent(event);\n                        });\n\n                        this._flash = null;\n                    }\n                }, {\n                    key: 'isDestroyed',\n                    value: function isDestroyed() {\n                        return this._destroyed;\n                    }\n                }, {\n                    key: 'on',\n                    value: function on(eventName, callback) {\n                        this._flash.on(eventName, callback);\n                    }\n                }, {\n                    key: 'off',\n                    value: function off(eventName, callback) {\n                        this._flash.off(eventName, callback);\n                    }\n                }, {\n                    key: 'handshakeVersion',\n\n                    //VPAID interface\n                    value: function handshakeVersion() {\n                        var playerVPAIDVersion = arguments[0] === undefined ? '2.0' : arguments[0];\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n\n                        this._flash.callFlashMethod('handshakeVersion', [playerVPAIDVersion], callback);\n                    }\n                }, {\n                    key: 'initAd',\n                    value: function initAd(width, height, viewMode, desiredBitrate) {\n                        var creativeData = arguments[4] === undefined ? { AdParameters: '' } : arguments[4];\n                        var environmentVars = arguments[5] === undefined ? { flashVars: '' } : arguments[5];\n                        var callback = arguments[6] === undefined ? undefined : arguments[6];\n\n                        //resize element that has the flash object\n                        this._flash.setSize(width, height);\n                        creativeData = creativeData || { AdParameters: '' };\n                        environmentVars = environmentVars || { flashVars: '' };\n\n                        this._flash.callFlashMethod('initAd', [this._flash.getWidth(), this._flash.getHeight(), viewMode, desiredBitrate, creativeData.AdParameters || '', environmentVars.flashVars || ''], callback);\n                    }\n                }, {\n                    key: 'resizeAd',\n                    value: function resizeAd(width, height, viewMode) {\n                        var callback = arguments[3] === undefined ? undefined : arguments[3];\n\n                        //resize element that has the flash object\n                        this._flash.setSize(width, height);\n\n                        //resize ad inside the flash\n                        this._flash.callFlashMethod('resizeAd', [this._flash.getWidth(), this._flash.getHeight(), viewMode], callback);\n                    }\n                }, {\n                    key: 'startAd',\n                    value: function startAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('startAd', [], callback);\n                    }\n                }, {\n                    key: 'stopAd',\n                    value: function stopAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('stopAd', [], callback);\n                    }\n                }, {\n                    key: 'pauseAd',\n                    value: function pauseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('pauseAd', [], callback);\n                    }\n                }, {\n                    key: 'resumeAd',\n                    value: function resumeAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('resumeAd', [], callback);\n                    }\n                }, {\n                    key: 'expandAd',\n                    value: function expandAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('expandAd', [], callback);\n                    }\n                }, {\n                    key: 'collapseAd',\n                    value: function collapseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('collapseAd', [], callback);\n                    }\n                }, {\n                    key: 'skipAd',\n                    value: function skipAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('skipAd', [], callback);\n                    }\n                }, {\n                    key: 'getAdLinear',\n\n                    //properties that will be treat as async methods\n                    value: function getAdLinear(callback) {\n                        this._flash.callFlashMethod('getAdLinear', [], callback);\n                    }\n                }, {\n                    key: 'getAdWidth',\n                    value: function getAdWidth(callback) {\n                        this._flash.callFlashMethod('getAdWidth', [], callback);\n                    }\n                }, {\n                    key: 'getAdHeight',\n                    value: function getAdHeight(callback) {\n                        this._flash.callFlashMethod('getAdHeight', [], callback);\n                    }\n                }, {\n                    key: 'getAdExpanded',\n                    value: function getAdExpanded(callback) {\n                        this._flash.callFlashMethod('getAdExpanded', [], callback);\n                    }\n                }, {\n                    key: 'getAdSkippableState',\n                    value: function getAdSkippableState(callback) {\n                        this._flash.callFlashMethod('getAdSkippableState', [], callback);\n                    }\n                }, {\n                    key: 'getAdRemainingTime',\n                    value: function getAdRemainingTime(callback) {\n                        this._flash.callFlashMethod('getAdRemainingTime', [], callback);\n                    }\n                }, {\n                    key: 'getAdDuration',\n                    value: function getAdDuration(callback) {\n                        this._flash.callFlashMethod('getAdDuration', [], callback);\n                    }\n                }, {\n                    key: 'setAdVolume',\n                    value: function setAdVolume(volume) {\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n\n                        this._flash.callFlashMethod('setAdVolume', [volume], callback);\n                    }\n                }, {\n                    key: 'getAdVolume',\n                    value: function getAdVolume(callback) {\n                        this._flash.callFlashMethod('getAdVolume', [], callback);\n                    }\n                }, {\n                    key: 'getAdCompanions',\n                    value: function getAdCompanions(callback) {\n                        this._flash.callFlashMethod('getAdCompanions', [], callback);\n                    }\n                }, {\n                    key: 'getAdIcons',\n                    value: function getAdIcons(callback) {\n                        this._flash.callFlashMethod('getAdIcons', [], callback);\n                    }\n                }]);\n\n                return VPAIDAdUnit;\n            })(IVPAIDAdUnit);\n\n            exports.VPAIDAdUnit = VPAIDAdUnit;\n\n        }, { \"./IVPAIDAdUnit\": 1 }],\n        3: [function(require, module, exports) {\n            'use strict';\n\n            var _createClass = (function() {\n                function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if ('value' in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor); } }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor; }; })();\n\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError('Cannot call a class as a function'); } }\n\n            var JSFlashBridge = require('./jsFlashBridge').JSFlashBridge;\n            var VPAIDAdUnit = require('./VPAIDAdUnit').VPAIDAdUnit;\n\n            var noop = require('./utils').noop;\n            var callbackTimeout = require('./utils').callbackTimeout;\n            var isPositiveInt = require('./utils').isPositiveInt;\n            var createElementWithID = require('./utils').createElementWithID;\n            var uniqueVPAID = require('./utils').unique('vpaid');\n\n            var ERROR = 'error';\n            var FLASH_VERSION = '10.1.0';\n\n            var VPAIDFLASHClient = (function() {\n                function VPAIDFLASHClient(vpaidParentEl, callback) {\n                    var swfConfig = arguments[2] === undefined ? { data: 'VPAIDFlash.swf', width: 800, height: 400 } : arguments[2];\n\n                    var _this = this;\n\n                    var params = arguments[3] === undefined ? { wmode: 'transparent', salign: 'tl', align: 'left', allowScriptAccess: 'always', scale: 'noScale', allowFullScreen: 'true', quality: 'high' } : arguments[3];\n                    var vpaidOptions = arguments[4] === undefined ? { debug: false, timeout: 10000 } : arguments[4];\n\n                    _classCallCheck(this, VPAIDFLASHClient);\n\n                    if (!VPAIDFLASHClient.hasExternalDependencies()) {\n                        return onError('no swfobject in global scope. check: https://github.com/swfobject/swfobject or https://code.google.com/p/swfobject/');\n                    }\n\n                    this._vpaidParentEl = vpaidParentEl;\n                    this._flashID = uniqueVPAID();\n                    this._destroyed = false;\n                    callback = callback || noop;\n\n                    swfConfig.width = isPositiveInt(swfConfig.width, 800);\n                    swfConfig.height = isPositiveInt(swfConfig.height, 400);\n\n                    createElementWithID(vpaidParentEl, this._flashID);\n\n                    params.movie = swfConfig.data;\n                    params.FlashVars = 'flashid=' + this._flashID + '&handler=' + JSFlashBridge.VPAID_FLASH_HANDLER + '&debug=' + vpaidOptions.debug + '&salign=' + params.salign;\n\n                    if (!VPAIDFLASHClient.isSupported()) {\n                        return onError('user don\\'t support flash or doesn\\'t have the minimum required version of flash ' + FLASH_VERSION);\n                    }\n\n                    this.el = swfobject.createSWF(swfConfig, params, this._flashID);\n\n                    if (!this.el) {\n                        return onError('swfobject failed to create object in element');\n                    }\n\n                    var handler = callbackTimeout(vpaidOptions.timeout, function(err, data) {\n                        $loadPendedAdUnit.call(_this);\n                        callback(err, data);\n                    }, function() {\n                        callback('vpaid flash load timeout ' + vpaidOptions.timeout);\n                    });\n\n                    this._flash = new JSFlashBridge(this.el, swfConfig.data, this._flashID, swfConfig.width, swfConfig.height, handler);\n\n                    function onError(error) {\n                        setTimeout(function() {\n                            callback(new Error(error));\n                        }, 0);\n                        return this;\n                    }\n                }\n\n                _createClass(VPAIDFLASHClient, [{\n                    key: 'destroy',\n                    value: function destroy() {\n                        this._destroyAdUnit();\n\n                        if (this._flash) {\n                            this._flash.destroy();\n                            this._flash = null;\n                        }\n                        this.el = null;\n                        this._destroyed = true;\n                    }\n                }, {\n                    key: 'isDestroyed',\n                    value: function isDestroyed() {\n                        return this._destroyed;\n                    }\n                }, {\n                    key: '_destroyAdUnit',\n                    value: function _destroyAdUnit() {\n                        delete this._loadLater;\n\n                        if (this._adUnitLoad) {\n                            this._adUnitLoad = null;\n                            this._flash.removeCallback(this._adUnitLoad);\n                        }\n\n                        if (this._adUnit) {\n                            this._adUnit._destroy();\n                            this._adUnit = null;\n                        }\n                    }\n                }, {\n                    key: 'loadAdUnit',\n                    value: function loadAdUnit(adURL, callback) {\n                        var _this2 = this;\n\n                        $throwIfDestroyed.call(this);\n\n                        if (this._adUnit) {\n                            this._destroyAdUnit();\n                        }\n\n                        if (this._flash.isReady()) {\n                            this._adUnitLoad = function(err, message) {\n                                if (!err) {\n                                    _this2._adUnit = new VPAIDAdUnit(_this2._flash);\n                                }\n                                _this2._adUnitLoad = null;\n                                callback(err, _this2._adUnit);\n                            };\n\n                            this._flash.callFlashMethod('loadAdUnit', [adURL], this._adUnitLoad);\n                        } else {\n                            this._loadLater = { url: adURL, callback: callback };\n                        }\n                    }\n                }, {\n                    key: 'unloadAdUnit',\n                    value: function unloadAdUnit() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        $throwIfDestroyed.call(this);\n\n                        this._destroyAdUnit();\n                        this._flash.callFlashMethod('unloadAdUnit', [], callback);\n                    }\n                }, {\n                    key: 'getFlashID',\n                    value: function getFlashID() {\n                        $throwIfDestroyed.call(this);\n                        return this._flash.getFlashID();\n                    }\n                }, {\n                    key: 'getFlashURL',\n                    value: function getFlashURL() {\n                        $throwIfDestroyed.call(this);\n                        return this._flash.getFlashURL();\n                    }\n                }]);\n\n                return VPAIDFLASHClient;\n            })();\n\n            setStaticProperty('isSupported', function() {\n                return VPAIDFLASHClient.hasExternalDependencies() && swfobject.hasFlashPlayerVersion(FLASH_VERSION);\n            });\n\n            setStaticProperty('hasExternalDependencies', function() {\n                return !!window.swfobject;\n            });\n\n            function $throwIfDestroyed() {\n                if (this._destroyed) {\n                    throw new error('VPAIDFlashToJS is destroyed!');\n                }\n            }\n\n            function $loadPendedAdUnit() {\n                if (this._loadLater) {\n                    this.loadAdUnit(this._loadLater.url, this._loadLater.callback);\n                    delete this._loadLater;\n                }\n            }\n\n            function setStaticProperty(propertyName, value) {\n                Object.defineProperty(VPAIDFLASHClient, propertyName, {\n                    writable: false,\n                    configurable: false,\n                    value: value\n                });\n            }\n\n            window.VPAIDFLASHClient = VPAIDFLASHClient;\n            module.exports = VPAIDFLASHClient;\n\n        }, { \"./VPAIDAdUnit\": 2, \"./jsFlashBridge\": 4, \"./utils\": 7 }],\n        4: [function(require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n            var _createClass = (function() {\n                function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if ('value' in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor); } }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor; }; })();\n\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError('Cannot call a class as a function'); } }\n\n            var unique = require('./utils').unique;\n            var isPositiveInt = require('./utils').isPositiveInt;\n            var stringEndsWith = require('./utils').stringEndsWith;\n            var SingleValueRegistry = require('./registry').SingleValueRegistry;\n            var MultipleValuesRegistry = require('./registry').MultipleValuesRegistry;\n            var registry = require('./jsFlashBridgeRegistry');\n            var VPAID_FLASH_HANDLER = 'vpaid_video_flash_handler';\n            var ERROR = 'AdError';\n\n            var JSFlashBridge = (function() {\n                function JSFlashBridge(el, flashURL, flashID, width, height, loadHandShake) {\n                    _classCallCheck(this, JSFlashBridge);\n\n                    this._el = el;\n                    this._flashID = flashID;\n                    this._flashURL = flashURL;\n                    this._width = width;\n                    this._height = height;\n                    this._handlers = new MultipleValuesRegistry();\n                    this._callbacks = new SingleValueRegistry();\n                    this._uniqueMethodIdentifier = unique(this._flashID);\n                    this._ready = false;\n                    this._handShakeHandler = loadHandShake;\n\n                    registry.addInstance(this._flashID, this);\n                }\n\n                _createClass(JSFlashBridge, [{\n                    key: 'on',\n                    value: function on(eventName, callback) {\n                        this._handlers.add(eventName, callback);\n                    }\n                }, {\n                    key: 'off',\n                    value: function off(eventName, callback) {\n                        return this._handlers.remove(eventName, callback);\n                    }\n                }, {\n                    key: 'offEvent',\n                    value: function offEvent(eventName) {\n                        return this._handlers.removeByKey(eventName);\n                    }\n                }, {\n                    key: 'offAll',\n                    value: function offAll() {\n                        return this._handlers.removeAll();\n                    }\n                }, {\n                    key: 'callFlashMethod',\n                    value: function callFlashMethod(methodName) {\n                        var args = arguments[1] === undefined ? [] : arguments[1];\n                        var callback = arguments[2] === undefined ? undefined : arguments[2];\n\n                        var callbackID = '';\n                        // if no callback, some methods the return is void so they don't need callback\n                        if (callback) {\n                            callbackID = this._uniqueMethodIdentifier() + '_' + methodName;\n                            this._callbacks.add(callbackID, callback);\n                        }\n\n                        try {\n                            //methods are created by ExternalInterface.addCallback in as3 code, if for some reason it failed\n                            //this code will throw an error\n                            this._el[methodName]([callbackID].concat(args));\n                        } catch (e) {\n                            if (callback) {\n                                $asyncCallback.call(this, callbackID, e);\n                            } else {\n\n                                //if there isn't any callback to return error use error event handler\n                                this._trigger(ERROR, e);\n                            }\n                        }\n                    }\n                }, {\n                    key: 'removeCallback',\n                    value: function removeCallback(callback) {\n                        return this._callbacks.removeByValue(callback);\n                    }\n                }, {\n                    key: 'removeCallbackByMethodName',\n                    value: function removeCallbackByMethodName(suffix) {\n                        var _this = this;\n\n                        this._callbacks.filterKeys(function(key) {\n                            return stringEndsWith(key, suffix);\n                        }).forEach(function(key) {\n                            _this._callbacks.remove(key);\n                        });\n                    }\n                }, {\n                    key: 'removeAllCallbacks',\n                    value: function removeAllCallbacks() {\n                        return this._callbacks.removeAll();\n                    }\n                }, {\n                    key: '_trigger',\n                    value: function _trigger(eventName, event) {\n                        var _this2 = this;\n\n                        this._handlers.get(eventName).forEach(function(callback) {\n                            //clickThru has to be sync, if not will be block by the popupblocker\n                            if (eventName === 'AdClickThru') {\n                                callback(event);\n                            } else {\n                                setTimeout(function() {\n                                    if (_this2._handlers.get(eventName).length > 0) {\n                                        callback(event);\n                                    }\n                                }, 0);\n                            }\n                        });\n                    }\n                }, {\n                    key: '_callCallback',\n                    value: function _callCallback(methodName, callbackID, err, result) {\n\n                        var callback = this._callbacks.get(callbackID);\n\n                        //not all methods callback's are mandatory\n                        //but if there exist an error, fire the error event\n                        if (!callback) {\n                            if (err && callbackID === '') {\n                                this.trigger(ERROR, err);\n                            }\n                            return;\n                        }\n\n                        $asyncCallback.call(this, callbackID, err, result);\n                    }\n                }, {\n                    key: '_handShake',\n                    value: function _handShake(err, data) {\n                        this._ready = true;\n                        if (this._handShakeHandler) {\n                            this._handShakeHandler(err, data);\n                            delete this._handShakeHandler;\n                        }\n                    }\n                }, {\n                    key: 'getSize',\n\n                    //methods like properties specific to this implementation of VPAID\n                    value: function getSize() {\n                        return { width: this._width, height: this._height };\n                    }\n                }, {\n                    key: 'setSize',\n                    value: function setSize(newWidth, newHeight) {\n                        this._width = isPositiveInt(newWidth, this._width);\n                        this._height = isPositiveInt(newHeight, this._height);\n                        this._el.setAttribute('width', this._width);\n                        this._el.setAttribute('height', this._height);\n                    }\n                }, {\n                    key: 'getWidth',\n                    value: function getWidth() {\n                        return this._width;\n                    }\n                }, {\n                    key: 'setWidth',\n                    value: function setWidth(newWidth) {\n                        this.setSize(newWidth, this._height);\n                    }\n                }, {\n                    key: 'getHeight',\n                    value: function getHeight() {\n                        return this._height;\n                    }\n                }, {\n                    key: 'setHeight',\n                    value: function setHeight(newHeight) {\n                        this.setSize(this._width, newHeight);\n                    }\n                }, {\n                    key: 'getFlashID',\n                    value: function getFlashID() {\n                        return this._flashID;\n                    }\n                }, {\n                    key: 'getFlashURL',\n                    value: function getFlashURL() {\n                        return this._flashURL;\n                    }\n                }, {\n                    key: 'isReady',\n                    value: function isReady() {\n                        return this._ready;\n                    }\n                }, {\n                    key: 'destroy',\n                    value: function destroy() {\n                        this.offAll();\n                        this.removeAllCallbacks();\n                        registry.removeInstanceByID(this._flashID);\n                        if (this._el.parentElement) {\n                            this._el.parentElement.removeChild(this._el);\n                        }\n                    }\n                }]);\n\n                return JSFlashBridge;\n            })();\n\n            exports.JSFlashBridge = JSFlashBridge;\n\n            function $asyncCallback(callbackID, err, result) {\n                var _this3 = this;\n\n                setTimeout(function() {\n                    var callback = _this3._callbacks.get(callbackID);\n                    if (callback) {\n                        _this3._callbacks.remove(callbackID);\n                        callback(err, result);\n                    }\n                }, 0);\n            }\n\n            Object.defineProperty(JSFlashBridge, 'VPAID_FLASH_HANDLER', {\n                writable: false,\n                configurable: false,\n                value: VPAID_FLASH_HANDLER\n            });\n\n            /**\n             * External interface handler\n             *\n             * @param {string} flashID identifier of the flash who call this\n             * @param {string} typeID what type of message is, can be 'event' or 'callback'\n             * @param {string} typeName if the typeID is a event the typeName will be the eventName, if is a callback the typeID is the methodName that is related this callback\n             * @param {string} callbackID only applies when the typeID is 'callback', identifier of the callback to call\n             * @param {object} error error object\n             * @param {object} data\n             */\n            window[VPAID_FLASH_HANDLER] = function(flashID, typeID, typeName, callbackID, error, data) {\n                var instance = registry.getInstanceByID(flashID);\n                if (!instance) return;\n                if (typeName === 'handShake') {\n                    instance._handShake(error, data);\n                } else {\n                    if (typeID !== 'event') {\n                        instance._callCallback(typeName, callbackID, error, data);\n                    } else {\n                        instance._trigger(typeName, data);\n                    }\n                }\n            };\n\n        }, { \"./jsFlashBridgeRegistry\": 5, \"./registry\": 6, \"./utils\": 7 }],\n        5: [function(require, module, exports) {\n            'use strict';\n\n            var SingleValueRegistry = require('./registry').SingleValueRegistry;\n            var instances = new SingleValueRegistry();\n\n            var JSFlashBridgeRegistry = {};\n            Object.defineProperty(JSFlashBridgeRegistry, 'addInstance', {\n                writable: false,\n                configurable: false,\n                value: function value(id, instance) {\n                    instances.add(id, instance);\n                }\n            });\n\n            Object.defineProperty(JSFlashBridgeRegistry, 'getInstanceByID', {\n                writable: false,\n                configurable: false,\n                value: function value(id) {\n                    return instances.get(id);\n                }\n            });\n\n            Object.defineProperty(JSFlashBridgeRegistry, 'removeInstanceByID', {\n                writable: false,\n                configurable: false,\n                value: function value(id) {\n                    return instances.remove(id);\n                }\n            });\n\n            module.exports = JSFlashBridgeRegistry;\n\n        }, { \"./registry\": 6 }],\n        6: [function(require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n            var _createClass = (function() {\n                function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if ('value' in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor); } }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor; }; })();\n\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError('Cannot call a class as a function'); } }\n\n            var MultipleValuesRegistry = (function() {\n                function MultipleValuesRegistry() {\n                    _classCallCheck(this, MultipleValuesRegistry);\n\n                    this._registries = {};\n                }\n\n                _createClass(MultipleValuesRegistry, [{\n                    key: 'add',\n                    value: function add(id, value) {\n                        if (!this._registries[id]) {\n                            this._registries[id] = [];\n                        }\n                        if (this._registries[id].indexOf(value) === -1) {\n                            this._registries[id].push(value);\n                        }\n                    }\n                }, {\n                    key: 'get',\n                    value: function get(id) {\n                        return this._registries[id] || [];\n                    }\n                }, {\n                    key: 'filterKeys',\n                    value: function filterKeys(handler) {\n                        return Object.keys(this._registries).filter(handler);\n                    }\n                }, {\n                    key: 'findByValue',\n                    value: function findByValue(value) {\n                        var _this = this;\n\n                        var keys = Object.keys(this._registries).filter(function(key) {\n                            return _this._registries[key].indexOf(value) !== -1;\n                        });\n\n                        return keys;\n                    }\n                }, {\n                    key: 'remove',\n                    value: function remove(key, value) {\n                        if (!this._registries[key]) {\n                            return;\n                        }\n\n                        var index = this._registries[key].indexOf(value);\n\n                        if (index < 0) {\n                            return;\n                        }\n                        return this._registries[key].splice(index, 1);\n                    }\n                }, {\n                    key: 'removeByKey',\n                    value: function removeByKey(id) {\n                        var old = this._registries[id];\n                        delete this._registries[id];\n                        return old;\n                    }\n                }, {\n                    key: 'removeByValue',\n                    value: function removeByValue(value) {\n                        var _this2 = this;\n\n                        var keys = this.findByValue(value);\n                        return keys.map(function(key) {\n                            return _this2.remove(key, value);\n                        });\n                    }\n                }, {\n                    key: 'removeAll',\n                    value: function removeAll() {\n                        var old = this._registries;\n                        this._registries = {};\n                        return old;\n                    }\n                }, {\n                    key: 'size',\n                    value: function size() {\n                        return Object.keys(this._registries).length;\n                    }\n                }]);\n\n                return MultipleValuesRegistry;\n            })();\n\n            exports.MultipleValuesRegistry = MultipleValuesRegistry;\n\n            var SingleValueRegistry = (function() {\n                function SingleValueRegistry() {\n                    _classCallCheck(this, SingleValueRegistry);\n\n                    this._registries = {};\n                }\n\n                _createClass(SingleValueRegistry, [{\n                    key: 'add',\n                    value: function add(id, value) {\n                        this._registries[id] = value;\n                    }\n                }, {\n                    key: 'get',\n                    value: function get(id) {\n                        return this._registries[id];\n                    }\n                }, {\n                    key: 'filterKeys',\n                    value: function filterKeys(handler) {\n                        return Object.keys(this._registries).filter(handler);\n                    }\n                }, {\n                    key: 'findByValue',\n                    value: function findByValue(value) {\n                        var _this3 = this;\n\n                        var keys = Object.keys(this._registries).filter(function(key) {\n                            return _this3._registries[key] === value;\n                        });\n\n                        return keys;\n                    }\n                }, {\n                    key: 'remove',\n                    value: function remove(id) {\n                        var old = this._registries[id];\n                        delete this._registries[id];\n                        return old;\n                    }\n                }, {\n                    key: 'removeByValue',\n                    value: function removeByValue(value) {\n                        var _this4 = this;\n\n                        var keys = this.findByValue(value);\n                        return keys.map(function(key) {\n                            return _this4.remove(key);\n                        });\n                    }\n                }, {\n                    key: 'removeAll',\n                    value: function removeAll() {\n                        var old = this._registries;\n                        this._registries = {};\n                        return old;\n                    }\n                }, {\n                    key: 'size',\n                    value: function size() {\n                        return Object.keys(this._registries).length;\n                    }\n                }]);\n\n                return SingleValueRegistry;\n            })();\n\n            exports.SingleValueRegistry = SingleValueRegistry;\n\n        }, {}],\n        7: [function(require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n            exports.unique = unique;\n            exports.noop = noop;\n            exports.callbackTimeout = callbackTimeout;\n            exports.createElementWithID = createElementWithID;\n            exports.isPositiveInt = isPositiveInt;\n            exports.stringEndsWith = stringEndsWith;\n\n            function unique(prefix) {\n                var count = -1;\n                return function(f) {\n                    return prefix + '_' + ++count;\n                };\n            }\n\n            function noop() {}\n\n            function callbackTimeout(timer, onSuccess, onTimeout) {\n\n                var timeout = setTimeout(function() {\n\n                    onSuccess = noop;\n                    onTimeout();\n                }, timer);\n\n                return function() {\n                    clearTimeout(timeout);\n                    onSuccess.apply(this, arguments);\n                };\n            }\n\n            function createElementWithID(parent, id) {\n                var nEl = document.createElement('div');\n                nEl.id = id;\n                parent.innerHTML = '';\n                parent.appendChild(nEl);\n                return nEl;\n            }\n\n            function isPositiveInt(newVal, oldVal) {\n                return !isNaN(parseFloat(newVal)) && isFinite(newVal) && newVal > 0 ? newVal : oldVal;\n            }\n\n            var endsWith = (function() {\n                if (String.prototype.endsWith) return String.prototype.endsWith;\n                return function endsWith(searchString, position) {\n                    var subjectString = this.toString();\n                    if (position === undefined || position > subjectString.length) {\n                        position = subjectString.length;\n                    }\n                    position -= searchString.length;\n                    var lastIndex = subjectString.indexOf(searchString, position);\n                    return lastIndex !== -1 && lastIndex === position;\n                };\n            })();\n\n            function stringEndsWith(string, search) {\n                return endsWith.call(string, search);\n            }\n\n        }, {}]\n    }, {}, [3])\n\n\n    //# sourceMappingURL=VPAIDFLASHClient.js.map\n    ;\n    /*jshint unused:false */\n    \"use strict\";\n\n    var NODE_TYPE_ELEMENT = 1;\n\n    function noop() {}\n\n    function isNull(o) {\n        return o === null;\n    }\n\n    function isDefined(o) {\n        return o !== undefined;\n    }\n\n    function isUndefined(o) {\n        return o === undefined;\n    }\n\n    function isObject(obj) {\n        return typeof obj === 'object';\n    }\n\n    function isFunction(str) {\n        return typeof str === 'function';\n    }\n\n    function isNumber(num) {\n        return typeof num === 'number';\n    }\n\n    function isWindow(obj) {\n        return isObject(obj) && obj.window === obj;\n    }\n\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === '[object Array]';\n    }\n\n    function isArrayLike(obj) {\n        if (obj === null || isWindow(obj) || isFunction(obj) || isUndefined(obj)) {\n            return false;\n        }\n\n        var length = obj.length;\n\n        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {\n            return true;\n        }\n\n        return isString(obj) || isArray(obj) || length === 0 ||\n            typeof length === 'number' && length > 0 && (length - 1) in obj;\n    }\n\n    function isString(str) {\n        return typeof str === 'string';\n    }\n\n    function isEmptyString(str) {\n        return isString(str) && str.length === 0;\n    }\n\n    function isNotEmptyString(str) {\n        return isString(str) && str.length !== 0;\n    }\n\n    function arrayLikeObjToArray(args) {\n        return Array.prototype.slice.call(args);\n    }\n\n    function forEach(obj, iterator, context) {\n        var key, length;\n        if (obj) {\n            if (isFunction(obj)) {\n                for (key in obj) {\n                    // Need to check if hasOwnProperty exists,\n                    // as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function\n                    if (key !== 'prototype' && key !== 'length' && key !== 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {\n                        iterator.call(context, obj[key], key, obj);\n                    }\n                }\n            } else if (isArray(obj)) {\n                var isPrimitive = typeof obj !== 'object';\n                for (key = 0, length = obj.length; key < length; key++) {\n                    if (isPrimitive || key in obj) {\n                        iterator.call(context, obj[key], key, obj);\n                    }\n                }\n            } else if (obj.forEach && obj.forEach !== forEach) {\n                obj.forEach(iterator, context, obj);\n            } else {\n                for (key in obj) {\n                    if (obj.hasOwnProperty(key)) {\n                        iterator.call(context, obj[key], key, obj);\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n\n    var SNAKE_CASE_REGEXP = /[A-Z]/g;\n\n    function snake_case(name, separator) {\n        separator = separator || '_';\n        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {\n            return (pos ? separator : '') + letter.toLowerCase();\n        });\n    }\n\n    function isValidEmail(email) {\n        if (!isString(email)) {\n            return false;\n        }\n        var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)+$/i;\n        return EMAIL_REGEXP.test(email.trim());\n    }\n\n    function extend(obj) {\n        var arg, i, k;\n        for (i = 1; i < arguments.length; i++) {\n            arg = arguments[i];\n            for (k in arg) {\n                if (arg.hasOwnProperty(k)) {\n                    if (isObject(obj[k]) && !isNull(obj[k]) && isObject(arg[k])) {\n                        obj[k] = extend({}, obj[k], arg[k]);\n                    } else {\n                        obj[k] = arg[k];\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n\n    function capitalize(s) {\n        return s.charAt(0).toUpperCase() + s.slice(1);\n    }\n\n    function decapitalize(s) {\n        return s.charAt(0).toLowerCase() + s.slice(1);\n    }\n\n    /**\n     * This method works the same way array.prototype.map works but if the transformer returns undefine, then\n     * it won't be added to the transformed Array.\n     */\n    function transformArray(array, transformer) {\n        var transformedArray = [];\n\n        array.forEach(function(item, index) {\n            var transformedItem = transformer(item, index);\n            if (isDefined(transformedItem)) {\n                transformedArray.push(transformedItem);\n            }\n        });\n\n        return transformedArray;\n    }\n\n    function toFixedDigits(num, digits) {\n        var formattedNum = num + '';\n        digits = isNumber(digits) ? digits : 0;\n        num = isNumber(num) ? num : parseInt(num, 10);\n        if (isNumber(num) && !isNaN(num)) {\n            formattedNum = num + '';\n            while (formattedNum.length < digits) {\n                formattedNum = '0' + formattedNum;\n            }\n            return formattedNum;\n        }\n        return NaN + '';\n    }\n\n    function debounce(callback, wait) {\n        var timeoutId;\n\n        return function() {\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n            timeoutId = setTimeout(function() {\n                callback.apply(this, arguments);\n                timeoutId = undefined;\n            }, wait);\n        };\n    }\n\n    // a function designed to blow up the stack in a naive way\n    // but it is ok for videoJs children components\n    function treeSearch(root, getChildren, found) {\n        var children = getChildren(root);\n        for (var i = 0; i < children.length; i++) {\n            if (found(children[i])) {\n                return children[i];\n            } else {\n                var el = treeSearch(children[i], getChildren, found);\n                if (el) {\n                    return el;\n                }\n            }\n        }\n    }\n\n    function echoFn(val) {\n        return function() {\n            return val;\n        };\n    }\n\n    //Note: Supported formats come from http://www.w3.org/TR/NOTE-datetime\n    // and the iso8601 regex comes from http://www.pelagodesign.com/blog/2009/05/20/iso-8601-date-validation-that-doesnt-suck/\n    function isISO8601(value) {\n        if (isNumber(value)) {\n            value = value + ''; //we make sure that we are working with strings\n        }\n\n        if (!isString(value)) {\n            return false;\n        }\n\n        /*jslint maxlen: 500 */\n        var iso8086Regex = /^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24\\:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\n        return iso8086Regex.test(value.trim());\n    }\n\n    /**\n     * Checks if the Browser is IE9 and below\n     * @returns {boolean}\n     */\n    function isOldIE() {\n        var version = getInternetExplorerVersion(navigator);\n        if (version === -1) {\n            return false;\n        }\n\n        return version < 10;\n    }\n\n    /**\n     * Returns the version of Internet Explorer or a -1 (indicating the use of another browser).\n     * Source: https://msdn.microsoft.com/en-us/library/ms537509(v=vs.85).aspx\n     * @returns {number} the version of Internet Explorer or a -1 (indicating the use of another browser).\n     */\n    function getInternetExplorerVersion(navigator) {\n        var rv = -1;\n\n        if (navigator.appName == 'Microsoft Internet Explorer') {\n            var ua = navigator.userAgent;\n            var re = new RegExp(\"MSIE ([0-9]{1,}[\\.0-9]{0,})\");\n            var res = re.exec(ua);\n            if (res !== null) {\n                rv = parseFloat(res[1]);\n            }\n        }\n\n        return rv;\n    }\n\n    /*** Mobile Utility functions ***/\n    var _UA = navigator.userAgent;\n\n    function isIDevice() {\n        return /iP(hone|ad)/.test(_UA);\n    }\n\n    function isMobile() {\n        return /iP(hone|ad|od)|Android|Windows Phone/.test(_UA);\n    }\n\n    function isIPhone() {\n        return /iP(hone|od)/.test(_UA);\n    }\n\n    function isAndroid() {\n        return /Android/.test(_UA);\n    }\n\n    ;\n    (function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof require == \"function\" && require;\n                    if (!u && a) return a(o, !0);\n                    if (i) return i(o, !0);\n                    var f = new Error(\"Cannot find module '\" + o + \"'\");\n                    throw f.code = \"MODULE_NOT_FOUND\", f }\n                var l = n[o] = { exports: {} };\n                t[o][0].call(l.exports, function(e) {\n                    var n = t[o][1][e];\n                    return s(n ? n : e) }, l, l.exports, e, t, n, r) }\n            return n[o].exports }\n        var i = typeof require == \"function\" && require;\n        for (var o = 0; o < r.length; o++) s(r[o]);\n        return s })({\n        1: [function(require, module, exports) {\n            'use strict';\n\n            var METHODS = [\n                'handshakeVersion',\n                'initAd',\n                'startAd',\n                'stopAd',\n                'skipAd', // VPAID 2.0 new method\n                'resizeAd',\n                'pauseAd',\n                'resumeAd',\n                'expandAd',\n                'collapseAd',\n                'subscribe',\n                'unsubscribe'\n            ];\n\n            var EVENTS = [\n                'AdLoaded',\n                'AdStarted',\n                'AdStopped',\n                'AdSkipped',\n                'AdSkippableStateChange', // VPAID 2.0 new event\n                'AdSizeChange', // VPAID 2.0 new event\n                'AdLinearChange',\n                'AdDurationChange', // VPAID 2.0 new event\n                'AdExpandedChange',\n                'AdRemainingTimeChange', // [Deprecated in 2.0] but will be still fired for backwards compatibility\n                'AdVolumeChange',\n                'AdImpression',\n                'AdVideoStart',\n                'AdVideoFirstQuartile',\n                'AdVideoMidpoint',\n                'AdVideoThirdQuartile',\n                'AdVideoComplete',\n                'AdClickThru',\n                'AdInteraction', // VPAID 2.0 new event\n                'AdUserAcceptInvitation',\n                'AdUserMinimize',\n                'AdUserClose',\n                'AdPaused',\n                'AdPlaying',\n                'AdLog',\n                'AdError'\n            ];\n\n            var GETTERS = [\n                'getAdLinear',\n                'getAdWidth', // VPAID 2.0 new getter\n                'getAdHeight', // VPAID 2.0 new getter\n                'getAdExpanded',\n                'getAdSkippableState', // VPAID 2.0 new getter\n                'getAdRemainingTime',\n                'getAdDuration', // VPAID 2.0 new getter\n                'getAdVolume',\n                'getAdCompanions', // VPAID 2.0 new getter\n                'getAdIcons' // VPAID 2.0 new getter\n            ];\n\n            var SETTERS = [\n                'setAdVolume'\n            ];\n\n\n            /**\n             * This callback is displayed as global member. The callback use nodejs error-first callback style\n             * @callback NodeStyleCallback\n             * @param {string|null}\n             * @param {undefined|object}\n             */\n\n\n            /**\n             * IVPAIDAdUnit\n             *\n             * @class\n             *\n             * @param {object} creative\n             * @param {HTMLElement} el\n             * @param {HTMLVideoElement} video\n             */\n            function IVPAIDAdUnit(creative, el, video) {}\n\n\n            /**\n             * handshakeVersion\n             *\n             * @param {string} VPAIDVersion\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.handshakeVersion = function(VPAIDVersion, callback) {};\n\n            /**\n             * initAd\n             *\n             * @param {number} width\n             * @param {number} height\n             * @param {string} viewMode can be 'normal', 'thumbnail' or 'fullscreen'\n             * @param {number} desiredBitrate indicates the desired bitrate in kbps\n             * @param {object} [creativeData] used for additional initialization data\n             * @param {object} [environmentVars] used for passing implementation-specific of js version\n             * @param {NodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.initAd = function(width, height, viewMode, desiredBitrate, creativeData, environmentVars, callback) {};\n\n            /**\n             * startAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.startAd = function(callback) {};\n\n            /**\n             * stopAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.stopAd = function(callback) {};\n\n            /**\n             * skipAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.skipAd = function(callback) {};\n\n            /**\n             * resizeAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.resizeAd = function(width, height, viewMode, callback) {};\n\n            /**\n             * pauseAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.pauseAd = function(callback) {};\n\n            /**\n             * resumeAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.resumeAd = function(callback) {};\n\n            /**\n             * expandAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.expandAd = function(callback) {};\n\n            /**\n             * collapseAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.collapseAd = function(callback) {};\n\n            /**\n             * subscribe\n             *\n             * @param {string} event\n             * @param {nodeStyleCallback} handler\n             * @param {object} context\n             */\n            IVPAIDAdUnit.prototype.subscribe = function(event, handler, context) {};\n\n            /**\n             * startAd\n             *\n             * @param {string} event\n             * @param {function} handler\n             */\n            IVPAIDAdUnit.prototype.unsubscribe = function(event, handler) {};\n\n\n\n            /**\n             * getAdLinear\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdLinear = function(callback) {};\n\n            /**\n             * getAdWidth\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdWidth = function(callback) {};\n\n            /**\n             * getAdHeight\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdHeight = function(callback) {};\n\n            /**\n             * getAdExpanded\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdExpanded = function(callback) {};\n\n            /**\n             * getAdSkippableState\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdSkippableState = function(callback) {};\n\n            /**\n             * getAdRemainingTime\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdRemainingTime = function(callback) {};\n\n            /**\n             * getAdDuration\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdDuration = function(callback) {};\n\n            /**\n             * getAdVolume\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdVolume = function(callback) {};\n\n            /**\n             * getAdCompanions\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdCompanions = function(callback) {};\n\n            /**\n             * getAdIcons\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdIcons = function(callback) {};\n\n            /**\n             * setAdVolume\n             *\n             * @param {number} volume\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.setAdVolume = function(volume, callback) {};\n\n            addStaticToInterface(IVPAIDAdUnit, 'METHODS', METHODS);\n            addStaticToInterface(IVPAIDAdUnit, 'GETTERS', GETTERS);\n            addStaticToInterface(IVPAIDAdUnit, 'SETTERS', SETTERS);\n            addStaticToInterface(IVPAIDAdUnit, 'EVENTS', EVENTS);\n\n\n            var VPAID1_METHODS = METHODS.filter(function(method) {\n                return ['skipAd'].indexOf(method) === -1;\n            });\n\n            addStaticToInterface(IVPAIDAdUnit, 'checkVPAIDInterface', function checkVPAIDInterface(creative) {\n                var result = VPAID1_METHODS.every(function(key) {\n                    return typeof creative[key] === 'function';\n                });\n                return result;\n            });\n\n            module.exports = IVPAIDAdUnit;\n\n            function addStaticToInterface(Interface, name, value) {\n                Object.defineProperty(Interface, name, {\n                    writable: false,\n                    configurable: false,\n                    value: value\n                });\n            }\n\n\n        }, {}],\n        2: [function(require, module, exports) {\n            'use strict';\n\n            var IVPAIDAdUnit = require('./IVPAIDAdUnit');\n            var Subscriber = require('./subscriber');\n            var checkVPAIDInterface = IVPAIDAdUnit.checkVPAIDInterface;\n            var utils = require('./utils');\n            var METHODS = IVPAIDAdUnit.METHODS;\n            var ERROR = 'AdError';\n            var AD_CLICK = 'AdClickThru';\n            var FILTERED_EVENTS = IVPAIDAdUnit.EVENTS.filter(function(event) {\n                return event != AD_CLICK;\n            });\n\n            /**\n             * This callback is displayed as global member. The callback use nodejs error-first callback style\n             * @callback NodeStyleCallback\n             * @param {string|null}\n             * @param {undefined|object}\n             */\n\n\n            /**\n             * VPAIDAdUnit\n             * @class\n             *\n             * @param VPAIDCreative\n             * @param {HTMLElement} [el] this will be used in initAd environmentVars.slot if defined\n             * @param {HTMLVideoElement} [video] this will be used in initAd environmentVars.videoSlot if defined\n             */\n            function VPAIDAdUnit(VPAIDCreative, el, video, iframe) {\n                this._isValid = checkVPAIDInterface(VPAIDCreative);\n                if (this._isValid) {\n                    this._creative = VPAIDCreative;\n                    this._el = el;\n                    this._videoEl = video;\n                    this._iframe = iframe;\n                    this._subscribers = new Subscriber();\n                    $addEventsSubscribers.call(this);\n                }\n            }\n\n            VPAIDAdUnit.prototype = Object.create(IVPAIDAdUnit.prototype);\n\n            /**\n             * isValidVPAIDAd will return if the VPAIDCreative passed in constructor is valid or not\n             *\n             * @return {boolean}\n             */\n            VPAIDAdUnit.prototype.isValidVPAIDAd = function isValidVPAIDAd() {\n                return this._isValid;\n            };\n\n            IVPAIDAdUnit.METHODS.forEach(function(method) {\n                //NOTE: this methods arguments order are implemented differently from the spec\n                var ignores = [\n                    'subscribe',\n                    'unsubscribe',\n                    'initAd'\n                ];\n\n                if (ignores.indexOf(method) !== -1) return;\n\n                VPAIDAdUnit.prototype[method] = function() {\n                    var ariaty = IVPAIDAdUnit.prototype[method].length;\n                    // TODO avoid leaking arguments\n                    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n                    var args = Array.prototype.slice.call(arguments);\n                    var callback = (ariaty === args.length) ? args.pop() : undefined;\n\n                    setTimeout(function() {\n                        var result, error = null;\n                        try {\n                            result = this._creative[method].apply(this._creative, args);\n                        } catch (e) {\n                            error = e;\n                        }\n\n                        callOrTriggerEvent(callback, this._subscribers, error, result);\n                    }.bind(this), 0);\n                };\n            });\n\n\n            /**\n             * initAd concreate implementation\n             *\n             * @param {number} width\n             * @param {number} height\n             * @param {string} viewMode can be 'normal', 'thumbnail' or 'fullscreen'\n             * @param {number} desiredBitrate indicates the desired bitrate in kbps\n             * @param {object} [creativeData] used for additional initialization data\n             * @param {object} [environmentVars] used for passing implementation-specific of js version, if el & video was used in constructor slot & videoSlot will be added to the object\n             * @param {NodeStyleCallback} callback\n             */\n            VPAIDAdUnit.prototype.initAd = function initAd(width, height, viewMode, desiredBitrate, creativeData, environmentVars, callback) {\n                creativeData = creativeData || {};\n                environmentVars = utils.extend({\n                    slot: this._el,\n                    videoSlot: this._videoEl\n                }, environmentVars || {});\n\n                setTimeout(function() {\n                    var error;\n                    try {\n                        this._creative.initAd(width, height, viewMode, desiredBitrate, creativeData, environmentVars);\n                    } catch (e) {\n                        error = e;\n                    }\n\n                    callOrTriggerEvent(callback, this._subscribers, error);\n                }.bind(this), 0);\n            };\n\n            /**\n             * subscribe\n             *\n             * @param {string} event\n             * @param {nodeStyleCallback} handler\n             * @param {object} context\n             */\n            VPAIDAdUnit.prototype.subscribe = function subscribe(event, handler, context) {\n                this._subscribers.subscribe(handler, event, context);\n            };\n\n\n            /**\n             * unsubscribe\n             *\n             * @param {string} event\n             * @param {nodeStyleCallback} handler\n             */\n            VPAIDAdUnit.prototype.unsubscribe = function unsubscribe(event, handler) {\n                this._subscribers.unsubscribe(handler, event);\n            };\n\n            //alias\n            VPAIDAdUnit.prototype.on = VPAIDAdUnit.prototype.subscribe;\n            VPAIDAdUnit.prototype.off = VPAIDAdUnit.prototype.unsubscribe;\n\n            IVPAIDAdUnit.GETTERS.forEach(function(getter) {\n                VPAIDAdUnit.prototype[getter] = function(callback) {\n                    setTimeout(function() {\n\n                        var result, error = null;\n                        try {\n                            result = this._creative[getter]();\n                        } catch (e) {\n                            error = e;\n                        }\n\n                        callOrTriggerEvent(callback, this._subscribers, error, result);\n                    }.bind(this), 0);\n                };\n            });\n\n            /**\n             * setAdVolume\n             *\n             * @param volume\n             * @param {nodeStyleCallback} callback\n             */\n            VPAIDAdUnit.prototype.setAdVolume = function setAdVolume(volume, callback) {\n                setTimeout(function() {\n\n                    var self = this;\n                    var result, error = null;\n                    try {\n                        this._creative.setAdVolume(volume);\n                    } catch (e) {\n                        error = e;\n                    }\n                    // Wait for creative volume to be set\n                    setTimeout(function() {\n                        result = self._creative.getAdVolume();\n                        if (!error) {\n                            error = utils.validate(result === volume, 'failed to apply volume: ' + volume);\n                        }\n                        callOrTriggerEvent(callback, self._subscribers, error, result);\n                    }, 200)\n                }.bind(this), 0);\n            };\n\n            VPAIDAdUnit.prototype._destroy = function destroy() {\n                this.stopAd();\n                this._subscribers.unsubscribeAll();\n            };\n\n            function $addEventsSubscribers() {\n                // some ads implement\n                // so they only handle one subscriber\n                // to handle this we create our one\n                FILTERED_EVENTS.forEach(function(event) {\n                    this._creative.subscribe($trigger.bind(this, event), event);\n                }.bind(this));\n\n                // map the click event to be an object instead of depending of the order of the arguments\n                // and to be consistent with the flash\n                this._creative.subscribe($clickThruHook.bind(this), AD_CLICK);\n\n                // because we are adding the element inside the iframe\n                // the user is not able to click in the video\n                if (this._videoEl) {\n                    var documentElement = this._iframe.contentDocument.documentElement;\n                    var videoEl = this._videoEl;\n                    documentElement.addEventListener('click', function(e) {\n                        if (e.target === documentElement) {\n                            videoEl.click();\n                        }\n                    });\n                }\n            }\n\n            function $clickThruHook(url, id, playerHandles) {\n                this._subscribers.triggerSync(AD_CLICK, { url: url, id: id, playerHandles: playerHandles });\n            }\n\n            function $trigger(event) {\n                // TODO avoid leaking arguments\n                // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n                this._subscribers.trigger(event, Array.prototype.slice.call(arguments, 1));\n            }\n\n            function callOrTriggerEvent(callback, subscribers, error, result) {\n                if (callback) {\n                    callback(error, result);\n                } else if (error) {\n                    subscribers.trigger(ERROR, error);\n                }\n            }\n\n            module.exports = VPAIDAdUnit;\n\n\n        }, { \"./IVPAIDAdUnit\": 1, \"./subscriber\": 4, \"./utils\": 5 }],\n        3: [function(require, module, exports) {\n            'use strict';\n\n\n            var utils = require('./utils');\n            var unique = utils.unique('vpaidIframe');\n            var VPAIDAdUnit = require('./VPAIDAdUnit');\n            //var defaultTemplate = \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n</head>\\n<body>\\n    <script type=\\\"text/javascript\\\" src=\\\"{{iframeURL_JS}}\\\"></script>\\n    <script>\\n        parent.postMessage('{\\\"event\\\": \\\"ready\\\", \\\"id\\\": \\\"{{iframeID}}\\\"}', window.location.origin);\\n    </script>\\n    <div class=\\\"ad-element\\\">\\n    </div>\\n</body>\\n</html>\\n\";\n            var defaultTemplate = \"<!DOCTYPE html>\\n<html>\\n <head>\\n </head>\\n <body style=\\\"margin:0px;overflow:hidden;\\\">\\n    <script type=\\\"text/javascript\\\" src=\\\"{{iframeURL_JS}}\\\"></script>\\n    <script>\\n        //parent.postMessage('{\\\"event\\\": \\\"ready\\\", \\\"id\\\": \\\"{{iframeID}}\\\"}', window.location.origin);\\n        //minthe : this should have proper logic for dynamic iframe generates on runtime.\\n        console.log(\\\"send postmessage\\\");\\n        parent.postMessage('{\\\"event\\\": \\\"ready\\\", \\\"id\\\": \\\"{{iframeID}}\\\"}', \\\"*\\\");\\n    </script>\\n    <div class=\\\"ad-element\\\">\\n    </div>\\n</body>\\n</html>\\n\";\n\n            var AD_STOPPED = 'AdStopped';\n\n            /**\n             * This callback is displayed as global member. The callback use nodejs error-first callback style\n             * @callback NodeStyleCallback\n             * @param {string|null}\n             * @param {undefined|object}\n             */\n\n            /**\n             * VPAIDHTML5Client\n             * @class\n             *\n             * @param {HTMLElement} el that will contain the iframe to load adUnit and a el to add to adUnit slot\n             * @param {HTMLVideoElement} video default video element to be used by adUnit\n             * @param {object} [templateConfig] template: html template to be used instead of the default, extraOptions: to be used when rendering the template\n             * @param {object} [vpaidOptions] timeout: when loading adUnit\n             */\n            function VPAIDHTML5Client(el, video, templateConfig, vpaidOptions) {\n                templateConfig = templateConfig || {};\n\n                this._id = unique();\n                this._destroyed = false;\n\n                this._frameContainer = utils.createElementInEl(el, 'div');\n                this._videoEl = video;\n                this._vpaidOptions = vpaidOptions || { timeout: 10000 };\n\n                this._templateConfig = {\n                    template: templateConfig.template || defaultTemplate,\n                    extraOptions: templateConfig.extraOptions || {}\n                };\n\n            }\n\n            /**\n             * destroy\n             *\n             */\n            VPAIDHTML5Client.prototype.destroy = function destroy() {\n                if (this._destroyed) {\n                    return;\n                }\n                this._destroyed = true;\n                $unloadPreviousAdUnit.call(this);\n            };\n\n            /**\n             * isDestroyed\n             *\n             * @return {boolean}\n             */\n            VPAIDHTML5Client.prototype.isDestroyed = function isDestroyed() {\n                return this._destroyed;\n            };\n\n            /**\n             * loadAdUnit\n             *\n             * @param {string} adURL url of the js of the adUnit\n             * @param {nodeStyleCallback} callback\n             */\n            VPAIDHTML5Client.prototype.loadAdUnit = function loadAdUnit(adURL, callback) {\n                $throwIfDestroyed.call(this);\n                $unloadPreviousAdUnit.call(this);\n\n                var frame = utils.createIframeWithContent(\n                    this._frameContainer,\n                    this._templateConfig.template,\n                    utils.extend({\n                        iframeURL_JS: adURL,\n                        iframeID: this.getID()\n                    }, this._templateConfig.extraOptions)\n                );\n                this._frame = frame;\n\n                this._onLoad = utils.callbackTimeout(\n                    this._vpaidOptions.timeout,\n                    onLoad.bind(this),\n                    onTimeout.bind(this)\n                );\n\n                // Set up user activity detection Hook for the iframe;\n                handleUserActivityIframeEvents(this._frame);\n\n                window.addEventListener('message', this._onLoad);\n\n                function onLoad(e) {\n\n                    console.log(\"got postMessage from container\");\n\n                    //minthe : this should have proper logic for dynamic iframe generates on runtime.\n                    //don't clear timeout\n                    //if (e.origin !== window.location.origin) return;\n                    var result = JSON.parse(e.data);\n\n                    //don't clear timeout\n                    if (result.id !== this.getID()) return;\n\n                    var adUnit, error, createAd;\n                    if (!this._frame.contentWindow) {\n\n                        error = 'the iframe is not anymore in the DOM tree';\n\n                    } else {\n                        createAd = this._frame.contentWindow.getVPAIDAd;\n                        error = utils.validate(typeof createAd === 'function', 'the ad didn\\'t return a function to create an ad');\n                    }\n\n                    if (!error) {\n                        var adEl = this._frame.contentWindow.document.querySelector('.ad-element');\n                        adUnit = new VPAIDAdUnit(createAd(), adEl, this._videoEl, this._frame);\n                        adUnit.subscribe(AD_STOPPED, $adDestroyed.bind(this));\n                        error = utils.validate(adUnit.isValidVPAIDAd(), 'the add is not fully complaint with VPAID specification');\n                    }\n\n                    this._adUnit = adUnit;\n                    $destroyLoadListener.call(this);\n                    callback(error, error ? null : adUnit);\n\n                    //clear timeout\n                    return true;\n                }\n\n                function onTimeout() {\n                    callback('timeout', null);\n                }\n\n                // VIDLA 1106 + VIDLA 601:\n                // Root cause for video JS not detecting UserActivity.\n                // if mousemove and touch events happens inside an iframe,\n                // then it is not automatically propogated to the player element.\n                // This code is forcing the mouse and touch event up to video js\n                // so that useractivity logic works just as for Vast mp4s\n                function handleUserActivityIframeEvents(iframe){\n                    // Save any previous handler\n                    var existingOnMouseMove = iframe.contentWindow.onmousemove;\n                    var existingOnMouseOver = iframe.contentWindow.onmouseover;\n                    var existingOnTouchStart = iframe.contentWindow.ontouchstart;\n                    var existingOnTouchEnd = iframe.contentWindow.ontouchend;\n\n\n                    iframe.contentWindow.onmousemove = function(e) {\n                        if (existingOnMouseMove) existingOnMouseMove(e);\n                        forwardMousemove(e);\n                    };\n                    iframe.contentWindow.onmouseover = function(e) {\n                        if (existingOnMouseOver) existingOnMouseOver(e);\n                        forwardMousemove(e);\n                    };\n\n                    function forwardMousemove(e){\n                        var evt = document.createEvent(\"MouseEvents\");\n                        // We'll need this to offset the mouse move appropriately\n                        var boundingClientRect = iframe.getBoundingClientRect();\n                        // Initialize the event, copying exiting event values\n                        // for the most part\n                        evt.initMouseEvent(\n                            \"mousemove\",\n                            true, // bubbles\n                            false, // not cancelable\n                            window,\n                            e.detail,\n                            e.screenX,\n                            e.screenY,\n                            e.clientX + boundingClientRect.left,\n                            e.clientY + boundingClientRect.top,\n                            e.ctrlKey,\n                            e.altKey,\n                            e.shiftKey,\n                            e.metaKey,\n                            e.button,\n                            null // no related element\n                        );\n                        iframe.dispatchEvent(evt);\n                    };\n\n                    iframe.contentWindow.ontouchstart = function(e) {\n                        if (existingOnTouchStart) existingOnTouchStart(e);\n                        forwardTouch(e);\n                    };\n\n                    iframe.contentWindow.ontouchend = function(e) {\n                        if (existingOnTouchEnd) existingOnTouchEnd(e);\n                        forwardTouch(e);\n                    };\n\n                    function forwardTouch(e){\n                        var evt = document.createEvent(\"HTMLEvents\");\n                        evt.initEvent(\n                            e.type,\n                            true, // bubbles\n                            false, // not cancelable\n                            window);\n                        iframe.dispatchEvent(evt);\n                    };\n                };\n            };\n\n            /**\n             * unloadAdUnit\n             *\n             */\n            VPAIDHTML5Client.prototype.unloadAdUnit = function unloadAdUnit() {\n                $unloadPreviousAdUnit.call(this);\n            };\n\n            /**\n             * getID will return the unique id\n             *\n             * @return {string}\n             */\n            VPAIDHTML5Client.prototype.getID = function() {\n                return this._id;\n            };\n\n\n            /**\n             * $removeEl\n             *\n             * @param {string} key\n             */\n            function $removeEl(key) {\n                var el = this[key];\n                if (el) {\n                    el.remove();\n                    delete this[key];\n                }\n            }\n\n            function $adDestroyed() {\n                $removeAdElements.call(this);\n                delete this._adUnit;\n            }\n\n            function $unloadPreviousAdUnit() {\n                $removeAdElements.call(this);\n                $destroyAdUnit.call(this);\n            }\n\n            function $removeAdElements() {\n                $removeEl.call(this, '_frame');\n                $destroyLoadListener.call(this);\n            }\n\n            /**\n             * $destroyLoadListener\n             *\n             */\n            function $destroyLoadListener() {\n                if (this._onLoad) {\n                    window.removeEventListener('message', this._onLoad);\n                    utils.clearCallbackTimeout(this._onLoad);\n                    delete this._onLoad;\n                }\n            }\n\n\n            function $destroyAdUnit() {\n                if (this._adUnit) {\n                    this._adUnit.stopAd();\n                    delete this._adUnit;\n                }\n            }\n\n            /**\n             * $throwIfDestroyed\n             *\n             */\n            function $throwIfDestroyed() {\n                if (this._destroyed) {\n                    throw new Error('VPAIDHTML5Client already destroyed!');\n                }\n            }\n\n            module.exports = VPAIDHTML5Client;\n            window.VPAIDHTML5Client = VPAIDHTML5Client;\n\n\n        }, { \"./VPAIDAdUnit\": 2, \"./utils\": 5 }],\n        4: [function(require, module, exports) {\n            'use strict';\n\n            function Subscriber() {\n                this._subscribers = {};\n            }\n\n            Subscriber.prototype.subscribe = function subscribe(handler, eventName, context) {\n                this.get(eventName).push({ handler: handler, context: context });\n            };\n\n            Subscriber.prototype.unsubscribe = function unsubscribe(handler, eventName) {\n                this._subscribers[eventName] = this.get(eventName).filter(function(subscriber) {\n                    return handler === subscriber.handler;\n                });\n            };\n\n            Subscriber.prototype.unsubscribeAll = function unsubscribeAll() {\n                this._subscribers = {};\n            };\n\n            Subscriber.prototype.trigger = function(eventName, data) {\n                var that = this;\n                that.get(eventName).forEach(function(subscriber) {\n                    setTimeout(function() {\n                        if (that.get(eventName)) {\n                            subscriber.handler.call(subscriber.context, data);\n                        }\n                    }, 0);\n                });\n            };\n\n            Subscriber.prototype.triggerSync = function(eventName, data) {\n                this.get(eventName).forEach(function(subscriber) {\n                    subscriber.handler.call(subscriber.context, data);\n                });\n            };\n\n            Subscriber.prototype.get = function get(eventName) {\n                if (!this._subscribers[eventName]) {\n                    this._subscribers[eventName] = [];\n                }\n                return this._subscribers[eventName];\n            };\n\n            module.exports = Subscriber;\n\n\n        }, {}],\n        5: [function(require, module, exports) {\n            'use strict';\n\n            /**\n             * noop a empty function\n             */\n            function noop() {}\n\n            /**\n             * validate if is not validate will return an Error with the message\n             *\n             * @param {boolean} isValid\n             * @param {string} message\n             */\n            function validate(isValid, message) {\n                return isValid ? null : new Error(message);\n            }\n\n            var timeouts = {};\n            /**\n             * clearCallbackTimeout\n             *\n             * @param {function} func handler to remove\n             */\n            function clearCallbackTimeout(func) {\n                var timeout = timeouts[func];\n                if (timeout) {\n                    clearTimeout(timeout);\n                    delete timeouts[func];\n                }\n            }\n\n            /**\n             * callbackTimeout if the onSuccess is not called and returns true in the timelimit then onTimeout will be called\n             *\n             * @param {number} timer\n             * @param {function} onSuccess\n             * @param {function} onTimeout\n             */\n            function callbackTimeout(timer, onSuccess, onTimeout) {\n                var callback, timeout;\n\n                timeout = setTimeout(function() {\n                    onSuccess = noop;\n                    if (!timeouts[callback]) {\n                        // Timeout has already been resolved.\n                        return;\n                    }\n                    delete timeout[callback];\n                    onTimeout();\n                }, timer);\n\n                callback = function() {\n                    // TODO avoid leaking arguments\n                    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n                    if (onSuccess.apply(this, arguments)) {\n                        clearCallbackTimeout(callback);\n                    }\n                };\n\n                timeouts[callback] = timeout;\n\n                return callback;\n            }\n\n\n            /**\n             * createElementInEl\n             *\n             * @param {HTMLElement} parent\n             * @param {string} tagName\n             * @param {string} id\n             */\n            function createElementInEl(parent, tagName, id) {\n                var nEl = document.createElement(tagName);\n                if (id) nEl.id = id;\n                parent.appendChild(nEl);\n                return nEl;\n            }\n\n            /**\n             * createIframeWithContent\n             *\n             * @param {HTMLElement} parent\n             * @param {string} template simple template using {{var}}\n             * @param {object} data\n             */\n            function createIframeWithContent(parent, template, data) {\n                var iframe = createIframe(parent);\n                if (!setIframeContent(iframe, simpleTemplate(template, data))) return;\n                return iframe;\n            }\n\n            /**\n             * createIframe\n             *\n             * @param {HTMLElement} parent\n             * @param {string} url\n             */\n            function createIframe(parent, url) {\n                var nEl = document.createElement('iframe');\n                nEl.src = url || 'about:blank';\n                nEl.width = '100%';\n                nEl.height = '100%';\n                nEl.style.position = 'absolute';\n                nEl.style.left = '0';\n                nEl.style.top = '0';\n                nEl.style.border = '0';\n                parent.innerHTML = '';\n                parent.appendChild(nEl);\n                return nEl;\n            }\n\n            /**\n             * simpleTemplate\n             *\n             * @param {string} template\n             * @param {object} data\n             */\n            function simpleTemplate(template, data) {\n                Object.keys(data).forEach(function(key) {\n                    var value = (typeof value === 'object') ? JSON.stringify(data[key]) : data[key];\n                    template = template.replace(new RegExp('{{' + key + '}}', 'g'), value);\n                });\n                return template;\n            }\n\n            /**\n             * setIframeContent\n             *\n             * @param {HTMLIframeElement} iframeEl\n             * @param content\n             */\n            function setIframeContent(iframeEl, content) {\n                var iframeDoc = iframeEl.contentWindow && iframeEl.contentWindow.document;\n                if (!iframeDoc) return false;\n\n                iframeDoc.write(content);\n\n                return true;\n            }\n\n\n            /**\n             * extend object with keys from another object\n             *\n             * @param {object} toExtend\n             * @param {object} fromSource\n             */\n            function extend(toExtend, fromSource) {\n                Object.keys(fromSource).forEach(function(key) {\n                    toExtend[key] = fromSource[key];\n                });\n                return toExtend;\n            }\n\n\n            /**\n             * unique will create a unique string everytime is called, sequentially and prefixed\n             *\n             * @param {string} prefix\n             */\n            function unique(prefix) {\n                var count = -1;\n                return function() {\n                    return prefix + '_' + (++count);\n                };\n            }\n\n            module.exports = {\n                noop: noop,\n                validate: validate,\n                clearCallbackTimeout: clearCallbackTimeout,\n                callbackTimeout: callbackTimeout,\n                createElementInEl: createElementInEl,\n                createIframeWithContent: createIframeWithContent,\n                createIframe: createIframe,\n                simpleTemplate: simpleTemplate,\n                setIframeContent: setIframeContent,\n                extend: extend,\n                unique: unique\n            };\n\n\n        }, {}]\n    }, {}, [3])\n\n\n    //# sourceMappingURL=VPAIDHTML5Client.js.map\n    ;\n    //Small subset of async\n    var async = {};\n\n    async.setImmediate = function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    async.iterator = function(tasks) {\n        var makeCallback = function(index) {\n            var fn = function() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function() {\n                return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n\n    async.waterfall = function(tasks, callback) {\n        callback = callback || function() {};\n        if (!isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function(iterator) {\n            return function(err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function() {};\n                } else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    } else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function() {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    async.when = function(condition, callback) {\n        if (!isFunction(callback)) {\n            throw new Error(\"async.when error: missing callback argument\");\n        }\n\n        var isAllowed = isFunction(condition) ? condition : function() {\n            return !!condition;\n        };\n\n        return function() {\n            var args = arrayLikeObjToArray(arguments);\n            var next = args.pop();\n\n            if (isAllowed.apply(null, args)) {\n                return callback.apply(this, arguments);\n            }\n\n            args.unshift(null);\n            return next.apply(null, args);\n        };\n    };\n\n\n\n    ;\n    \"use strict\";\n\n    var dom = {};\n\n    dom.isVisible = function isVisible(el) {\n        var style = window.getComputedStyle(el);\n        return style.visibility !== 'hidden';\n    };\n\n    dom.isHidden = function isHidden(el) {\n        var style = window.getComputedStyle(el);\n        return style.display === 'none';\n    };\n\n    dom.isShown = function isShown(el) {\n        return !dom.isHidden(el);\n    };\n\n    dom.hide = function hide(el) {\n        el.__prev_style_display_ = el.style.display;\n        el.style.display = 'none';\n    };\n\n    dom.show = function show(el) {\n        if (dom.isHidden(el)) {\n            el.style.display = el.__prev_style_display_;\n        }\n        el.__prev_style_display_ = undefined;\n    };\n\n    dom.hasClass = function hasClass(el, cssClass) {\n        var classes, i, len;\n\n        if (isNotEmptyString(cssClass)) {\n            if (el.classList) {\n                return el.classList.contains(cssClass);\n            }\n\n            classes = isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\\s+/) : [];\n            cssClass = (cssClass || '');\n\n            for (i = 0, len = classes.length; i < len; i += 1) {\n                if (classes[i] === cssClass) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    dom.addClass = function(el, cssClass) {\n        var classes;\n\n        if (isNotEmptyString(cssClass)) {\n            if (el.classList) {\n                return el.classList.add(cssClass);\n            }\n\n            classes = isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\\s+/) : [];\n            if (isString(cssClass) && isNotEmptyString(cssClass.replace(/\\s+/, ''))) {\n                classes.push(cssClass);\n                el.setAttribute('class', classes.join(' '));\n            }\n        }\n    };\n\n    dom.removeClass = function(el, cssClass) {\n        var classes;\n\n        if (isNotEmptyString(cssClass)) {\n            if (el.classList) {\n                return el.classList.remove(cssClass);\n            }\n\n            classes = isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\\s+/) : [];\n            var newClasses = [];\n            var i, len;\n            if (isString(cssClass) && isNotEmptyString(cssClass.replace(/\\s+/, ''))) {\n\n                for (i = 0, len = classes.length; i < len; i += 1) {\n                    if (cssClass !== classes[i]) {\n                        newClasses.push(classes[i]);\n                    }\n                }\n                el.setAttribute('class', newClasses.join(' '));\n            }\n        }\n    };\n\n    dom.addEventListener = function addEventListener(el, type, handler) {\n        if (isArray(el)) {\n            forEach(el, function(e) {\n                dom.addEventListener(e, type, handler);\n            });\n            return;\n        }\n\n        if (isArray(type)) {\n            forEach(type, function(t) {\n                dom.addEventListener(el, t, handler);\n            });\n            return;\n        }\n\n        if (el.addEventListener) {\n            el.addEventListener(type, handler, false);\n        } else if (el.attachEvent) {\n            // WARNING!!! this is a very naive implementation !\n            // the event object that should be passed to the handler\n            // would not be there for IE8\n            // we should use \"window.event\" and then \"event.srcElement\"\n            // instead of \"event.target\"\n            el.attachEvent(\"on\" + type, handler);\n        }\n    };\n\n    dom.removeEventListener = function removeEventListener(el, type, handler) {\n        if (isArray(el)) {\n            forEach(el, function(e) {\n                dom.removeEventListener(e, type, handler);\n            });\n            return;\n        }\n\n        if (isArray(type)) {\n            forEach(type, function(t) {\n                dom.removeEventListener(el, t, handler);\n            });\n            return;\n        }\n\n        if (el.removeEventListener) {\n            el.removeEventListener(type, handler, false);\n        } else if (el.detachEvent) {\n            el.detachEvent(\"on\" + type, handler);\n        } else {\n            el[\"on\" + type] = null;\n        }\n    };\n\n    dom.dispatchEvent = function dispatchEvent(el, event) {\n        if (el.dispatchEvent) {\n            el.dispatchEvent(event);\n        } else {\n            el.fireEvent(\"on\" + event.eventType, event);\n        }\n    };\n\n    dom.isDescendant = function isDescendant(parent, child) {\n        var node = child.parentNode;\n        while (node !== null) {\n            if (node === parent) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    };\n\n    dom.getTextContent = function getTextContent(el) {\n        return el.textContent || el.text;\n    };\n\n    dom.prependChild = function prependChild(parent, child) {\n        if (child.parentNode) {\n            child.parentNode.removeChild(child);\n        }\n        return parent.insertBefore(child, parent.firstChild);\n    };\n\n    dom.remove = function removeNode(node) {\n        if (node && node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n    };\n\n    dom.isDomElement = function isDomElement(o) {\n        return o instanceof Element;\n    };\n\n    dom.click = function(el, handler) {\n        dom.addEventListener(el, 'click', handler);\n    };\n\n    dom.once = function(el, type, handler) {\n        function handlerWrap() {\n            handler.apply(null, arguments);\n            dom.removeEventListener(el, type, handlerWrap);\n        }\n\n        dom.addEventListener(el, type, handlerWrap);\n    };\n\n    //Note: there is no getBoundingClientRect on iPad so we need a fallback\n    dom.getDimension = function getDimension(element) {\n        var rect;\n        var parentNode = element.parentNode;\n        // VIDLA-910 Always initializing with 1x1 for creative to better deal with falsy cases.\n        // some creatives do not like 0x0 initializations specially inside iframe.\n        var width = 1;\n        var height = 1;\n        if (parentNode) {\n            width = parentNode.clientWidth ? parentNode.clientWidth : width;\n            height = parentNode.clientHeight ? parentNode.clientHeight : height;\n        }else {\n            width = element.offsetWidth ? element.offsetWidth : width;\n            height = element.offsetHeight ? element.offsetHeight : height;\n        }\n        return {\n            width: width,\n            height: height\n        };\n    };\n\n    \"use strict\";\n\n    var logger = {};\n\n    ;\n    \"use strict\";\n\n    //minthe2 profile\n    var profile = {};\n\n    profile.timeout = 0;\n    profile.initAdTimestamp = 0;\n    profile.adLoadedTimestamp = 0;\n\n    profile.startAdTimestamp = 0;\n    profile.adStartedTimestamp = 0;\n\n    profile.adImpressionTimestamp = 0;\n\n    profile.getState = function() {\n        if (profile.adImpressionTimestamp) {\n            return 'adImpression';\n        }\n        if (profile.startAdTimestamp) {\n            return 'startAd';\n        }\n        if (profile.initAdTimestamp) {\n            return 'initAd';\n        }\n        return 'pluginInit';\n    };\n\n    profile.getRemainingTime = function(type) {\n        var offset = 0;\n        var currTime = new Date().getTime();\n        switch (type) {\n            case 'initAd':\n                offset = currTime - profile.initAdTimestamp;\n                break;\n            case 'AdLoaded':\n                offset = profile.getInitTime();\n                break;\n            case 'startAd':\n                offset = profile.getInitTime();\n                break;\n            case 'AdStarted':\n                offset = profile.getInitTime() + profile.getStartTime();\n                break;\n            case 'AdImpression':\n                offset = profile.getTotalTime();\n                break;\n            default:\n                break;\n        }\n        var remainingTime = profile.timeout - offset;\n        return remainingTime;\n    };\n\n    profile.getInitTime = function() {\n        var interval = profile.adLoadedTimestamp - profile.initAdTimestamp;\n        return interval;\n    };\n\n    profile.getStartTime = function() {\n        var interval = profile.adStartedTimestamp - profile.startAdTimestamp;\n        return interval;\n    };\n\n    profile.getAdImpressionTime = function() {\n        var interval = profile.adImpressionTimestamp - profile.startAdTimestamp;\n        return interval;\n    };\n\n    profile.getTotalTime = function() {\n\n        var interval = profile.getInitTime();\n\n        if (profile.adStartedTimestamp > profile.adImpressionTimestamp) {\n            interval = interval + profile.getStartTime();\n        } else {\n            interval = interval + profile.getAdImpressionTime();\n        }\n\n        // if (profile.adImpressionTimestamp) {\n        //     interval = interval + profile.getAdImpressionTime();\n        // }\n        return interval;\n    };\n\n    ;\n    \"use strict\";\n\n    //minthe2 timer\n    var timer = {};\n\n    timer.killUnresponsiveCreative = false;\n    timer.responseWaitingTime = 1000;\n    timer.killTimeout = null;\n    timer.adCancelTimeout = 5000;\n    timer.adLoadTimeout = null;\n    timer.adStartTimeout = null;\n    // timer.adImpressionTimeout = null;\n    timer.adStartedResponseTime = 0;\n    timer.adImpressionResponseTime = 0;\n\n\n    timer.startKillTimeout = function(adUnit) {\n        if (timer.killUnresponsiveCreative) {\n            // if already timeout is set . cleanup\n            if (timer.killTimeout) {\n                timer.stopKillTimeout();\n            }\n            timer.killTimeout = setTimeout(function() {\n                if (timer.killTimeout) {\n                    logger.log('killUnresponsiveCreative Timeout reached ');\n                    adUnit.stopAd();\n                }\n            }, timer.responseWaitingTime);\n        }\n    };\n\n    timer.stopKillTimeout = function() {\n        if (!timer.killTimeout) {\n            return;\n        }\n        timer.clearTimeout(timer.killTimeout);\n        timer.killTimeout = null;\n    };\n\n    timer.handleAdTimeout = function(cb, state) {\n        logger.error('VPAID AD TIMED OUT :: AFTER ' + state + ' ,timeout value : ' + timer.adCancelTimeout);\n        if (cb) {\n            cb(new VASTError('timeout while waiting for the video to start playing', 402));\n        }\n    };\n\n    timer.clearTimeout = function(timeout) {\n        if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n        }\n    };\n\n    timer.startInitAdTimeout = function(cb) {\n        profile.timeout = timer.adCancelTimeout;\n        profile.initAdTimestamp = new Date().getTime();\n        timer.adLoadTimeout = setTimeout(function() {\n            timer.handleAdTimeout(cb, \"initAd\");\n        }, timer.adCancelTimeout);\n    };\n\n    timer.stopInitAdTimeout = function() {\n        profile.adLoadedTimestamp = new Date().getTime();\n        timer.adStartedResponseTime = timer.adCancelTimeout - profile.getInitTime();\n        timer.clearTimeout(timer.adLoadTimeout);\n\n    };\n\n    timer.startStartAdTimeout = function(cb) {\n        profile.startAdTimestamp = new Date().getTime();\n        var timeoutFunction;\n\n        timeoutFunction = function() {\n            if (profile.adStartedTimestamp > 0) {\n                timer.handleAdTimeout(cb, \"AdStarted\");\n            } else {\n                timer.handleAdTimeout(cb, \"startAd\");\n            }\n        }\n\n        timer.adStartTimeout = setTimeout(timeoutFunction, timer.adStartedResponseTime);\n    };\n\n    timer.stopStartAdTimeout = function() {\n        timer.clearTimeout(timer.adStartTimeout);\n        logger.debug(\"stopStartAdTimeout\");\n    };\n\n    // timer.startAdImpressionTimeout =  function(cb) {\n    //     profile.adImpressionTimestamp = new Date().getTime();\n    //     timer.adImpressionTimeout = setTimeout(function(){\n    //         timer.handleAdTimeout(cb,\"AdStarted\");\n    //     }, timer.adImpressionResponseTime);\n    // };\n\n    // timer.stopAdImpressionTimeout =  function() {\n    //     profile.adImpressionTimestamp = new Date().getTime();\n    //     timer.clearTimeout(timer.adImpressionTimeout);\n    // };\n\n    timer.stopAdTimeouts = function() {\n        logger.debug(\"stopAdTimeouts\");\n        timer.clearTimeout(timer.adLoadTimeout);\n        timer.clearTimeout(timer.adStartTimeout);\n        // timer.clearTimeout(timer.adImpressionTimeout);\n    };\n\n    ;\n    \"use strict\";\n\n    function HttpRequestError(message) {\n        this.message = 'HttpRequest Error: ' + (message || '');\n    }\n    HttpRequestError.prototype = new Error();\n    HttpRequestError.prototype.name = \"HttpRequest Error\";\n\n    function HttpRequest(createXhr) {\n        if (!isFunction(createXhr)) {\n            throw new HttpRequestError('Missing XMLHttpRequest factory method');\n        }\n\n        this.createXhr = createXhr;\n    }\n\n    HttpRequest.prototype.run = function(method, url, callback, options) {\n        sanityCheck(url, callback, options);\n        var timeout, timeoutId;\n        var xhr = this.createXhr();\n        options = options || {};\n        timeout = isNumber(options.timeout) ? options.timeout : 0;\n\n        xhr.open(method, urlParts(url).href, true);\n\n        if (options.headers) {\n            setHeaders(xhr, options.headers);\n        }\n\n        if (options.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        xhr.onload = function() {\n            var statusText, response, status;\n\n            /**\n             * The only way to do a secure request on IE8 and IE9 is with the XDomainRequest object. Unfortunately, microsoft is\n             * so nice that decided that the status property and the 'getAllResponseHeaders' method where not needed so we have to\n             * fake them. If the request gets done with an XDomainRequest instance, we will assume that there are no headers and\n             * the status will always be 200. If you don't like it, DO NOT USE ANCIENT BROWSERS!!!\n             *\n             * For mor info go to: https://msdn.microsoft.com/en-us/library/cc288060(v=vs.85).aspx\n             */\n            if (!xhr.getAllResponseHeaders) {\n                xhr.getAllResponseHeaders = function() {\n                    return null;\n                };\n            }\n\n            if (!xhr.status) {\n                xhr.status = 200;\n            }\n\n            if (isDefined(timeoutId)) {\n                clearTimeout(timeoutId);\n                timeoutId = undefined;\n            }\n\n            statusText = xhr.statusText || '';\n\n            // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n            // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)\n            response = ('response' in xhr) ? xhr.response : xhr.responseText;\n\n            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n            status = xhr.status === 1223 ? 204 : xhr.status;\n\n            callback(\n                status,\n                response,\n                xhr.getAllResponseHeaders(),\n                statusText);\n        };\n\n        xhr.onerror = requestError;\n        xhr.onabort = requestError;\n\n        xhr.send();\n\n        if (timeout > 0) {\n            timeoutId = setTimeout(function() {\n                xhr && xhr.abort();\n            }, timeout);\n        }\n\n        function sanityCheck(url, callback, options) {\n            if (!isString(url) || isEmptyString(url)) {\n                throw new HttpRequestError(\"Invalid url '\" + url + \"'\");\n            }\n\n            if (!isFunction(callback)) {\n                throw new HttpRequestError(\"Invalid handler '\" + callback + \"' for the http request\");\n            }\n\n            if (isDefined(options) && !isObject(options)) {\n                throw new HttpRequestError(\"Invalid options map '\" + options + \"'\");\n            }\n        }\n\n        function setHeaders(xhr, headers) {\n            forEach(headers, function(value, key) {\n                if (isDefined(value)) {\n                    xhr.setRequestHeader(key, value);\n                }\n            });\n        }\n\n        function requestError() {\n            callback(-1, null, null, '');\n        }\n    };\n\n    HttpRequest.prototype.get = function(url, callback, options) {\n        this.run('GET', url, processResponse, options);\n\n        function processResponse(status, response, headersString, statusText) {\n            if (isSuccess(status)) {\n                callback(null, response, status, headersString, statusText);\n            } else {\n                callback(new HttpRequestError(statusText), response, status, headersString, statusText);\n            }\n        }\n\n        function isSuccess(status) {\n            return 200 <= status && status < 300;\n        }\n    };\n\n    function createXhr() {\n        var xhr = new XMLHttpRequest();\n        if (!(\"withCredentials\" in xhr)) {\n            // XDomainRequest for IE.\n            xhr = new XDomainRequest();\n        }\n        return xhr;\n    }\n\n    var http = new HttpRequest(createXhr);\n\n    ;\n    var playerUtils = {};\n\n    /**\n     * Returns an object that captures the portions of player state relevant to\n     * video playback. The result of this function can be passed to\n     * restorePlayerSnapshot with a player to return the player to the state it\n     * was in when this function was invoked.\n     * @param {object} player The videojs player object\n     */\n    playerUtils.getPlayerSnapshot = function getPlayerSnapshot(player) {\n        var tech = player.el().querySelector('.vjs-tech');\n        var snapshot = {\n            ended: player.ended(),\n            src: player.currentSrc(),\n            currentTime: player.currentTime(),\n            type: player.currentType(),\n            playing: !player.paused(),\n            suppressedTracks: getSuppressedTracks(player)\n        };\n\n        if (tech) {\n            snapshot.nativePoster = tech.poster;\n            snapshot.style = tech.getAttribute('style');\n        }\n\n        return snapshot;\n\n        /**** Local Functions ****/\n        function getSuppressedTracks(player) {\n            var tracks = player.remoteTextTracks ? player.remoteTextTracks() : [];\n\n            if (tracks && isArray(tracks.tracks_)) {\n                tracks = tracks.tracks_;\n            }\n\n            if (!isArray(tracks)) {\n                tracks = [];\n            }\n\n            var suppressedTracks = [];\n            tracks.forEach(function(track) {\n                suppressedTracks.push({\n                    track: track,\n                    mode: track.mode\n                });\n                track.mode = 'disabled';\n            });\n\n            return suppressedTracks;\n        }\n    };\n\n    /**\n     * Attempts to modify the specified player so that its state is equivalent to\n     * the state of the snapshot.\n     * @param {object} snapshot - the player state to apply\n     */\n    playerUtils.restorePlayerSnapshot = function restorePlayerSnapshot(player, snapshot) {\n        var tech = player.el().querySelector('.vjs-tech');\n        var attempts = 20; // the number of remaining attempts to restore the snapshot\n\n        if (snapshot.nativePoster) {\n            tech.poster = snapshot.nativePoster;\n        }\n\n        if ('style' in snapshot) {\n            // overwrite all css style properties to restore state precisely\n            tech.setAttribute('style', snapshot.style || '');\n        }\n\n        if (hasSrcChanged(player, snapshot)) {\n            // on ios7, fiddling with textTracks too early will cause safari to crash\n            player.one('contentloadedmetadata', restoreTracks);\n\n            player.one('canplay', tryToResume);\n            ensureCanplayEvtGetsFired();\n\n            // if the src changed for ad playback, reset it\n            player.src({ src: snapshot.src, type: snapshot.type });\n\n            // safari requires a call to `load` to pick up a changed source\n            player.load();\n\n        } else {\n            restoreTracks();\n\n            if (snapshot.playing) {\n                player.play();\n            }\n        }\n\n        /*** Local Functions ***/\n\n        /**\n         * Sometimes firefox does not trigger the 'canplay' evt.\n         * This code ensure that it always gets triggered triggered.\n         */\n        function ensureCanplayEvtGetsFired() {\n            var timeoutId = setTimeout(function() {\n                player.trigger('canplay');\n            }, 1000);\n\n            player.one('canplay', function() {\n                clearTimeout(timeoutId);\n            });\n        }\n\n        /**\n         * Determine whether the player needs to be restored to its state\n         * before ad playback began. With a custom ad display or burned-in\n         * ads, the content player state hasn't been modified and so no\n         * restoration is required\n         */\n        function hasSrcChanged(player, snapshot) {\n            if (player.src()) {\n                return player.src() !== snapshot.src;\n            }\n            // the player was configured through source element children\n            return player.currentSrc() !== snapshot.src;\n        }\n\n        function restoreTracks() {\n            var suppressedTracks = snapshot.suppressedTracks;\n            suppressedTracks.forEach(function(trackSnapshot) {\n                trackSnapshot.track.mode = trackSnapshot.mode;\n            });\n        }\n\n        /**\n         * Determine if the video element has loaded enough of the snapshot source\n         * to be ready to apply the rest of the state\n         */\n        function tryToResume() {\n            if (playerUtils.isReadyToResume(tech)) {\n                // if some period of the video is seekable, resume playback\n                return resume();\n            }\n\n            // delay a bit and then check again unless we're out of attempts\n            if (attempts--) {\n                setTimeout(tryToResume, 50);\n            } else {\n                (function() {\n                    try {\n                        resume();\n                    } catch (e) {\n                        videojs.log.warn('Failed to resume the content after an advertisement', e);\n                    }\n                })();\n            }\n\n\n            /*** Local functions ***/\n            function resume() {\n                player.currentTime(snapshot.currentTime);\n\n                if (snapshot.playing) {\n                    player.play();\n                }\n            }\n\n        }\n    };\n\n    playerUtils.isReadyToResume = function(tech) {\n        if (tech.readyState > 1) {\n            // some browsers and media aren't \"seekable\".\n            // readyState greater than 1 allows for seeking without exceptions\n            return true;\n        }\n\n        if (tech.seekable === undefined) {\n            // if the tech doesn't expose the seekable time ranges, try to\n            // resume playback immediately\n            return true;\n        }\n\n        if (tech.seekable.length > 0) {\n            // if some period of the video is seekable, resume playback\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * This function prepares the player to display ads.\n     * Adding convenience events like the 'vast.firsPlay' that gets fired when the video is first played\n     * and ads the blackPoster to the player to prevent content from being displayed before the preroll ad.\n     *\n     * @param player\n     */\n    playerUtils.prepareForAds = function(player, disableMonkeyPatchPlayerApi) {\n\n        var blackPoster = player.addChild('blackPoster');\n        var _firstPlay = true;\n        var volumeSnapshot;\n\n        // VID-1955 Causes Interference with Waterfall playback\n        // VIDLA-853 Causes Interference with Mobile App playback\n        if (!disableMonkeyPatchPlayerApi) {\n            monkeyPatchPlayerApi();\n        }\n\n        player.on('play', tryToTriggerFirstPlay);\n        player.on('vast.reset', resetFirstPlay); //Every time we change the sources we reset the first play.\n        player.on('vast.firstPlay', restoreContentVolume);\n        player.on('error', hideBlackPoster); //If there is an error in the player we remove the blackposter to show the err msg\n        player.on('vast.adStart', hideBlackPoster);\n        player.on('vast.adsCancel', hideBlackPoster);\n        player.on('vast.adError', hideBlackPoster);\n        player.on('vast.adStart', addStyles);\n        player.on('vast.adEnd', removeStyles);\n        player.on('vast.adsCancel', removeStyles);\n\n        /*** Local Functions ***/\n\n        /**\n         What this function does is ugly and horrible and I should think twice before calling myself a good developer. With that said,\n         it is the best solution I could find to mute the video until the 'play' event happens (on mobile devices) and the plugin can decide whether\n         to play the ad or not.\n\n         We also need this monkeypatch to be able to pause and resume an ad using the player's API\n\n         If you have a better solution please do tell me.\n         */\n        function monkeyPatchPlayerApi() {\n\n            /**\n             * Monkey patch needed to handle firstPlay and resume of playing ad.\n             *\n             * @param prepareForAds necessary flag to prevent infinite loop when you are restoring a VAST ad.\n             * @returns {player}\n             */\n            var origPlay = player.play;\n            player.play = function(callOrigPlay) {\n\n\n\n\n                if (isFirstPlay()) {\n                    firstPlay.call(this);\n                } else {\n                    resume.call(this, callOrigPlay);\n                }\n\n                return this;\n\n                /*** local functions ***/\n                function firstPlay() {\n\n\n                    if (!isIPhone()) {\n                        volumeSnapshot = saveVolumeSnapshot();\n                        player.muted(true);\n                    }\n                    // Do not call play on the video element instead just trigger startAd and the creative will call play as it is suppose to.\n                    // VID-2515 Force the enabling of the spinner. As we do not call actual play the wait state to trigger spinner never gets activated until its too late.\n                    player.addClass('vjs-waiting');\n                    player.trigger('firstplay');\n                    player.trigger('play');\n                }\n\n                function resume(callOrigPlay) {\n                    if (isAdPlaying() && !callOrigPlay) {\n                        player.vast.adUnit.resumeAd();\n                    } else {\n                        origPlay.apply(this, arguments);\n                    }\n                }\n            };\n\n\n            /**\n             * Needed monkey patch to handle pause of playing ad.\n             *\n             * @param callOrigPlay necessary flag to prevent infinite loop when you are pausing a VAST ad.\n             * @returns {player}\n             */\n            var origPause = player.pause;\n            player.pause = function(callOrigPause) {\n                if (isAdPlaying() && !callOrigPause) {\n                    player.vast.adUnit.pauseAd();\n                } else {\n                    origPause.apply(this, arguments);\n                }\n                return this;\n            };\n\n\n            /**\n             * Needed monkey patch to handle paused state of the player when ads are playing.\n             *\n             * @param callOrigPlay necessary flag to prevent infinite loop when you are pausing a VAST ad.\n             * @returns {player}\n             */\n            var origPaused = player.paused;\n            player.paused = function(callOrigPaused) {\n                if (isAdPlaying() && !callOrigPaused) {\n                    return player.vast.adUnit.isPaused();\n                }\n                return origPaused.apply(this, arguments);\n            };\n        }\n\n        function isAdPlaying() {\n            return player.vast && player.vast.adUnit;\n        }\n\n        function tryToTriggerFirstPlay() {\n\n            if (isFirstPlay()) {\n                _firstPlay = false;\n                player.trigger('vast.firstPlay');\n            }\n        }\n\n        function resetFirstPlay() {\n            _firstPlay = true;\n            blackPoster.show();\n            restoreContentVolume();\n        }\n\n        function isFirstPlay() {\n            return _firstPlay;\n        }\n\n        function saveVolumeSnapshot() {\n            return {\n                muted: player.muted(),\n                volume: player.volume()\n            };\n        }\n\n        function restoreContentVolume() {\n            if (volumeSnapshot) {\n                player.currentTime(0);\n                restoreVolumeSnapshot(volumeSnapshot);\n                volumeSnapshot = null;\n            }\n        }\n\n        function restoreVolumeSnapshot(snapshot) {\n            if (isObject(snapshot)) {\n                player.volume(snapshot.volume);\n                player.muted(snapshot.muted);\n            }\n        }\n\n        function hideBlackPoster() {\n            if (!dom.hasClass(blackPoster.el(), 'vjs-hidden')) {\n                blackPoster.hide();\n            }\n        }\n\n        function addStyles() {\n            dom.addClass(player.el(), 'vjs-ad-playing');\n        }\n\n        function removeStyles() {\n            dom.removeClass(player.el(), 'vjs-ad-playing');\n        }\n    };\n\n    /**\n     * Remove the poster attribute from the video element tech, if present. When\n     * reusing a video element for multiple videos, the poster image will briefly\n     * reappear while the new source loads. Removing the attribute ahead of time\n     * prevents the poster from showing up between videos.\n     * @param {object} player The videojs player object\n     */\n    playerUtils.removeNativePoster = function(player) {\n        var tech = player.el().querySelector('.vjs-tech');\n        if (tech) {\n            tech.removeAttribute('poster');\n        }\n    };\n\n    /**\n     * Helper function to listen to many events until one of them gets fired, then we\n     * execute the handler and unsubscribe all the event listeners;\n     *\n     * @param player specific player from where to listen for the events\n     * @param events array of events\n     * @param handler function to execute once one of the events fires\n     */\n    playerUtils.once = function once(player, events, handler) {\n        function listener() {\n            handler.apply(null, arguments);\n\n            events.forEach(function(event) {\n                player.off(event, listener);\n            });\n        }\n\n        events.forEach(function(event) {\n            player.on(event, listener);\n        });\n    };\n\n    ;\n    'use strict';\n\n    /**\n     * documentMode is an IE-only property\n     * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx\n     */\n    var msie = document.documentMode;\n\n    /**\n     *\n     * IMPORTANT NOTE: This function comes from angularJs and was originally called urlResolve\n     *                 you can take a look at the original code here https://github.com/angular/angular.js/blob/master/src/ng/urlUtils.js\n     *\n     * Implementation Notes for non-IE browsers\n     * ----------------------------------------\n     * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,\n     * results both in the normalizing and parsing of the URL.  Normalizing means that a relative\n     * URL will be resolved into an absolute URL in the context of the application document.\n     * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related\n     * properties are all populated to reflect the normalized URL.  This approach has wide\n     * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See\n     * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html\n     *\n     * Implementation Notes for IE\n     * ---------------------------\n     * IE >= 8 and <= 10 normalizes the URL when assigned to the anchor node similar to the other\n     * browsers.  However, the parsed components will not be set if the URL assigned did not specify\n     * them.  (e.g. if you assign a.href = \"foo\", then a.protocol, a.host, etc. will be empty.)  We\n     * work around that by performing the parsing in a 2nd step by taking a previously normalized\n     * URL (e.g. by assigning to a.href) and assigning it a.href again.  This correctly populates the\n     * properties such as protocol, hostname, port, etc.\n     *\n     * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one\n     * uses the inner HTML approach to assign the URL as part of an HTML snippet -\n     * http://stackoverflow.com/a/472729)  However, setting img[src] does normalize the URL.\n     * Unfortunately, setting img[src] to something like \"javascript:foo\" on IE throws an exception.\n     * Since the primary usage for normalizing URLs is to sanitize such URLs, we can't use that\n     * method and IE < 8 is unsupported.\n     *\n     * References:\n     *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement\n     *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html\n     *   http://url.spec.whatwg.org/#urlutils\n     *   https://github.com/angular/angular.js/pull/2902\n     *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/\n     *\n     * @kind function\n     * @param {string} url The URL to be parsed.\n     * @description Normalizes and parses a URL.\n     * @returns {object} Returns the normalized URL as a dictionary.\n     *\n     *   | member name   | Description    |\n     *   |---------------|----------------|\n     *   | href          | A normalized version of the provided URL if it was not an absolute URL |\n     *   | protocol      | The protocol including the trailing colon                              |\n     *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |\n     *   | search        | The search params, minus the question mark                             |\n     *   | hash          | The hash string, minus the hash symbol\n     *   | hostname      | The hostname\n     *   | port          | The port, without \":\"\n     *   | pathname      | The pathname, beginning with \"/\"\n     *\n     */\n\n    var urlParsingNode = document.createElement(\"a\");\n\n    function urlParts(url) {\n        var href = url;\n\n        if (msie) {\n            // Normalize before parse.  Refer Implementation Notes on why this is\n            // done in two steps on IE.\n            urlParsingNode.setAttribute(\"href\", href);\n            href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n            href: urlParsingNode.href,\n            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n            host: urlParsingNode.host,\n            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n            hostname: urlParsingNode.hostname,\n            port: isNotEmptyString(urlParsingNode.port) ? urlParsingNode.port : 80,\n            pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname\n        };\n    }\n\n\n    /**\n     * This function accepts a query string (search part of a url) and returns a dictionary with\n     * the different key value pairs\n     * @param {string} qs queryString\n     */\n    function queryStringToObj(qs, cond) {\n        var pairs, qsObj;\n\n        cond = isFunction(cond) ? cond : function() {\n            return true;\n        };\n\n        qs = qs.trim().replace(/^\\?/, '');\n        pairs = qs.split('&');\n        qsObj = {};\n\n        forEach(pairs, function(pair) {\n            var keyValue, key, value;\n            if (pair !== '') {\n                keyValue = pair.split('=');\n                key = keyValue[0];\n                value = keyValue[1];\n                if (cond(key, value)) {\n                    qsObj[key] = value;\n                }\n            }\n        });\n\n        return qsObj;\n    }\n\n    /**\n     * This function accepts an object and serializes it into a query string without the leading '?'\n     * @param obj\n     * @returns {string}\n     */\n    function objToQueryString(obj) {\n        var pairs = [];\n        forEach(obj, function(value, key) {\n            pairs.push(key + '=' + value);\n        });\n        return pairs.join('&');\n    }\n\n\n    ;\n    var xml = {};\n\n    xml.strToXMLDoc = function strToXMLDoc(stringContainingXMLSource) {\n        //IE 8\n        if (typeof window.DOMParser === 'undefined') {\n            var xmlDocument = new ActiveXObject('Microsoft.XMLDOM');\n            xmlDocument.async = false;\n            xmlDocument.loadXML(stringContainingXMLSource);\n            return xmlDocument;\n        }\n\n        return parseString(stringContainingXMLSource);\n\n        function parseString(stringContainingXMLSource) {\n            var parser = new DOMParser();\n            var parsedDocument;\n\n            //Note: This try catch is to deal with the fact that on IE parser.parseFromString does throw an error but the rest of the browsers don't.\n            try {\n                parsedDocument = parser.parseFromString(stringContainingXMLSource, \"application/xml\");\n\n                if (isParseError(parsedDocument) || isEmptyString(stringContainingXMLSource)) {\n                    throw new Error();\n                }\n            } catch (e) {\n                throw new Error(\"xml.strToXMLDOC: Error parsing the string: '\" + stringContainingXMLSource + \"'\");\n            }\n\n            return parsedDocument;\n        }\n\n        function isParseError(parsedDocument) {\n            try { // parser and parsererrorNS could be cached on startup for efficiency\n                var parser = new DOMParser(),\n                    errorneousParse = parser.parseFromString('INVALID', 'text/xml'),\n                    parsererrorNS = errorneousParse.getElementsByTagName(\"parsererror\")[0].namespaceURI;\n\n                if (parsererrorNS === 'http://www.w3.org/1999/xhtml') {\n                    // In PhantomJS the parseerror element doesn't seem to have a special namespace, so we are just guessing here :(\n                    return parsedDocument.getElementsByTagName(\"parsererror\").length > 0;\n                }\n\n                return parsedDocument.getElementsByTagNameNS(parsererrorNS, 'parsererror').length > 0;\n            } catch (e) {\n                //Note on IE parseString throws an error by itself and it will never reach this code. Because it will have failed before\n            }\n        }\n    };\n\n    xml.parseText = function parseText(sValue) {\n        if (/^\\s*$/.test(sValue)) {\n            return null; }\n        if (/^(?:true|false)$/i.test(sValue)) {\n            return sValue.toLowerCase() === \"true\"; }\n        if (isFinite(sValue)) {\n            return parseFloat(sValue); }\n        if (isISO8601(sValue)) {\n            return new Date(sValue); }\n        return sValue.trim();\n    };\n\n    xml.JXONTree = function JXONTree(oXMLParent) {\n        var parseText = xml.parseText;\n\n        //The document object is an especial object that it may miss some functions or attrs depending on the browser.\n        //To prevent this problem with create the JXONTree using the root childNode which is a fully fleshed node on all supported\n        //browsers.\n        if (oXMLParent.documentElement) {\n            return new xml.JXONTree(oXMLParent.documentElement);\n        }\n\n        if (oXMLParent.hasChildNodes()) {\n            var sCollectedTxt = \"\";\n            for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {\n                oNode = oXMLParent.childNodes.item(nItem);\n                /*jshint bitwise: false*/\n                if ((oNode.nodeType - 1 | 1) === 3) { sCollectedTxt += oNode.nodeType === 3 ? oNode.nodeValue.trim() : oNode.nodeValue; } else if (oNode.nodeType === 1 && !oNode.prefix) {\n                    sProp = decapitalize(oNode.nodeName);\n                    vContent = new xml.JXONTree(oNode);\n                    if (this.hasOwnProperty(sProp)) {\n                        if (this[sProp].constructor !== Array) { this[sProp] = [this[sProp]]; }\n                        this[sProp].push(vContent);\n                    } else { this[sProp] = vContent; }\n                }\n            }\n            if (sCollectedTxt) { this.keyValue = parseText(sCollectedTxt); }\n        }\n\n        //IE8 Stupid fix\n        var hasAttr = typeof oXMLParent.hasAttributes === 'undefined' ? oXMLParent.attributes.length > 0 : oXMLParent.hasAttributes();\n        if (hasAttr) {\n            var oAttrib;\n            for (var nAttrib = 0; nAttrib < oXMLParent.attributes.length; nAttrib++) {\n                oAttrib = oXMLParent.attributes.item(nAttrib);\n                this[\"@\" + decapitalize(oAttrib.name)] = parseText(oAttrib.value.trim());\n            }\n        }\n    };\n\n    xml.JXONTree.prototype.attr = function(attr) {\n        return this['@' + decapitalize(attr)];\n    };\n\n    xml.toJXONTree = function toJXONTree(xmlString) {\n        var xmlDoc = xml.strToXMLDoc(xmlString);\n        return new xml.JXONTree(xmlDoc);\n    };\n\n    /**\n     * Helper function to extract the keyvalue of a JXONTree obj\n     *\n     * @param xmlObj {JXONTree}\n     * return the key value or undefined;\n     */\n    xml.keyValue = function getKeyValue(xmlObj) {\n        if (xmlObj) {\n            return xmlObj.keyValue;\n        }\n        return undefined;\n    };\n\n    xml.attr = function getAttrValue(xmlObj, attr) {\n        if (xmlObj) {\n            return xmlObj['@' + decapitalize(attr)];\n        }\n        return undefined;\n    };\n\n    xml.encode = function encodeXML(str) {\n        return str.replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    };\n\n    xml.decode = function decodeXML(str) {\n        return str.replace(/&apos;/g, \"'\")\n            .replace(/&quot;/g, '\"')\n            .replace(/&gt;/g, '>')\n            .replace(/&lt;/g, '<')\n            .replace(/&amp;/g, '&');\n    };;\n\n    //minthe : initalize vastClient\n    vjs.plugin('vastClient', function VASTPlugin(options) {\n\n        var snapshot;\n        var player = this;\n        var vast = new VASTClient();\n        var adsCanceled = false;\n        var defaultOpts = {\n            // maximum amount of time in ms to wait to receive `adsready` from the ad\n            // implementation after play has been requested. Ad implementations are\n            // expected to load any dynamic libraries and make any requests to determine\n            // ad policies for a video during this time.\n            timeout: 500,\n\n            //TODO:finish this IOS FIX\n            //Whenever you play an add on IOS, the native player kicks in and we loose control of it. On very heavy pages the 'play' event\n            // May occur after the video content has already started. This is wrong if you want to play a preroll ad that needs to happen before the user\n            // starts watching the content. To prevent this usec\n            iosPrerollCancelTimeout: 2000,\n\n            // maximun amount of time for the ad to actually start playing. If this timeout gets\n            // triggered the ads will be cancelled\n            adCancelTimeout: 5000,\n\n            // Boolean flag that configures the player to play a new ad before the user sees the video again\n            // the current video\n            playAdAlways: false,\n\n            // Flag to enable or disable the ads by default.\n            adsEnabled: true,\n\n            // Boolean flag to enable or disable the resize with window.resize or orientationchange\n            autoResize: true,\n\n            // Path to the VPAID flash ad's loader\n            vpaidFlashLoaderPath: '/VPAIDFlash.swf',\n\n            //Boolean flag to enable/disable Controls on mouse over/out.\n            disableControlsOnMouseover: false,\n\n            initialAudio: 'off',\n\n            overlayPlayer: false,\n\n            mobileSDK: false,\n\n            controlBarPosition: \"below\"\n        };\n\n        var settings = extend({}, defaultOpts, options || {});\n\n        if (isUndefined(settings.adTagUrl) && isDefined(settings.url)) {\n            settings.adTagUrl = settings.url;\n        }\n\n        if (isString(settings.adTagUrl)) {\n            settings.adTagUrl = echoFn(settings.adTagUrl);\n        }\n\n        if (isDefined(settings.adTagXML) && !isFunction(settings.adTagXML)) {\n            return trackAdError(new VASTError('on VideoJS VAST plugin, the passed adTagXML option does not contain a function'));\n        }\n\n        if (!isDefined(settings.adTagUrl) && !isFunction(settings.adTagXML)) {\n            return trackAdError(new VASTError('on VideoJS VAST plugin, missing adTagUrl on options object'));\n        }\n        //VIDLA-1491 Disabling for iOS. Few creatives such as Mediamind(Bemruda) and Moat create playback problems\n        var disableForOverlay = settings.overlayPlayer && isIDevice();\n        var disableMonkeyPatchPlayerApi =  disableForOverlay || settings.mobileSDK ;\n        playerUtils.prepareForAds(player, disableMonkeyPatchPlayerApi);\n        if (settings.playAdAlways) {\n            // No matter what happens we play a new ad before the user sees the video again.\n            player.on('vast.contentEnd', function() {\n                setTimeout(function() {\n                    player.trigger('vast.reset');\n                }, 0);\n            });\n        }\n\n        player.on('vast.firstPlay', tryToPlayPrerollAd);\n\n        player.on('vast.reset', function() {\n            //If we are reseting the plugin, we don't want to restore the content\n            snapshot = null;\n            cancelAds();\n        });\n\n        player.vast = {\n            isEnabled: function() {\n                return settings.adsEnabled;\n            },\n\n            enable: function() {\n                settings.adsEnabled = true;\n            },\n\n            disable: function() {\n                settings.adsEnabled = false;\n            }\n        };\n\n        if (settings.loggerCallback) {\n            logger = settings.loggerCallback;\n        } else {\n            logger = console;\n        }\n        if (settings.terminateUnresponsiveVPAIDCreative) {\n            timer.killUnresponsiveCreative = true;\n        }\n        if (settings.adCancelTimeout) {\n            timer.adCancelTimeout = settings.adCancelTimeout;\n        }\n\n        var vastResponse = getAnVastXml();\n        var adIntegrator = isVPAID(vastResponse) ? new VPAIDIntegrator(player, settings) : new VASTIntegrator(player);\n\n        if (settings.delayExpandUntilVPAIDInit) {\n            checkAd(); //minthe : invoke init method of vpaid creative here in order to check valid ad, at the end of this checkAd process it will dispatch custom event which is called \"an.readytogovpaid\"\n        }\n\n        return player.vast;\n\n\n\n        /**** Local functions ****/\n        function tryToPlayPrerollAd() {\n            //We remove the poster to prevent flickering whenever the content starts playing\n            playerUtils.removeNativePoster(player);\n\n            playerUtils.once(player, ['vast.adsCancel', 'vast.adEnd'], function() {\n                removeAdUnit();\n                restoreVideoContent();\n            });\n\n            async.waterfall([\n                checkAdsEnabled,\n                preparePlayerForAd,\n                playPrerollAd\n            ], function(error, response) {\n                if (error) {\n                    trackAdError(error, response);\n                } else {\n                    player.trigger('vast.adEnd');\n                }\n            });\n\n            /*** Local functions ***/\n\n            function removeAdUnit() {\n                if (player.vast && player.vast.adUnit) {\n                    player.vast.adUnit = null; //We remove the adUnit\n                }\n            }\n\n            function restoreVideoContent() {\n                setupContentEvents();\n                if (snapshot) {\n                    playerUtils.restorePlayerSnapshot(player, snapshot);\n                    snapshot = null;\n                }\n            }\n\n            function setupContentEvents() {\n                playerUtils.once(player, ['playing', 'vast.reset', 'vast.firstPlay'], function(evt) {\n                    if (evt.type !== 'playing') {\n                        return;\n                    }\n\n                    player.trigger('vast.contentStart');\n\n                    playerUtils.once(player, ['ended', 'vast.reset', 'vast.firstPlay'], function(evt) {\n                        if (evt.type === 'ended') {\n                            player.trigger('vast.contentEnd');\n                        }\n                    });\n                });\n            }\n\n            function checkAdsEnabled(next) {\n                if (settings.adsEnabled) {\n                    return next(null);\n                }\n                next(new VASTError('Ads are not enabled'));\n            }\n\n            function preparePlayerForAd(next) {\n                if (canPlayPrerollAd()) {\n                    snapshot = playerUtils.getPlayerSnapshot(player);\n                    addSpinnerIcon();\n                    next(null);\n                } else {\n                    next(new VASTError('video content has been playing before preroll ad'));\n                }\n            }\n\n            function canPlayPrerollAd() {\n                return !isIPhone() || player.currentTime() <= settings.iosPrerollCancelTimeout;\n            }\n\n            function addSpinnerIcon() {\n                dom.addClass(player.el(), 'vjs-vast-ad-loading');\n                playerUtils.once(player, ['vast.adStart', 'vast.adsCancel'], removeSpinnerIcon);\n            }\n\n            function removeSpinnerIcon() {\n                //IMPORTANT NOTE: We remove the spinnerIcon asynchronously to give time to the browser to start the video.\n                // If we remove it synchronously we see a flash of the content video before the ad starts playing.\n                setTimeout(function() {\n                    dom.removeClass(player.el(), 'vjs-vast-ad-loading');\n                }, 100);\n            }\n\n        }\n\n        function cancelAds() {\n            player.trigger('vast.adsCancel');\n            adsCanceled = true;\n        }\n\n        function playPrerollAd(callback) {\n            async.waterfall([\n                //getVastResponse,//minthe : comment out, we're not using mail online's vast parser and loader\n                playAd\n            ], callback);\n        }\n\n        function getVastResponse(callback) {\n            vast.getVASTResponse(settings.adTagUrl ? settings.adTagUrl() : settings.adTagXML, callback);\n        }\n\n        function getAnVastXml() { //minthe : override vast response to use jsVpaidUrl coming from videoplayer framework\n            var vastResponse = new VASTResponse();\n            vastResponse._linearAdded = true;\n            vastResponse.ads = [{\n                \"id\": 1234567,\n                \"inLine\": {\n                    \"adTitle\": \"\",\n                    \"adSystem\": \"\",\n                    \"impressions\": [],\n                    \"creatives\": [{\n                        \"sequence\": 1,\n                        \"linear\": {\n                            \"duration\": 13000,\n                            \"mediaFiles\": [{\n                                \"src\": settings.jsVpaidUrl,\n                                \"type\": \"application/javascript\",\n                                \"apiFramework\": \"VPAID\"\n                            }],\n                            \"skipoffset\": null,\n                        }\n                    }, { \"sequence\": 1 }],\n                    \"description\": \"Vpaid Linear Video Ad\",\n                    \"surveys\": []\n                }\n            }];\n            vastResponse.errorURLMacros = [];\n            vastResponse.impressions = [];\n            vastResponse.customClicks = [];\n            vastResponse.mediaFiles = [{\n                \"src\": settings.jsVpaidUrl,\n                \"type\": \"application/javascript\",\n                \"apiFramework\": \"VPAID\"\n            }];\n            vastResponse.clickThrough = settings.clickUrl;\n            vastResponse.adTitle = \"\";\n            vastResponse.adParameters = settings.adParameters;\n\n            return vastResponse;\n        }\n\n        function playAd(vastResponse, callback) {\n\n            //minthe : override vast response to use jsVpaidUrl coming from videoplayer framework\n            vastResponse = getAnVastXml();\n\n            //TODO: Find a better way to stop the play. The 'playPrerollWaterfall' ends in an inconsistent situation\n            //If the state is not 'preroll?' it means the ads were canceled therefore, we break the waterfall\n            if (adsCanceled) {\n                return;\n            }\n\n            var adFinished = false;\n\n            //comment out for VID-1359\n            //if (isIDevice()) {\n            //preventManualProgress();\n            //}\n            callback = callback || trackAdError;\n            player.vast.adUnit = adIntegrator.playAd(vastResponse, callback);\n\n            //comment out for VID-1359\n            //function preventManualProgress() {\n            //    //IOS video clock is very unreliable and we need a 3 seconds threshold to ensure that the user forwarded/rewound the ad\n            //    var PROGRESS_THRESHOLD = 3;\n            //    var previousTime = 0;\n            //    var tech = player.el().querySelector('.vjs-tech');\n            //    var skipad_attempts = 0;\n            //\n            //    player.on('timeupdate', adTimeupdateHandler);\n            //    playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel', 'vast.adError'], stopPreventManualProgress);\n            //\n            //    /*** Local functions ***/\n            //    function adTimeupdateHandler() {\n            //        var currentTime = player.currentTime();\n            //        var progressDelta = Math.abs(currentTime - previousTime);\n            //\n            //        if (progressDelta > PROGRESS_THRESHOLD) {\n            //            skipad_attempts += 1;\n            //            if (skipad_attempts >= 2) {\n            //                player.pause();\n            //            }\n            //            player.currentTime(previousTime);\n            //        } else {\n            //            previousTime = currentTime;\n            //        }\n            //    }\n            //\n            //    function stopPreventManualProgress() {\n            //        player.off('timeupdate', adTimeupdateHandler);\n            //    }\n            //}\n        }\n\n        //minthe : checkAd to check vpaid ad is ready to go\n        function checkAd(vastResponse, callback) {\n            vastResponse = getAnVastXml();\n            callback = callback || trackAdError;\n            player.vast.adUnit = adIntegrator.playAd(vastResponse, callback, true);\n        }\n\n        function trackAdError(error, vastResponse) {\n            if (!error) return;\n            player.trigger({ type: 'vast.adError', error: error });\n            cancelAds();\n            if (console && console.log) {\n                console.log('AD ERROR:', error.message, error, vastResponse);\n            }\n        }\n\n        function isVPAID(vastResponse) {\n            var i, len;\n            var mediaFiles = vastResponse.mediaFiles;\n            for (i = 0, len = mediaFiles.length; i < len; i++) {\n                if (vastUtil.isVPAID(mediaFiles[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    });\n\n    ;\n    vjs.AdsLabel = vjs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n            vjs.Component.call(this, player, options);\n\n            var that = this;\n\n            // We asynchronously reposition the ads label element\n            setTimeout(function() {\n                var currentTimeComp = player.controlBar && (player.controlBar.getChild(\"timerControls\") || player.controlBar.getChild(\"currentTimeDisplay\"));\n                if (currentTimeComp) {\n                    player.controlBar.el().insertBefore(that.el(), currentTimeComp.el());\n                }\n                dom.removeClass(that.el(), 'vjs-label-hidden');\n            }, 0);\n        }\n    });\n\n    vjs.AdsLabel.prototype.createEl = function() {\n        return vjs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-ads-label vjs-control vjs-label-hidden',\n            innerHTML: 'Advertisement'\n        });\n    };;\n    /**\n     * The component that shows a black screen until the ads plugin has decided if it can or it can not play the ad.\n     *\n     * Note: In case you wonder why instead of this black poster we don't just show the spinner loader.\n     *       IOS devices do not work well with animations and the browser chrashes from time to time That is why we chose to\n     *       have a secondary black poster.\n     *\n     *       It also makes it much more easier for the users of the plugin since it does not change the default behaviour of the\n     *       spinner and the player works the same way with and without the plugin.\n     *\n     * @param {vjs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n    vjs.BlackPoster = vjs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n            vjs.Component.call(this, player, options);\n\n            var posterImg = player.getChild('posterImage');\n\n            //We need to do it asynchronously to be sure that the black poster el is on the dom.\n            setTimeout(function() {\n                if (posterImg) {\n                    player.el().insertBefore(this.el(), posterImg.el());\n                }\n            }.bind(this), 0);\n        }\n    });\n\n    /**\n     * Create the black poster div element\n     * @return {Element}\n     */\n    vjs.BlackPoster.prototype.createEl = function() {\n        return vjs.createEl('div', {\n            className: 'vjs-black-poster'\n        });\n    };;\n\n    function VPAIDAdUnitWrapper(vpaidAdUnit, opts) {\n        if (!(this instanceof VPAIDAdUnitWrapper)) {\n            return new VPAIDAdUnitWrapper(vpaidAdUnit, opts);\n        }\n        sanityCheck(vpaidAdUnit, opts);\n\n        this.options = extend({}, opts);\n\n        this._adUnit = vpaidAdUnit;\n        this._adLoaded = false;\n        this._adStopped = false;\n        this._adStarted = false;\n        this._adSkipped = false;\n\n        /*** Local Functions ***/\n        function sanityCheck(adUnit, opts) {\n            if (!adUnit || !VPAIDAdUnitWrapper.checkVPAIDInterface(adUnit)) {\n                throw new VASTError('on VPAIDAdUnitWrapper, the passed VPAID adUnit does not fully implement the VPAID interface');\n            }\n\n            if (!isObject(opts)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper, expected options hash  but got '\" + opts + \"'\");\n            }\n\n            if (!(\"adCancelTimeout\" in opts) || !isNumber(opts.adCancelTimeout)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper, expected adCancelTimeout in options\");\n            }\n        }\n    }\n\n    VPAIDAdUnitWrapper.checkVPAIDInterface = function checkVPAIDInterface(VPAIDAdUnit) {\n        //NOTE: skipAd is not part of the method list because it only appears in VPAID 2.0 and we support VPAID 1.0\n        var VPAIDInterfaceMethods = [\n            'handshakeVersion', 'initAd', 'startAd', 'stopAd', 'resizeAd', 'pauseAd', 'expandAd', 'collapseAd'\n        ];\n\n        for (var i = 0, len = VPAIDInterfaceMethods.length; i < len; i++) {\n            if (!VPAIDAdUnit || !isFunction(VPAIDAdUnit[VPAIDInterfaceMethods[i]])) {\n                return false;\n            }\n        }\n\n\n        return canSubscribeToEvents(VPAIDAdUnit) && canUnsubscribeFromEvents(VPAIDAdUnit);\n\n        /*** Local Functions ***/\n\n        function canSubscribeToEvents(adUnit) {\n            return isFunction(adUnit.subscribe) || isFunction(adUnit.addEventListener) || isFunction(adUnit.on);\n        }\n\n        function canUnsubscribeFromEvents(adUnit) {\n            return isFunction(adUnit.unsubscribe) || isFunction(adUnit.removeEventListener) || isFunction(adUnit.off);\n\n        }\n    };\n\n    VPAIDAdUnitWrapper.prototype.adUnitAsyncCall = function() {\n        var args = arrayLikeObjToArray(arguments);\n        var method = args.shift();\n        var cb = args.pop();\n        var timeoutId;\n\n        sanityCheck(method, cb, this._adUnit);\n        args.push(wrapCallback());\n\n        this._adUnit[method].apply(this._adUnit, args);\n        timeoutId = setTimeout(function() {\n            timeoutId = null;\n            cb(new VASTError(\"on VPAIDAdUnitWrapper, timeout while waiting for a response on call '\" + method + \"'\"));\n            cb = noop;\n        }, this.options.adCancelTimeout);\n\n        /*** Local functions ***/\n        function sanityCheck(method, cb, adUnit) {\n            if (!isString(method) || !isFunction(adUnit[method])) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.adUnitAsyncCall, invalid method name\");\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.adUnitAsyncCall, missing callback\");\n            }\n        }\n\n        function wrapCallback() {\n            return function() {\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n                cb.apply(this, arguments);\n            };\n        }\n    };\n\n    VPAIDAdUnitWrapper.prototype.on = function(evtName, handler) {\n        var addEventListener = this._adUnit.addEventListener || this._adUnit.subscribe || this._adUnit.on;\n        addEventListener.call(this._adUnit, evtName, handler);\n    };\n\n    VPAIDAdUnitWrapper.prototype.off = function(evtName, handler) {\n        var removeEventListener = this._adUnit.removeEventListener || this._adUnit.unsubscribe || this._adUnit.off;\n        removeEventListener.call(this._adUnit, evtName, handler);\n    };\n\n    //minthe : waitForEvent\n    VPAIDAdUnitWrapper.prototype.waitForEvent = function(evtName, cb, context) {\n        var timeoutId;\n        sanityCheck(evtName, cb);\n        context = context || null;\n\n        this.on(evtName, responseListener);\n\n        timeoutId = setTimeout(function() {\n            cb(new VASTError(\"on VPAIDAdUnitWrapper.waitForEvent, timeout while waiting for event '\" + evtName + \"'\"));\n            timeoutId = null;\n            cb = noop;\n        }, this.options.adCancelTimeout);\n\n        /*** Local functions ***/\n        function sanityCheck(evtName, cb) {\n            if (!isString(evtName)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.waitForEvent, missing evt name\");\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.waitForEvent, missing callback\");\n            }\n        }\n\n        function responseListener() {\n            var args = arrayLikeObjToArray(arguments);\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n\n            args.unshift(null);\n            cb.apply(context, args);\n        }\n    };\n\n    // VPAID METHODS\n    VPAIDAdUnitWrapper.prototype.handshakeVersion = function(version, cb) {\n        this.adUnitAsyncCall('handshakeVersion', version, cb);\n    };\n\n    /* jshint maxparams:6 */\n    VPAIDAdUnitWrapper.prototype.initAd = function(width, height, viewMode, desiredBitrate, adUnitData, environmentVars, cb) {\n        //minthe : AdLoaded\n        logger.info('Calling VPAID initAd, time remaining =' + profile.getRemainingTime('initAd'));\n        this.waitForEvent('AdLoaded', cb);\n\n        //minthe VID-1580\n        this._adUnit.initAd(width, height, viewMode, desiredBitrate, adUnitData, environmentVars);\n\n    };\n\n    VPAIDAdUnitWrapper.prototype.resizeAd = function(width, height, viewMode, cb) {\n        // NOTE: AdSizeChange event is only supported on VPAID 2.0 so for the moment we are not going to use it\n        // and will assume that everything is fine after the async call\n        this.adUnitAsyncCall('resizeAd', width, height, viewMode, cb);\n    };\n\n    VPAIDAdUnitWrapper.prototype.startAd = function(cb) {\n        logger.info('Calling VPAID startAd, time remaining =' + profile.getRemainingTime('startAd'));\n        this.waitForEvent('AdStarted', cb);\n        this._adUnit.startAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.stopAd = function(cb) {\n        logger.info(' Calling VPAID stopAd');\n        this.waitForEvent('AdStopped', cb);\n        this._adUnit.stopAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.pauseAd = function(cb) {\n        if (this._adStopped || !this._adStarted) return;\n        logger.log(' Calling VPAID pauseAd');\n        this._adUnit.pauseAd();\n        timer.startKillTimeout(this._adUnit);\n    };\n\n    VPAIDAdUnitWrapper.prototype.resumeAd = function(cb) {\n        if (this._adStopped || !this._adStarted) return;\n        logger.log(' Calling VPAID resumeAd');\n        this.waitForEvent('AdPlaying', cb);\n        this._adUnit.resumeAd();\n        timer.startKillTimeout(this._adUnit);\n    };\n\n    VPAIDAdUnitWrapper.prototype.expandAd = function(cb) {\n        if (this._adStopped) return;\n        this.waitForEvent('AdExpandedChange', cb);\n        this._adUnit.expandAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.collapseAd = function(cb) {\n        if (this._adStopped) return;\n        this.waitForEvent('AdExpandedChange', cb);\n        this._adUnit.collapseAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.skipAd = function(cb) {\n        var skipAnyway = function() {\n            if(!this._adSkipped){\n                logger.debug('VPAID Creative has ' + ((this._adStopped) ? 'already stopped' : 'not responded with AdSkipped') + ': Forcing AdSkipped');\n                this._adSkipped = true;\n                this.player.trigger('vpaid.AdSkipped');\n            }\n        }\n\n        if (this._adStopped) {\n            // VIDLA-990 VPAID Ads that have already stopped should be skipped anyway (to support collapsing ad unit when disableCollapse is on)\n            skipAnyway.apply(this);\n            return;\n        }\n        logger.log('Calling VPAID skipAd');\n        if (cb) {\n            this.waitForEvent('AdSkipped', cb);\n        }\n        this._adUnit.skipAd();\n        //VIDLA-442 VPAID Ads that don't respond to skipAd should be skipped anyway\n        setTimeout(function() {\n            skipAnyway.apply(this);\n        }.bind(this), 500);\n    };\n\n    //VPAID property getters\n    [\n        'adLinear',\n        'adWidth',\n        'adHeight',\n        'adExpanded',\n        'adSkippableState',\n        'adRemainingTime',\n        'adDuration',\n        'adVolume',\n        'adCompanions',\n        'adIcons'\n    ].forEach(function(property) {\n        var getterName = 'get' + capitalize(property);\n\n        VPAIDAdUnitWrapper.prototype[getterName] = function(cb) {\n            this.adUnitAsyncCall(getterName, cb);\n        };\n    });\n\n    //VPAID property setters\n    VPAIDAdUnitWrapper.prototype.setAdVolume = function(volume, cb) {\n        if (this._adStopped) return;\n        logger.debug('Calling VPAID setAdVolume :: volume :' + volume);\n        this.adUnitAsyncCall('setAdVolume', volume, cb);\n    };\n\n    ;\n\n    function VPAIDFlashTech(mediaFile, settings) {\n        if (!(this instanceof VPAIDFlashTech)) {\n            return new VPAIDFlashTech(mediaFile);\n        }\n        sanityCheck(mediaFile);\n        this.name = 'vpaid-flash';\n        this.mediaFile = mediaFile;\n        this.containerEl = null;\n        this.vpaidFlashClient = null;\n        this.settings = settings;\n\n        /*** local functions ***/\n        function sanityCheck(mediaFile) {\n            if (!mediaFile || !isString(mediaFile.src)) {\n                throw new VASTError('on VPAIDFlashTech, invalid MediaFile');\n            }\n        }\n    }\n\n    VPAIDFlashTech.supports = function(type) {\n        return type === 'application/x-shockwave-flash' && VPAIDFLASHClient.isSupported();\n    };\n\n    VPAIDFlashTech.prototype.loadAdUnit = function loadFlashCreative(containerEl, objectEl, callback) {\n        var that = this;\n        var flashClientOpts = this.settings && this.settings.vpaidFlashLoaderPath ? { data: this.settings.vpaidFlashLoaderPath } : undefined;\n        sanityCheck(containerEl, callback);\n\n        this.containerEl = containerEl;\n        this.vpaidFlashClient = new VPAIDFLASHClient(containerEl, function(error) {\n            if (error) {\n                return callback(error);\n            }\n\n            that.vpaidFlashClient.loadAdUnit(that.mediaFile.src, callback);\n        }, flashClientOpts);\n\n        /*** Local Functions ***/\n        function sanityCheck(container, cb) {\n\n            if (!dom.isDomElement(container)) {\n                throw new VASTError('on VPAIDFlashTech.loadAdUnit, invalid dom container element');\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError('on VPAIDFlashTech.loadAdUnit, missing valid callback');\n            }\n        }\n    };\n\n    VPAIDFlashTech.prototype.unloadAdUnit = function() {\n        if (this.vpaidFlashClient) {\n            try {\n                this.vpaidFlashClient.destroy();\n            } catch (e) {\n                if (console && isFunction(console.log)) {\n                    console.log('VAST ERROR: trying to unload the VPAID adunit');\n                }\n            }\n            this.vpaidFlashClient = null;\n        }\n\n        if (this.containerEl) {\n            dom.remove(this.containerEl);\n            this.containerEl = null;\n        }\n    };\n\n    ;\n\n    function VPAIDHTML5Tech(mediaFile) {\n\n        if (!(this instanceof VPAIDHTML5Tech)) {\n            return new VPAIDHTML5Tech(mediaFile);\n        }\n\n        sanityCheck(mediaFile);\n\n        this.name = 'vpaid-html5';\n        this.containerEl = null;\n        this.videoEl = null;\n        this.vpaidHTMLClient = null;\n\n        this.mediaFile = mediaFile;\n\n        function sanityCheck(mediaFile) {\n            if (!mediaFile || !isString(mediaFile.src)) {\n                throw new VASTError(VPAIDHTML5Tech.INVALID_MEDIA_FILE);\n            }\n        }\n    }\n\n    VPAIDHTML5Tech.supports = function(type) {\n        return !isOldIE() && type === 'application/javascript';\n    };\n\n    VPAIDHTML5Tech.prototype.loadAdUnit = function loadAdUnit(containerEl, videoEl, callback) {\n        sanityCheck(containerEl, videoEl, callback);\n\n        this.containerEl = containerEl;\n        this.videoEl = videoEl;\n        this.vpaidHTMLClient = new VPAIDHTML5Client(containerEl, videoEl, {});\n        this.vpaidHTMLClient.loadAdUnit(this.mediaFile.src, callback);\n\n\n\n        function sanityCheck(container, video, cb) {\n            if (!dom.isDomElement(container)) {\n                throw new VASTError(VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL);\n            }\n\n            if (!dom.isDomElement(video) || video.tagName.toLowerCase() !== 'video') {\n                throw new VASTError(VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL);\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError(VPAIDHTML5Tech.MISSING_CALLBACK);\n            }\n        }\n    };\n\n    VPAIDHTML5Tech.prototype.unloadAdUnit = function unloadAdUnit() {\n        if (this.vpaidHTMLClient) {\n            try {\n                this.vpaidHTMLClient.destroy();\n            } catch (e) {\n                if (console && isFunction(console.log)) {\n                    console.log('VAST ERROR: trying to unload the VPAID adunit');\n                }\n            }\n\n            this.vpaidHTMLClient = null;\n        }\n\n        if (this.containerEl) {\n            dom.remove(this.containerEl);\n            this.containerEl = null;\n        }\n    };\n\n    var PREFIX = 'on VPAIDHTML5Tech';\n    VPAIDHTML5Tech.INVALID_MEDIA_FILE = PREFIX + ', invalid MediaFile';\n    VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL = PREFIX + ', invalid container HtmlElement';\n    VPAIDHTML5Tech.INVALID_DOM_VIDEO_EL = PREFIX + ', invalid HTMLVideoElement';\n    VPAIDHTML5Tech.MISSING_CALLBACK = PREFIX + ', missing valid callback';\n\n\n    ;\n\n    function VPAIDIntegrator(player, settings) {\n        if (!(this instanceof VPAIDIntegrator)) {\n            return new VPAIDIntegrator(player);\n        }\n\n        this.VIEW_MODE = {\n            NORMAL: 'normal',\n            FULLSCREEN: \"fullscreen\",\n            THUMBNAIL: \"thumbnail\"\n        };\n        this.player = player;\n        this.containerEl = createVPAIDContainerEl(player);\n        this.options = {\n            adCancelTimeout: 5000,\n            VPAID_VERSION: '2.0'\n        };\n        this.settings = settings;\n        this.volume = 1;\n        this.initVolume = 1;\n        if (this.settings.initialAudio === 'off') {\n            logger.log(\"Initial audio off\");\n            this.initVolume = 0;\n        }\n        this.initAdUnitCalled = false;\n        this.initialisedAdUnit = null;\n        this.initAdTimeout = false;\n        /*** Local functions ***/\n\n        function createVPAIDContainerEl() {\n            var containerEl = document.createElement('div');\n            dom.addClass(containerEl, 'VPAID-container');\n            player.el().insertBefore(containerEl, player.controlBar.el());\n            return containerEl;\n\n        }\n        this.EVENTS = [\n            'AdLoaded', 'AdStarted', 'AdStopped', 'AdSkipped', 'AdSkippableStateChange',\n            'AdSizeChange', 'AdLinearChange', 'AdDurationChange', 'AdExpandedChange',\n            'AdRemainingTimeChange', 'AdVolumeChange', 'AdImpression', 'AdVideoStart',\n            'AdVideoFirstQuartile', 'AdVideoMidpoint', 'AdVideoThirdQuartile',\n            'AdVideoComplete', 'AdClickThru', 'AdInteraction', 'AdUserAcceptInvitation',\n            'AdUserMinimize', 'AdUserClose', 'AdPaused', 'AdPlaying', 'AdLog', 'AdError'\n        ];\n    }\n\n    //List of supported VPAID technologies\n    VPAIDIntegrator.techs = [\n        VPAIDFlashTech,\n        VPAIDHTML5Tech\n    ];\n\n    //minthe : protoype.playAd\n    VPAIDIntegrator.prototype.playAd = function playVPaidAd(vastResponse, callback, isTestPlay) {\n        //flag to sperate logic for checking vpaid ad is valid\n        isTestPlay = (isTestPlay && isTestPlay !== undefined ? isTestPlay : false);\n\n        var that = this;\n        var tech;\n        var player = this.player;\n\n        callback = callback || noop;\n        if (!(vastResponse instanceof VASTResponse)) {\n            return callback(new VASTError('on VASTIntegrator.playAd, missing required VASTResponse'));\n        }\n\n        tech = this._findSupportedTech(vastResponse, this.settings);\n        dom.addClass(player.el(), 'vjs-vpaid-ad');\n\n        player.on('vast.adsCancel', triggerVpaidAdEnd);\n        player.one('vpaid.adEnd', function() {\n            player.off('vast.adsCancel', triggerVpaidAdEnd);\n            removeAdUnit();\n        });\n\n        if (tech) {\n\n            //if it's test-play this routine will invoke initAd and return result to notify the creative is ready to go\n            if (isTestPlay) {\n                async.waterfall([\n                    function(next) {\n                        next(null, tech, vastResponse);\n                    },\n                    this._loadAdUnit.bind(this),\n                    this._initAdUnit.bind(this)\n                ], function(error, adUnit, vastResponse) {\n                    if (error) {\n                        that._trackError(vastResponse);\n                    } else {\n                        player.trigger('an.readytogovpaid');\n                    }\n                    callback(error, vastResponse);\n                });\n            } else {\n                var errorCallback = function(error, adUnit, vastResponse) {\n                    if (error) {\n                        that._trackError(vastResponse);\n                    }\n                    player.trigger('vpaid.adEnd');\n                    callback(error, vastResponse);\n                };\n                var taskList = [\n                    function(next) {\n                        next(null, that.initialisedAdUnit, vastResponse, true);\n                    },\n                    this._playAdUnit.bind(this)\n                ];\n                if (this.initialisedAdUnit) {\n                    async.waterfall(taskList, errorCallback);\n                } else {\n                    if (this.initAdUnitCalled) {\n                        player.one(\"an.readytogovpaid\", function() {\n                            async.waterfall(taskList, errorCallback);\n                        });\n                    } else {\n                        async.waterfall([\n                            function(next) {\n                                next(null, tech, vastResponse);\n                            },\n                            this._loadAdUnit.bind(this),\n                            this._initAdUnit.bind(this),\n                            this._playAdUnit.bind(this)\n                        ], errorCallback);\n                    }\n                }\n            }\n\n            this._adUnit = {\n                _paused: true,\n                type: 'VPAID',\n                pauseAd: function() {\n                    player.trigger('vpaid.pauseAd');\n                    // VIDLA-1327-1329 Reverting back the pause which caused the regression.\n                    player.pause(true);\n                },\n                resumeAd: function() {\n                    player.trigger('vpaid.resumeAd');\n                },\n                isPaused: function() {\n                    return that.player.paused(true);\n                },\n                getSrc: function() {\n                    return tech.mediaFile;\n                }\n            };\n\n            return this._adUnit;\n        }\n\n        callback(new VASTError('on VPAIDIntegrator.playAd, could not find a supported mediaFile'));\n\n        return null;\n        /*** Local functions ***/\n        function triggerVpaidAdEnd() {\n            player.trigger('vpaid.adEnd');\n        }\n\n        function removeAdUnit() {\n            if (tech) {\n                tech.unloadAdUnit();\n            }\n            dom.removeClass(player.el(), 'vjs-vpaid-ad');\n        }\n    };\n\n    VPAIDIntegrator.prototype._findSupportedTech = function(vastResponse, settings) {\n        if (!(vastResponse instanceof VASTResponse)) {\n            return null;\n        }\n\n        var vpaidMediaFiles = vastResponse.mediaFiles.filter(vastUtil.isVPAID);\n        var i, len, mediaFile, VPAIDTech;\n\n        for (i = 0, len = vpaidMediaFiles.length; i < len; i += 1) {\n            mediaFile = vpaidMediaFiles[i];\n            VPAIDTech = findSupportedTech(mediaFile);\n            if (VPAIDTech) {\n                return new VPAIDTech(mediaFile, settings);\n            }\n        }\n\n        return null;\n\n        /*** Local functions ***/\n        function findSupportedTech(mediafile) {\n            var type = mediafile.type;\n            var i, len, VPAIDTech;\n\n            for (i = 0, len = VPAIDIntegrator.techs.length; i < len; i += 1) {\n                VPAIDTech = VPAIDIntegrator.techs[i];\n                if (VPAIDTech.supports(type)) {\n                    return VPAIDTech;\n                }\n            }\n            return null;\n        }\n    };\n\n    //minthe : loadAdUnit\n    VPAIDIntegrator.prototype._loadAdUnit = function(tech, vastResponse, next) {\n        if (this.initAdUnitCalled) {\n            return;\n        }\n        var player = this.player;\n        var vjsTechEl = player.el().querySelector('.vjs-tech');\n        var adCancelTimeout = this.settings.adCancelTimeout || this.options.adCancelTimeout;\n        var overlayPlayer = this.settings.overlayPlayer;\n        var initialPlayback = this.settings.initialPlayback;\n        var controlBarPosition = this.settings.controlBarPosition;\n        tech.loadAdUnit(this.containerEl, vjsTechEl, function(error, adUnit) {\n            if (error) {\n                return next(error, adUnit, vastResponse);\n            }\n\n            try {\n                var WrappedAdUnit = new VPAIDAdUnitWrapper(adUnit, { src: tech.mediaFile.src, adCancelTimeout: adCancelTimeout, overlayPlayer: overlayPlayer, initialPlayback: initialPlayback, controlBarPosition: controlBarPosition });\n                WrappedAdUnit.player = player;\n                var techClass = 'vjs-' + tech.name + '-ad';\n                dom.addClass(player.el(), techClass);\n                player.one('vpaid.adEnd', function() {\n                    dom.removeClass(player.el(), techClass);\n                });\n                //Entry point for player's skip button which trigger 'skip' event;\n                player.on('skip', function() {\n                    WrappedAdUnit.skipAd();\n                });\n                next(null, WrappedAdUnit, vastResponse);\n            } catch (e) {\n                next(e, adUnit, vastResponse);\n            }\n        });\n    };\n\n\n    //minthe : _testAdUnit\n    VPAIDIntegrator.prototype._initAdUnit = function(adUnit, vastResponse, callback) {\n        if (this.initAdUnitCalled) {\n            return;\n        }\n        this.initAdUnitCalled = true;\n        async.waterfall([\n            function(next) {\n                next(null, adUnit, vastResponse);\n            },\n            this._handshake.bind(this),\n            this._setupEvents.bind(this),\n            this._initAd.bind(this)\n        ], callback);\n    };\n\n    //minthe : _playAdUnit\n    VPAIDIntegrator.prototype._playAdUnit = function(adUnit, vastResponse, callback) {\n        async.waterfall([\n            function(next) {\n                next(null, adUnit, vastResponse);\n            },\n            this._linkPlayerControls.bind(this),\n            this._startAd.bind(this)\n        ], callback);\n    };\n\n    VPAIDIntegrator.prototype._handshake = function handshake(adUnit, vastResponse, next) {\n        adUnit.handshakeVersion(this.options.VPAID_VERSION, function(error, version) {\n            if (error) {\n                return next(error, adUnit, vastResponse);\n            }\n\n            if (version && isSupportedVersion(version)) {\n                return next(null, adUnit, vastResponse);\n            }\n\n            return next(new VASTError('on VPAIDIntegrator._handshake, unsupported version \"' + version + '\"'), adUnit, vastResponse);\n        });\n\n        function isSupportedVersion(version) {\n            var majorNum = major(version);\n            return majorNum >= 1 && majorNum <= 2;\n        }\n\n        function major(version) {\n            var parts = version.split('.');\n            return parseInt(parts[0], 10);\n        }\n    };\n\n    //minthe : _initAd\n    VPAIDIntegrator.prototype._initAd = function(adUnit, vastResponse, next) {\n        var self = this;\n        var tech = this.player.el().querySelector('.vjs-tech');\n        var dimension = dom.getDimension(tech);\n        // Reset the timeout flag\n        self.initAdTimeout = false;\n\n        timer.startInitAdTimeout(function(error) {\n            self.initAdTimeout = true;\n            self._reportTimeout(adUnit, error);\n        });\n        /*\n        adUnit.initAd(dimension.width, dimension.height, this.VIEW_MODE.NORMAL, -1, {AdParameters: vastResponse.adParameters || ''}, function (error) {\n            self.initialisedAdUnit = adUnit;\n            next(error, adUnit, vastResponse);\n        });\n        */\n\n        adUnit.initAd(dimension.width, dimension.height, this.VIEW_MODE.NORMAL, -1, { AdParameters: vastResponse.adParameters || '' }, self.settings.vpaidEnvironmentVars, function(error) {\n            self.initialisedAdUnit = adUnit;\n            next(error, adUnit, vastResponse);\n        });\n    };\n\n    VPAIDIntegrator.prototype._setupEvents = function(adUnit, vastResponse, next) {\n        var adUnitSrc = adUnit.options.src;\n        var tracker = new VASTTracker(adUnitSrc, vastResponse);\n        var player = this.player;\n        var that = this;\n\n        function setupEventCallbacks() {\n            var cb = that.settings.vpaidEventCallback;\n            if (!cb) return;\n            that.EVENTS.forEach(function(event) {\n                adUnit.on(event, function(data) {\n                    cb.call(this, event, data);\n                });\n            });\n        };\n\n        setupEventCallbacks();\n\n        adUnit.on('AdLoaded', function() {\n            adUnit._adLoaded = true;\n            timer.stopInitAdTimeout();\n            logger.info('VPAID event received :: AdLoaded, time = ' + profile.getInitTime() + ', time remaining = ' + profile.getRemainingTime('AdLoaded'));\n        });\n\n        //minthe2 AdStarted Handler\n        //fix for VID-1525\n        adUnit.on('AdStarted', function() {\n\n            adUnit._adStarted = true;\n            profile.adStartedTimestamp = new Date().getTime();\n\n            if (that.settings.delayExpandUntilVPAIDImpression) {\n                if (profile.adImpressionTimestamp !== 0 && profile.adStartedTimestamp !== 0) {\n                    timer.stopStartAdTimeout();\n                }\n            } else {\n                timer.stopStartAdTimeout();\n            }\n\n            // if (profile.adImpressionTimestamp !== 0) {//if AdImpression is deliverd without AdStarted\n            //     profile.adLoadedTimestamp = profile.adImpressionTimestamp;\n            // }\n\n\n            if (!adUnit._adLoaded) {\n                var remainingTime = profile.timeout - (profile.adStartedTimestamp - profile.initAdTimestamp);\n                logger.info('VPAID event received :: AdStarted, time = ' + 0 + ', time remaining = ' + remainingTime + ', Out of order AdStarted');\n            } else {\n                if (that.settings.delayExpandUntilVPAIDImpression && profile.adImpressionTimestamp === 0) {\n                    logger.info('VPAID event received :: AdStarted');\n                } else {\n                    logger.info('VPAID event received :: AdStarted, time = ' + profile.getStartTime() + ', total time = ' + profile.getTotalTime() + ', time remaining = ' + profile.getRemainingTime('AdStarted'));\n                }\n            }\n            player.trigger('vpaid.AdStarted');\n            tracker.trackCreativeView();\n            notifyPlayToPlayer();\n\n\n            //activate impression timer if it's not already started\n            if (that.settings.delayExpandUntilVPAIDImpression && profile.adImpressionTimestamp === 0) {\n                profile.adImpressionTimestamp = new Date().getTime();\n                // timer.startAdImpressionTimeout(function (error) {\n                //     that._reportTimeout(adUnit, error);\n                // });\n            }\n            if (isAndroid()) {\n                ChiveFacebookHack();\n            }\n        });\n\n        // For creatives that do not use the video tag provided by the player.\n        function handleAdPlayPause() {\n            // Ad creatives do not creative their own video tags on devices so no need to handle AdProgess timer\n            // TODO : find  more reliable way to figure out the video src set.\n            if (isIDevice() || isAndroid()) {\n            \t// VIDLA-421 (do not ignore pause/resume event handlers for overlay player)\n            \tif (!adUnit.options.overlayPlayer) {\n                    return;\n            \t}\n            }\n\n            // Ad uses video JS Slot\n            if (isVideoSlotUsed()) {\n                return;\n            }\n            var creative = adUnit._adUnit ? adUnit._adUnit._creative : null;\n\n            if (adUnit.options.overlayPlayer) {\n                // since no monkeypatch api is activated.\n                player.on('pause', function() {\n                    if (adUnit._adUnit && creative) {\n                        that._adUnit.pauseAd();\n                    }\n                });\n                player.on('play', function() {\n                    if (adUnit._adUnit && creative) {\n                        that._adUnit.resumeAd();\n                    }\n                });\n            }\n\n            //IE11 has an issue to not listen this pause event - VID-2405, VID-2406\n            //video.js has their own event pooling sytem for video element and parent div of video element, the \"pause event\" area is so crowded for now - when vpaid player injects \"pause\" listener to player object on IE11, the video.js doesn't handle as well. looks like incorrect GUID setting problem in order to get events unique\n            //for handling this vpaid-creative.pause by \"pause\" signal from video.js we don't have to stick with the crowded \"pause\" signal. we can do samething with differnet signal for this\n            // player.on('pause', function(){\n            //     if(creative){\n            //         that._adUnit.pauseAd();\n            //     }\n            // });\n            player.on('apn-vpaid-pause', function() { //this \"apn-vpaid-pause\" will be dispatch from video.js pause.\n                if (creative) {\n                    // that._adUnit.pauseAd();//no need to dispatch pause again to video.js because video.js already dispatch pause before triggered \"apn-vpaid-pause\". this will also cover a case showing pause button on the UI\n                    player.trigger('vpaid.pauseAd'); //vpaid video pause\n                }\n            });\n        };\n\n        // For creatives that do not use the video tag provided by the player.\n        function handleAdProgress() {\n\n            // Ad creatives do not creative their own video tags on devices so no need to handle AdProgess timer\n            // TODO : find  more reliable way to figure out the video src set.\n            //if(isIDevice() || isAndroid()){\n            if (isIDevice()) { //for VID-2597\n                return;\n            }\n\n            // Ad uses video JS Slot\n            if (isVideoSlotUsed()) {\n                return;\n            }\n\n            // Ad is using its own Video slot.\n            var creative = adUnit._adUnit._creative;\n            var remainingTimeUnknown = false;\n\n            function updateProgress() {\n                var duration = creative.getAdDuration ? creative.getAdDuration() : 0;\n                var remainingTime = creative.getAdRemainingTime ? creative.getAdRemainingTime() : -1;\n                remainingTime = (remainingTime > duration) ? duration : remainingTime;//fix VIDLA-429\n                var currentTime = duration - remainingTime;\n\n                switch (remainingTime) {\n                    case -2:\n                        // If time is not currently known\n                        remainingTimeUnknown = true;\n                        player.controlBar.currentTimeDisplay.hide();\n                        player.controlBar.timeDivider.hide();\n                        player.controlBar.durationDisplay.hide();\n                        break;\n                    case -1:\n                        // If time is not implemeneted\n                        clearInterval(progressHandler);\n                        player.controlBar.currentTimeDisplay.hide();\n                        player.controlBar.timeDivider.hide();\n                        player.controlBar.durationDisplay.hide();\n                        break;\n                    case 0:\n                        clearInterval(progressHandler);\n                        break;\n                    default:\n                        if (remainingTimeUnknown) {\n                            remainingTimeUnknown = false;\n                            player.controlBar.currentTimeDisplay.show();\n                            player.controlBar.timeDivider.show();\n                            player.controlBar.durationDisplay.show();\n                        }\n                        player.currentTime(currentTime);\n                        player.controlBar.currentTimeDisplay.updateContent();\n                        player.duration(duration);\n                        player.controlBar.durationDisplay.updateContent();\n                        break;\n                }\n            }\n            var progressHandler = setInterval(updateProgress, 200);\n            updateProgress();\n        }\n\n        adUnit.on('AdSkipped', function() {\n            logger.log('VPAID event received :: AdSkipped');\n            if(!adUnit._adSkipped) {\n                adUnit._adSkipped = true;\n                player.trigger('vpaid.AdSkipped');\n                tracker.trackSkip();\n            }\n        });\n\n\n        //minthe2 AdImpression Handler\n        adUnit.on('AdImpression', function() {\n\n            profile.adImpressionTimestamp = new Date().getTime();\n\n\n            if (that.settings.delayExpandUntilVPAIDImpression) {\n                if (profile.adImpressionTimestamp !== 0 && profile.adStartedTimestamp !== 0) {\n                    timer.stopStartAdTimeout();\n                }\n            }\n\n            // if (profile.adImpressionTimestamp !== 0) {//if AdImpression is deliverd without AdStarted\n            //     profile.adLoadedTimestamp = profile.adImpressionTimestamp;\n            // }\n            // if (profile.adStartedTimestamp === 0) {//if AdImpression is deliverd without AdStarted\n            //     profile.adStartedTimestamp = profile.adLoadedTimestamp;\n            // }\n\n            if (that.settings.delayExpandUntilVPAIDImpression && profile.adStartedTimestamp === 0) {\n                logger.info('VPAID event received :: AdImpression');\n            } else {\n                logger.info('VPAID event received :: AdImpression, time = ' + profile.getAdImpressionTime() + ', total time = ' + profile.getTotalTime() + ', time remaining = ' + profile.getRemainingTime('AdImpression'));\n            }\n\n\n            player.trigger('vpaid.AdImpression');\n            tracker.trackImpressions();\n            if(adUnit._adUnit && adUnit._adUnit._creative){\n                var creative = adUnit._adUnit._creative;\n                var creativeIcons = false;\n                if(creative.getAdIcons){\n                    creativeIcons = creative.getAdIcons();\n                }\n                player.trigger({type: 'vpaid.AdIcons', adIcons: creativeIcons});\n            }\n        });\n\n        adUnit.on('AdVideoStart', function() {\n            logger.info('VPAID event received :: AdVideoStart');\n\n            // VIDLA-441 This is definitely when the Ad video has started and all the metadata is ready. AdStarted event may be too early\n            handleAdPlayPause();\n            handleAdProgress();\n\n            player.trigger('vpaid.AdVideoStart');\n            tracker.trackStart();\n            notifyPlayToPlayer();\n            if (that.settings.initialAudio === 'off') {\n                player.muted(true);\n            } else {\n                player.muted(false);\n            }\n            linkVolumeControl();\n\n            //resizeAd(player, adUnit, that.VIEW_MODE);\n\n            //VIDLA-2143\n            //to figure out specific creative issue which has 1px of height after AdVideoStart\n            //details here: https://stash.corp.appnexus.com/projects/VIDEO/repos/resources_video-ad-video-player-html5-plugin-vpaid/pull-requests/14/overview\n            resizeAd(player, adUnit, that.VIEW_MODE, true);\n\n            if (isIDevice()) {\n                ChiveFacebookHack();\n            }\n        });\n\n        // VID-3052 This is a temporary hack for FB creative autoplay on chive pages. Please see ticket for details.\n        function ChiveFacebookHack() {\n            var videoSlot = adUnit._adUnit._videoEl;\n            if (adUnit.options.overlayPlayer && adUnit.options.initialPlayback === 'auto' && videoSlot.paused) {\n                setTimeout(function() {\n                    // Overlay Chive hack for Facebook Creative\n                    logger.log('Applying Facebook Chive Hack');\n                    player.muted(true);\n                    that._adUnit.resumeAd();\n                }, 1000);\n            }\n        };\n\n        adUnit.on('AdPlaying', function() {\n            logger.log('VPAID event received :: AdPlaying');\n            timer.stopKillTimeout();\n            player.trigger('vpaid.AdPlaying');\n            tracker.trackResume();\n            notifyPlayToPlayer();\n        });\n\n        adUnit.on('AdPaused', function() {\n            logger.log('VPAID event received :: AdPaused');\n            timer.stopKillTimeout();\n            player.trigger('vpaid.AdPaused');\n            tracker.trackPause();\n            notifyPauseToPlayer();\n        });\n\n        function notifyPlayToPlayer() {\n            if (that._adUnit && that._adUnit.isPaused()) {\n                that._adUnit._paused = false;\n            }\n            player.trigger('play');\n\n        }\n\n        function notifyPauseToPlayer() {\n            if (that._adUnit) {\n                that._adUnit._paused = true;\n            }\n            player.trigger('pause');\n        }\n\n        adUnit.on('AdVideoFirstQuartile', function() {\n            logger.info('VPAID event received :: AdVideoFirstQuartile');\n            player.trigger('vpaid.AdVideoFirstQuartile');\n            tracker.trackFirstQuartile();\n        });\n\n        adUnit.on('AdVideoMidpoint', function() {\n            logger.info('VPAID event received :: AdVideoMidpoint');\n            player.trigger('vpaid.AdVideoMidpoint');\n            tracker.trackMidpoint();\n        });\n\n        adUnit.on('AdVideoThirdQuartile', function() {\n            logger.info('VPAID event received :: AdVideoThirdQuartile');\n            player.trigger('vpaid.AdVideoThirdQuartile');\n            tracker.trackThirdQuartile();\n        });\n\n        adUnit.on('AdVideoComplete', function() {\n            logger.info('VPAID event received :: AdVideoComplete');\n            player.trigger('vpaid.AdVideoComplete');\n            tracker.trackComplete();\n        });\n\n        adUnit.on('AdClickThru', function(data) {\n            player.trigger('vpaid.AdClickThru');\n        });\n\n        adUnit.on('AdUserAcceptInvitation', function() {\n            player.trigger('vpaid.AdUserAcceptInvitation');\n            tracker.trackAcceptInvitation();\n            tracker.trackAcceptInvitationLinear();\n        });\n\n        adUnit.on('AdUserClose', function() {\n            player.trigger('vpaid.AdUserClose');\n            tracker.trackClose();\n            tracker.trackCloseLinear();\n        });\n\n        adUnit.on('AdUserMinimize', function() {\n            player.trigger('vpaid.AdUserMinimize');\n            tracker.trackCollapse();\n        });\n\n        adUnit.on('AdError', function(message) {\n            timer.stopAdTimeouts();\n            logger.error('VPAID event received :: AdError : message : ' + message);\n            //player.trigger('vast.adError');//TODO jeff's change for VID-583\n            player.trigger('vpaid.AdError');\n            //NOTE: we track errors code 901, as noted in VAST 3.0\n            tracker.trackErrorWithCode(901);\n        });\n\n        adUnit.on('AdVolumeChange', function() {\n            logger.debug('VPAID event received :: AdVolumeChange');\n            player.trigger('vpaid.AdVolumeChange');\n        });\n\n        adUnit.on('AdStopped', function() {\n            logger.info('VPAID event received :: AdStopped');\n            adUnit._adStopped = true;\n            player.trigger('vpaid.AdStopped');\n        });\n\n        var updateViewSize = resizeAd.bind(this, player, adUnit, this.VIEW_MODE);\n        var autoResize = this.settings.autoResize;\n\n        if (autoResize) {\n            dom.addEventListener(window, 'resize', updateViewSize);\n            dom.addEventListener(window, 'orientationchange', updateViewSize);\n        }\n\n        player.on('vast.resize', updateViewSize);\n        player.on('vpaid.pauseAd', pauseAdUnit);\n        player.on('vpaid.resumeAd', resumeAdUnit);\n\n        player.one('vpaid.adEnd', function() {\n            player.off('vast.resize', updateViewSize);\n            player.off('vpaid.pauseAd', pauseAdUnit);\n            player.off('vpaid.resumeAd', resumeAdUnit);\n\n            if (autoResize) {\n                dom.removeEventListener(window, 'resize', updateViewSize);\n                dom.removeEventListener(window, 'orientationchange', updateViewSize);\n            }\n        });\n\n        next(null, adUnit, vastResponse);\n\n        /*** Local Functions ***/\n        function pauseAdUnit() {\n            adUnit.pauseAd(noop);\n        }\n\n        function resumeAdUnit() {\n            adUnit.resumeAd(noop);\n        }\n\n        function isVideoSlotUsed() {\n            var videoSlot = adUnit._adUnit._videoEl;\n            var creative = adUnit._adUnit._creative;\n\n            // Ad uses video JS Slot\n            if (!creative || !videoSlot || videoSlot.src) {\n                return true;\n            }\n            return false;\n        }\n\n        function linkVolumeControl() {\n            // Ad uses video JS slot. Volume be controlled via Player Framework\n            if (isVideoSlotUsed()) {\n                return;\n            }\n            // for creatives that create own tag set initial volume appropriately\n            adUnit.setAdVolume(that.initVolume, function(error, result) {\n                if (error) {\n                    logger.log('The volume change is not implemented as part of the ad unit');\n                } else {\n                    logger.debug('The volume change is implemented as part of the ad unit');\n                }\n            });\n            // Ad is using its own Video slot. Volume be controlled by setAdVolume\n            player.on('volumechange', updateAdUnitVolume);\n\n            player.one('vpaid.adEnd', function() {\n                player.off('volumechange', updateAdUnitVolume);\n            });\n\n            /*** local functions ***/\n            function updateAdUnitVolume() {\n                var vol;\n                if (player.muted()) {\n                    vol = 0;\n                } else {\n                    that.volume = player.volume() ? player.volume() : that.volume;\n                    vol = that.volume;\n                }\n                adUnit.setAdVolume(vol, logError);\n            }\n        }\n    };\n\n    VPAIDIntegrator.prototype._linkPlayerControls = function(adUnit, vastResponse, next) {\n        var that = this;\n        linkFullScreenControl(this.player, adUnit, this.VIEW_MODE);\n\n        next(null, adUnit, vastResponse);\n\n        /*** Local functions ***/\n\n        function linkFullScreenControl(player, adUnit, VIEW_MODE) {\n            var updateViewSize = resizeAd.bind(this, player, adUnit, VIEW_MODE);\n\n            player.on('fullscreenchange', updateViewSize);\n\n            player.one('vpaid.adEnd', function() {\n                player.off('fullscreenchange', updateViewSize);\n            });\n        }\n    };\n\n    //minthe : _startAd\n    VPAIDIntegrator.prototype._startAd = function(adUnit, vastResponse, next) {\n        var self = this;\n        var player = this.player;\n\n        if (self.initAdTimeout) {\n            return;\n        }\n        // VIDLA-245 IAS hack: If AdStarted is received before calling startAd then do not cap it with a timer.\n        if (!adUnit._adStarted) {\n            timer.startStartAdTimeout(function(error) {\n                self._reportTimeout(adUnit, error);\n            });\n        } else {\n            //Just set the timestamp correctly for VIDLA-245\n            profile.startAdTimestamp = new Date().getTime();\n        }\n        adUnit.startAd(function(error) {\n            if (!error) {\n                player.trigger('vast.adStart');\n            }\n        });\n    };\n\n\n    VPAIDIntegrator.prototype._trackError = function trackError(response) {\n        vastUtil.track(response.errorURLMacros, { ERRORCODE: 901 });\n    };\n\n    VPAIDIntegrator.prototype._reportTimeout = function(adUnit, error) {\n        var player = this.player;\n        player.trigger({ type: 'vast.adTimeout', error: error });\n        try {\n            if (adUnit && adUnit._adUnit) {\n                logger.log(\"Calling VPAID stopAd on TIMEOUT\");\n                adUnit._adUnit.stopAd();\n            }\n        } catch (e) {\n            logger.log('VPAID error in calling stopAd on Timeout');\n        }\n    };\n\n    function resizeAd(player, adUnit, VIEW_MODE, isAdVideoStart) {\n        var tech = player.el().querySelector('.vjs-tech');\n        var dimension = dom.getDimension(tech);\n        var width = dimension.width;\n        var height = dimension.height;\n        var MODE = player.isFullscreen() ? VIEW_MODE.FULLSCREEN : VIEW_MODE.NORMAL;\n\n        var slot = adUnit._adUnit._el;\n        var videoSlot = adUnit._adUnit._videoEl;\n\n        var controlBar = player.controlBar;\n        var controlBarPosition = adUnit.options.controlBarPosition ? adUnit.options.controlBarPosition : \"over\";\n        var controlBarHeight = (controlBar && controlBarPosition === \"over\") ? controlBar.height() : 0;\n        if (controlBar && controlBarHeight) {\n            height = dimension.height - controlBarHeight;\n        }\n        //Resize both slot and video slot (Ads could use either or both)\n        if (slot && videoSlot) {\n            slot.style.height = height + 'px';\n            videoSlot.style.height = height + 'px';\n        }\n\n        //adUnit.resizeAd(width, height, MODE, logError);\n        \n        //VIDLA-2143\n        //To figure out specific creative issue which has 1px of height after AdVideoStart\n        //details here: https://stash.corp.appnexus.com/projects/VIDEO/repos/resources_video-ad-video-player-html5-plugin-vpaid/pull-requests/14/overview\n        if (isAdVideoStart && isAdVideoStart === true) {\n            adUnit.resizeAd(width + 1, height + 1, MODE, logError);\n            adUnit.resizeAd(width, height, MODE, logError);\n        } else {\n            adUnit.resizeAd(width, height, MODE, logError);\n        }\n    };\n\n    function logError(error) {\n        if (error) {\n            logger.log('ERROR: ' + error.message);\n        }\n    };\n\n    function Ad(adJTree) {\n        if (!(this instanceof Ad)) {\n            return new Ad(adJTree);\n        }\n\n        this.id = adJTree.attr('id');\n        this.sequence = adJTree.attr('sequence');\n\n        if (adJTree.inLine) {\n            this.inLine = new InLine(adJTree.inLine);\n        }\n\n        if (adJTree.wrapper) {\n            this.wrapper = new Wrapper(adJTree.wrapper);\n        }\n    };\n\n    function Creative(creativeJTree) {\n        if (!(this instanceof Creative)) {\n            return new Creative(creativeJTree);\n        }\n\n        this.id = creativeJTree.attr('id');\n        this.sequence = creativeJTree.attr('sequence');\n        this.adId = creativeJTree.attr('adId');\n        this.apiFramework = creativeJTree.attr('apiFramework');\n\n        if (creativeJTree.linear) {\n            this.linear = new Linear(creativeJTree.linear);\n        }\n    };\n\n    function InLine(inlineJTree) {\n        if (!(this instanceof InLine)) {\n            return new InLine(inlineJTree);\n        }\n\n        //Required Fields\n        this.adTitle = xml.keyValue(inlineJTree.adTitle);\n        this.adSystem = xml.keyValue(inlineJTree.adSystem);\n        this.impressions = vastUtil.parseImpressions(inlineJTree.impression);\n        this.creatives = vastUtil.parseCreatives(inlineJTree.creatives);\n\n        //Optional Fields\n        this.description = xml.keyValue(inlineJTree.description);\n        this.advertiser = xml.keyValue(inlineJTree.advertiser);\n        this.surveys = parseSurveys(inlineJTree.survey);\n        this.error = xml.keyValue(inlineJTree.error);\n        this.pricing = xml.keyValue(inlineJTree.pricing);\n        this.extensions = inlineJTree.extensions;\n\n        /*** Local Functions ***/\n        function parseSurveys(inlineSurveys) {\n            if (inlineSurveys) {\n                return transformArray(isArray(inlineSurveys) ? inlineSurveys : [inlineSurveys], function(survey) {\n                    if (isNotEmptyString(survey.keyValue)) {\n                        return {\n                            uri: survey.keyValue,\n                            type: survey.attr('type')\n                        };\n                    }\n\n                    return undefined;\n                });\n            }\n            return [];\n        }\n    };\n\n    function Linear(linearJTree) {\n        if (!(this instanceof Linear)) {\n            return new Linear(linearJTree);\n        }\n\n        //Required Elements\n        this.duration = vastUtil.parseDuration(xml.keyValue(linearJTree.duration));\n        this.mediaFiles = parseMediaFiles(linearJTree.mediaFiles && linearJTree.mediaFiles.mediaFile);\n\n        //Optional fields\n        this.trackingEvents = parseTrackingEvents(linearJTree.trackingEvents && linearJTree.trackingEvents.tracking, this.duration);\n        this.skipoffset = vastUtil.parseOffset(xml.attr(linearJTree, 'skipoffset'), this.duration);\n\n        if (linearJTree.videoClicks) {\n            this.videoClicks = new VideoClicks(linearJTree.videoClicks);\n        }\n\n        if (linearJTree.adParameters) {\n            this.adParameters = xml.keyValue(linearJTree.adParameters);\n\n            if (xml.attr(linearJTree.adParameters, 'xmlEncoded')) {\n                this.adParameters = xml.decode(this.adParameters);\n            }\n        }\n\n        /*** Local functions ***/\n        function parseTrackingEvents(trackingEvents, duration) {\n            var trackings = [];\n            if (isDefined(trackingEvents)) {\n                trackingEvents = isArray(trackingEvents) ? trackingEvents : [trackingEvents];\n                trackingEvents.forEach(function(trackingData) {\n                    trackings.push(new TrackingEvent(trackingData, duration));\n                });\n            }\n            return trackings;\n        }\n\n        function parseMediaFiles(mediaFilesJxonTree) {\n            var mediaFiles = [];\n            if (isDefined(mediaFilesJxonTree)) {\n                mediaFilesJxonTree = isArray(mediaFilesJxonTree) ? mediaFilesJxonTree : [mediaFilesJxonTree];\n\n                mediaFilesJxonTree.forEach(function(mfData) {\n                    mediaFiles.push(new MediaFile(mfData));\n                });\n            }\n            return mediaFiles;\n        }\n    };\n\n    function MediaFile(mediaFileJTree) {\n        if (!(this instanceof MediaFile)) {\n            return new MediaFile(mediaFileJTree);\n        }\n\n        //Required attributes\n        this.src = xml.keyValue(mediaFileJTree);\n        this.delivery = mediaFileJTree.attr('delivery');\n        this.type = mediaFileJTree.attr('type');\n        this.width = mediaFileJTree.attr('width');\n        this.height = mediaFileJTree.attr('height');\n\n        //Optional attributes\n        this.codec = mediaFileJTree.attr('codec');\n        this.id = mediaFileJTree.attr('id');\n        this.bitrate = mediaFileJTree.attr('bitrate');\n        this.minBitrate = mediaFileJTree.attr('minBitrate');\n        this.maxBitrate = mediaFileJTree.attr('maxBitrate');\n        this.scalable = mediaFileJTree.attr('scalable');\n        this.maintainAspectRatio = mediaFileJTree.attr('maintainAspectRatio');\n        this.apiFramework = mediaFileJTree.attr('apiFramework');\n    };\n\n    function TrackingEvent(trackingJTree, duration) {\n        if (!(this instanceof TrackingEvent)) {\n            return new TrackingEvent(trackingJTree, duration);\n        }\n\n        this.name = trackingJTree.attr('event');\n        this.uri = xml.keyValue(trackingJTree);\n\n        if ('progress' === this.name) {\n            this.offset = vastUtil.parseOffset(trackingJTree.attr('offset'), duration);\n        }\n    }\n\n    ;\n\n    //minthe : VASTClient initialize\n    function VASTClient(options) {\n\n        if (!(this instanceof VASTClient)) {\n            return new VASTClient(options);\n        }\n        var defaultOptions = {\n            WRAPPER_LIMIT: 5\n        };\n\n        options = options || {};\n        this.settings = extend({}, options, defaultOptions);\n        this.errorURLMacros = [];\n    }\n\n    VASTClient.prototype.getVASTResponse = function getVASTResponse(adTagUrl, callback) {\n        var that = this;\n\n        var error = sanityCheck(adTagUrl, callback);\n        if (error) {\n            if (isFunction(callback)) {\n                return callback(error);\n            }\n            throw error;\n        }\n\n        async.waterfall([\n                this._getVASTAd.bind(this, adTagUrl),\n                buildVASTResponse\n            ],\n            callback);\n\n        /*** Local functions ***/\n        function buildVASTResponse(adsChain, cb) {\n            try {\n                var response = that._buildVASTResponse(adsChain);\n                cb(null, response);\n            } catch (e) {\n                cb(e);\n            }\n        }\n\n        function sanityCheck(adTagUrl, cb) {\n            if (!adTagUrl) {\n                return new VASTError('on VASTClient.getVASTResponse, missing ad tag URL');\n            }\n\n            if (!isFunction(cb)) {\n                return new VASTError('on VASTClient.getVASTResponse, missing callback function');\n            }\n        }\n    };\n\n    VASTClient.prototype._getVASTAd = function(adTagUrl, callback) {\n        var that = this;\n\n        getAdWaterfall(adTagUrl, function(error, vastTree) {\n            var waterfallAds = vastTree && isArray(vastTree.ads) ? vastTree.ads : null;\n            if (error) {\n                that._trackError(error, waterfallAds);\n                return callback(error, waterfallAds);\n            }\n\n            getAd(waterfallAds.shift(), [], waterfallHandler);\n\n            /*** Local functions ***/\n            function waterfallHandler(error, adChain) {\n                if (error) {\n                    that._trackError(error, adChain);\n                    if (waterfallAds.length > 0) {\n                        getAd(waterfallAds.shift(), [], waterfallHandler);\n                    } else {\n                        callback(error, adChain);\n                    }\n                } else {\n                    callback(null, adChain);\n                }\n            }\n        });\n\n        /*** Local functions ***/\n        function getAdWaterfall(adTagUrl, callback) {\n            var requestVastXML = that._requestVASTXml.bind(that, adTagUrl);\n            async.waterfall([\n                requestVastXML,\n                buildVastWaterfall\n            ], callback);\n        }\n\n        function buildVastWaterfall(xmlStr, callback) {\n            var vastTree;\n            try {\n                vastTree = xml.toJXONTree(xmlStr);\n                vastTree.ads = isArray(vastTree.ad) ? vastTree.ad : [vastTree.ad];\n                callback(validateVASTTree(vastTree), vastTree);\n            } catch (e) {\n                callback(new VASTError(\"on VASTClient.getVASTAd.buildVastWaterfall, error parsing xml\", 100), null);\n            }\n        }\n\n        function validateVASTTree(vastTree) {\n            var vastVersion = xml.attr(vastTree, 'version');\n\n            if (!vastTree.ad) {\n                return new VASTError('on VASTClient.getVASTAd.validateVASTTree, no Ad in VAST tree', 303);\n            }\n\n            if (vastVersion && (vastVersion != 3 && vastVersion != 2)) {\n                return new VASTError('on VASTClient.getVASTAd.validateVASTTree, not supported VAST version \"' + vastVersion + '\"', 102);\n            }\n\n            return null;\n        }\n\n        function getAd(adTagUrl, adChain, callback) {\n            if (adChain.length >= that.WRAPPER_LIMIT) {\n                return callback(new VASTError(\"on VASTClient.getVASTAd.getAd, players wrapper limit reached (the limit is \" + that.WRAPPER_LIMIT + \")\", 302), adChain);\n            }\n\n            async.waterfall([\n                function(next) {\n                    if (isString(adTagUrl)) {\n                        requestVASTAd(adTagUrl, next);\n                    } else {\n                        next(null, adTagUrl);\n                    }\n                },\n                buildAd\n            ], function(error, ad) {\n                if (ad) {\n                    adChain.push(ad);\n                }\n\n                if (error) {\n                    return callback(error, adChain);\n                }\n\n                if (ad.wrapper) {\n                    return getAd(ad.wrapper.VASTAdTagURI, adChain, callback);\n                }\n\n                return callback(null, adChain);\n            });\n        }\n\n        function buildAd(adJxonTree, callback) {\n            try {\n                var ad = new Ad(adJxonTree);\n                callback(validateAd(ad), ad);\n            } catch (e) {\n                callback(new VASTError('on VASTClient.getVASTAd.buildAd, error parsing xml', 100), null);\n            }\n        }\n\n        function validateAd(ad) {\n            var wrapper = ad.wrapper;\n            var inLine = ad.inLine;\n            var errMsgPrefix = 'on VASTClient.getVASTAd.validateAd, ';\n\n            if (inLine && wrapper) {\n                return new VASTError(errMsgPrefix + \"InLine and Wrapper both found on the same Ad\", 101);\n            }\n\n            if (!inLine && !wrapper) {\n                return new VASTError(errMsgPrefix + \"nor wrapper nor inline elements found on the Ad\", 101);\n            }\n\n            if (inLine && inLine.creatives.length === 0) {\n                return new VASTError(errMsgPrefix + \"missing creative in InLine element\", 101);\n            }\n\n            if (wrapper && !wrapper.VASTAdTagURI) {\n                return new VASTError(errMsgPrefix + \"missing 'VASTAdTagURI' in wrapper\", 101);\n            }\n        }\n\n        function requestVASTAd(adTagUrl, callback) {\n            that._requestVASTXml(adTagUrl, function(error, xmlStr) {\n                if (error) {\n                    return callback(error);\n                }\n                try {\n                    var vastTree = xml.toJXONTree(xmlStr);\n                    callback(validateVASTTree(vastTree), vastTree.ad);\n                } catch (e) {\n                    callback(new VASTError(\"on VASTClient.getVASTAd.requestVASTAd, error parsing xml\", 100));\n                }\n            });\n        }\n    };\n\n    VASTClient.prototype._requestVASTXml = function requestVASTXml(adTagUrl, callback) {\n        try {\n            if (isFunction(adTagUrl)) {\n                adTagUrl(requestHandler);\n            } else {\n                http.get(adTagUrl, requestHandler, {\n                    withCredentials: true\n                });\n            }\n        } catch (e) {\n            callback(e);\n        }\n\n        /*** Local functions ***/\n        function requestHandler(error, response, status) {\n            if (error) {\n                var errMsg = isDefined(status) ?\n                    \"on VASTClient.requestVastXML, HTTP request error with status '\" + status + \"'\" :\n                    \"on VASTClient.requestVastXML, Error getting the the VAST XML with he passed adTagXML fn\";\n                return callback(new VASTError(errMsg, 301), null);\n            }\n\n            callback(null, response);\n        }\n    };\n\n    VASTClient.prototype._buildVASTResponse = function buildVASTResponse(adsChain) {\n        var response = new VASTResponse();\n        addAdsToResponse(response, adsChain);\n        validateResponse(response);\n\n        return response;\n\n        //*** Local function ****\n        function addAdsToResponse(response, ads) {\n            ads.forEach(function(ad) {\n                response.addAd(ad);\n            });\n        }\n\n        function validateResponse(response) {\n            var progressEvents = response.trackingEvents.progress;\n\n            if (!response.hasLinear()) {\n                throw new VASTError(\"on VASTClient._buildVASTResponse, Received an Ad type that is not supported\", 200);\n            }\n\n            if (response.duration === undefined) {\n                throw new VASTError(\"on VASTClient._buildVASTResponse, Missing duration field in VAST response\", 101);\n            }\n\n            if (progressEvents) {\n                progressEvents.forEach(function(progressEvent) {\n                    if (!isNumber(progressEvent.offset)) {\n                        throw new VASTError(\"on VASTClient._buildVASTResponse, missing or wrong offset attribute on progress tracking event\", 101);\n                    }\n                });\n            }\n        }\n    };\n\n    VASTClient.prototype._trackError = function(error, adChain) {\n        if (!isArray(adChain) || adChain.length === 0) { //There is nothing to track\n            return;\n        }\n\n        var errorURLMacros = [];\n        adChain.forEach(addErrorUrlMacros);\n        vastUtil.track(errorURLMacros, { ERRORCODE: error.code || 900 }); //900 <== Undefined error\n\n        /*** Local functions  ***/\n        function addErrorUrlMacros(ad) {\n            if (ad.wrapper && ad.wrapper.error) {\n                errorURLMacros.push(ad.wrapper.error);\n            }\n\n            if (ad.inLine && ad.inLine.error) {\n                errorURLMacros.push(ad.inLine.error);\n            }\n        }\n    };\n\n    ;\n    var VAST = {};\n\n    function VASTError(message, code) {\n        this.message = 'VAST Error: ' + (message || '');\n        if (code) {\n            this.code = code;\n        }\n    }\n\n    VASTError.prototype = new Error();\n    VASTError.prototype.name = \"VAST Error\";;\n    /**\n     * Inner helper class that deals with the logic of the individual steps needed to setup an ad in the player.\n     *\n     * @param player {object} instance of the player that will play the ad. It assumes that the videojs-contrib-ads plugin\n     *                        has been initialized when you use its utility functions.\n     *\n     * @constructor\n     */\n    function VASTIntegrator(player) {\n        if (!(this instanceof VASTIntegrator)) {\n            return new VASTIntegrator(player);\n        }\n\n        this.player = player;\n    }\n\n    VASTIntegrator.prototype.playAd = function playAd(vastResponse, callback) {\n        var that = this;\n        callback = callback || noop;\n\n        if (!(vastResponse instanceof VASTResponse)) {\n            return callback(new VASTError('On VASTIntegrator, missing required VASTResponse'));\n        }\n\n        async.waterfall([\n            function(next) {\n                next(null, vastResponse);\n            },\n            this._selectAdSource.bind(this),\n            this._createVASTTracker.bind(this),\n            this._addClickThrough.bind(this),\n            this._setupEvents.bind(this),\n            this._playSelectedAd.bind(this)\n        ], function(error, response) {\n            if (error && response) {\n                that._trackError(error, response);\n            }\n            callback(error, response);\n        });\n\n        this._adUnit = {\n            _src: null,\n            type: 'VAST',\n            pauseAd: function() {\n                that.player.pause(true); //video.js player pause\n            },\n\n            resumeAd: function() {\n                that.player.play(true);\n            },\n\n            isPaused: function() {\n                return that.player.paused(true);\n            },\n\n            getSrc: function() {\n                return this._src;\n            }\n        };\n\n        return this._adUnit;\n    };\n\n    VASTIntegrator.prototype._selectAdSource = function selectAdSource(response, callback) {\n        var source;\n\n        var playerWidth = dom.getDimension(this.player.el()).width;\n        response.mediaFiles.sort(function compareTo(a, b) {\n            var deltaA = Math.abs(playerWidth - a.width);\n            var deltaB = Math.abs(playerWidth - b.width);\n            return deltaA - deltaB;\n        });\n\n        source = this.player.selectSource(response.mediaFiles).source;\n\n        if (source) {\n            if (this._adUnit) {\n                this._adUnit._src = source;\n            }\n            return callback(null, source, response);\n        }\n\n        // code 403 <== Couldn't find MediaFile that is supported by this video player\n        callback(new VASTError(\"Could not find Ad mediafile supported by this player\", 403), response);\n    };\n\n    VASTIntegrator.prototype._createVASTTracker = function createVASTTracker(adMediaFile, response, callback) {\n        try {\n            callback(null, adMediaFile, new VASTTracker(adMediaFile.src, response), response);\n        } catch (e) {\n            callback(e, response);\n        }\n    };\n\n    VASTIntegrator.prototype._setupEvents = function setupEvents(adMediaFile, tracker, response, callback) {\n        var previouslyMuted;\n        var player = this.player;\n        player.on('fullscreenchange', trackFullscreenChange);\n        player.on('vast.adStart', trackImpressions);\n        player.on('pause', trackPause);\n        player.on('timeupdate', trackProgress);\n        player.on('volumechange', trackVolumeChange);\n\n        playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], unbindEvents);\n        playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel', 'vast.adSkip'], function(evt) {\n            if (evt.type === 'vast.adEnd') {\n                tracker.trackComplete();\n            }\n        });\n\n        return callback(null, adMediaFile, response);\n\n        /*** Local Functions ***/\n        function unbindEvents() {\n            player.off('fullscreenchange', trackFullscreenChange);\n            player.off('vast.adStart', trackImpressions);\n            player.off('pause', trackPause);\n            player.off('timeupdate', trackProgress);\n            player.off('volumechange', trackVolumeChange);\n        }\n\n        function trackFullscreenChange() {\n            if (player.isFullscreen()) {\n                tracker.trackFullscreen();\n            } else {\n                tracker.trackExitFullscreen();\n            }\n        }\n\n        function trackPause() {\n            //NOTE: whenever a video ends the video Element triggers a 'pause' event before the 'ended' event.\n            //      We should not track this pause event because it makes the VAST tracking confusing again we use a\n            //      Threshold of 2 seconds to prevent false positives on IOS.\n            if (Math.abs(player.duration() - player.currentTime()) < 2) {\n                return;\n            }\n\n            tracker.trackPause();\n            playerUtils.once(player, ['play', 'vast.adEnd', 'vast.adsCancel'], function(evt) {\n                if (evt.type === 'play') {\n                    tracker.trackResume();\n                }\n            });\n        }\n\n        function trackProgress() {\n            var currentTimeInMs = player.currentTime() * 1000;\n            tracker.trackProgress(currentTimeInMs);\n        }\n\n        function trackImpressions() {\n            tracker.trackImpressions();\n            tracker.trackCreativeView();\n        }\n\n        function trackVolumeChange() {\n            var muted = player.muted();\n            if (muted) {\n                tracker.trackMute();\n            } else if (previouslyMuted) {\n                tracker.trackUnmute();\n            }\n            previouslyMuted = muted;\n        }\n    };\n\n    VASTIntegrator.prototype._addClickThrough = function addClickThrough(mediaFile, tracker, response, callback) {\n        var player = this.player;\n        var blocker = createClickThroughBlocker(player, tracker, response);\n        var updateBlocker = updateBlockerURL.bind(this, blocker, response, player);\n\n        player.el().insertBefore(blocker, player.controlBar.el());\n        player.on('timeupdate', updateBlocker);\n        playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeBlocker);\n\n        return callback(null, mediaFile, tracker, response);\n\n        /*** Local Functions ***/\n\n        function createClickThroughBlocker(player, tracker, response) {\n            var blocker = window.document.createElement(\"a\");\n            var clickThroughMacro = response.clickThrough;\n\n            dom.addClass(blocker, 'vast-blocker');\n            blocker.href = generateClickThroughURL(clickThroughMacro, player);\n\n            if (isString(clickThroughMacro)) {\n                blocker.target = \"_blank\";\n            }\n\n            blocker.onclick = function(e) {\n                if (player.paused()) {\n                    player.play();\n\n                    //We prevent event propagation to avoid problems with the player's normal pause mechanism\n                    if (window.Event.prototype.stopPropagation !== undefined) {\n                        e.stopPropagation();\n                    }\n                    return false;\n                }\n\n                player.pause();\n                tracker.trackClick();\n            };\n\n            return blocker;\n        }\n\n        function updateBlockerURL(blocker, response, player) {\n            blocker.href = generateClickThroughURL(response.clickThrough, player);\n        }\n\n        function generateClickThroughURL(clickThroughMacro, player) {\n            var variables = {\n                ASSETURI: mediaFile.src,\n                CONTENTPLAYHEAD: vastUtil.formatProgress(player.currentTime() * 1000)\n            };\n\n            return clickThroughMacro ? vastUtil.parseURLMacro(clickThroughMacro, variables) : '#';\n        }\n\n        function removeBlocker() {\n            player.off('timeupdate', updateBlocker);\n            dom.remove(blocker);\n        }\n    };\n\n    VASTIntegrator.prototype._playSelectedAd = function playSelectedAd(source, response, callback) {\n        var player = this.player;\n\n        player.preload(\"auto\"); //without preload=auto the durationchange event is never fired\n        player.src(source);\n\n        playerUtils.once(player, ['durationchange', 'error', 'vast.adsCancel'], function(evt) {\n            if (evt.type === 'durationchange') {\n                playAd();\n            } else if (evt.type === 'error') {\n                callback(new VASTError(\"on VASTIntegrator, Player is unable to play the Ad\", 400), response);\n            }\n            //NOTE: If the ads get canceled we do nothing/\n        });\n\n        /**** local functions ******/\n        function playAd() {\n            player.play();\n            playerUtils.once(player, ['playing', 'vast.adsCancel'], function(evt) {\n                if (evt.type === 'vast.adsCancel') {\n                    return;\n                }\n\n                player.trigger('vast.adStart');\n\n                playerUtils.once(player, ['ended', 'vast.adsCancel', 'vast.adSkip'], function(evt) {\n                    if (evt.type === 'ended' || evt.type === 'vast.adSkip') {\n                        callback(null, response);\n                    }\n                    //NOTE: if the ads get cancel we do nothing\n                });\n            });\n        }\n    };\n\n    VASTIntegrator.prototype._trackError = function trackError(error, response) {\n        vastUtil.track(response.errorURLMacros, { ERRORCODE: error.code || 900 });\n    };\n\n    ;\n    (function(window) {\n        \"use strict\";\n\n\n        function VASTResponse() {\n            if (!(this instanceof VASTResponse)) {\n                return new VASTResponse();\n            }\n\n            this._linearAdded = false;\n            this.ads = [];\n            this.errorURLMacros = [];\n            this.impressions = [];\n            this.clickTrackings = [];\n            this.customClicks = [];\n            this.trackingEvents = {};\n            this.mediaFiles = [];\n            this.clickThrough = undefined;\n            this.adTitle = '';\n            this.duration = undefined;\n            this.skipoffset = undefined;\n        }\n\n        VASTResponse.prototype.addAd = function(ad) {\n            var inLine, wrapper;\n\n            if (ad instanceof Ad) {\n                inLine = ad.inLine;\n                wrapper = ad.wrapper;\n\n                this.ads.push(ad);\n\n                if (inLine) {\n                    this._addInLine(inLine);\n                }\n\n                if (wrapper) {\n                    this._addWrapper(wrapper);\n                }\n            }\n        };\n\n        VASTResponse.prototype._addErrorTrackUrl = function(error) {\n            var errorURL = error instanceof xml.JXONTree ? xml.keyValue(error) : error;\n            if (errorURL) {\n                this.errorURLMacros.push(errorURL);\n            }\n        };\n\n        VASTResponse.prototype._addImpressions = function(impressions) {\n            isArray(impressions) && appendToArray(this.impressions, impressions);\n        };\n\n        VASTResponse.prototype._addClickThrough = function(clickThrough) {\n            if (isNotEmptyString(clickThrough)) {\n                this.clickThrough = clickThrough;\n            }\n        };\n\n        VASTResponse.prototype._addClickTrackings = function(clickTrackings) {\n            isArray(clickTrackings) && appendToArray(this.clickTrackings, clickTrackings);\n        };\n\n        VASTResponse.prototype._addCustomClicks = function(customClicks) {\n            isArray(customClicks) && appendToArray(this.customClicks, customClicks);\n        };\n\n        VASTResponse.prototype._addTrackingEvents = function(trackingEvents) {\n            var eventsMap = this.trackingEvents;\n\n            if (trackingEvents) {\n                trackingEvents = isArray(trackingEvents) ? trackingEvents : [trackingEvents];\n                trackingEvents.forEach(function(trackingEvent) {\n                    if (!eventsMap[trackingEvent.name]) {\n                        eventsMap[trackingEvent.name] = [];\n                    }\n                    eventsMap[trackingEvent.name].push(trackingEvent);\n                });\n            }\n        };\n\n        VASTResponse.prototype._addTitle = function(title) {\n            if (isNotEmptyString(title)) {\n                this.adTitle = title;\n            }\n        };\n\n        VASTResponse.prototype._addDuration = function(duration) {\n            if (isNumber(duration)) {\n                this.duration = duration;\n            }\n        };\n\n        VASTResponse.prototype._addVideoClicks = function(videoClicks) {\n            if (videoClicks instanceof VideoClicks) {\n                this._addClickThrough(videoClicks.clickThrough);\n                this._addClickTrackings(videoClicks.clickTrackings);\n                this._addCustomClicks(videoClicks.customClicks);\n            }\n        };\n\n        VASTResponse.prototype._addMediaFiles = function(mediaFiles) {\n            isArray(mediaFiles) && appendToArray(this.mediaFiles, mediaFiles);\n        };\n\n        VASTResponse.prototype._addSkipoffset = function(offset) {\n            if (offset) {\n                this.skipoffset = offset;\n            }\n        };\n\n        VASTResponse.prototype._addAdParameters = function(adParameters) {\n            if (adParameters) {\n                this.adParameters = adParameters;\n            }\n        };\n\n        VASTResponse.prototype._addLinear = function(linear) {\n            if (linear instanceof Linear) {\n                this._addDuration(linear.duration);\n                this._addTrackingEvents(linear.trackingEvents);\n                this._addVideoClicks(linear.videoClicks);\n                this._addMediaFiles(linear.mediaFiles);\n                this._addSkipoffset(linear.skipoffset);\n                this._addAdParameters(linear.adParameters);\n                this._linearAdded = true;\n            }\n        };\n\n        VASTResponse.prototype._addInLine = function(inLine) {\n            var that = this;\n\n            if (inLine instanceof InLine) {\n                this._addTitle(inLine.adTitle);\n                this._addErrorTrackUrl(inLine.error);\n                this._addImpressions(inLine.impressions);\n\n                inLine.creatives.forEach(function(creative) {\n                    if (creative.linear) {\n                        that._addLinear(creative.linear);\n                    }\n                });\n            }\n        };\n\n        VASTResponse.prototype._addWrapper = function(wrapper) {\n            var that = this;\n\n            if (wrapper instanceof Wrapper) {\n                this._addErrorTrackUrl(wrapper.error);\n                this._addImpressions(wrapper.impressions);\n\n                wrapper.creatives.forEach(function(creative) {\n                    var linear = creative.linear;\n                    if (linear) {\n                        that._addVideoClicks(linear.videoClicks);\n                        that.clickThrough = undefined; //We ensure that no clickThrough has been added\n                        that._addTrackingEvents(linear.trackingEvents);\n                    }\n                });\n            }\n        };\n\n        VASTResponse.prototype.hasLinear = function() {\n            return this._linearAdded;\n        };\n\n        function appendToArray(array, items) {\n            items.forEach(function(item) {\n                array.push(item);\n            });\n        }\n\n        window.VASTResponse = VASTResponse;\n    })(window);\n\n    ;\n\n    function VASTTracker(assetURI, vastResponse) {\n        if (!(this instanceof VASTTracker)) {\n            return new VASTTracker(assetURI, vastResponse);\n        }\n\n        sanityCheck(assetURI, vastResponse);\n        this.response = vastResponse;\n        this.assetURI = assetURI;\n        this.progress = 0;\n        this.quartiles = {\n            firstQuartile: { tracked: false, time: Math.round(25 * vastResponse.duration) / 100 },\n            midpoint: { tracked: false, time: Math.round(50 * vastResponse.duration) / 100 },\n            thirdQuartile: { tracked: false, time: Math.round(75 * vastResponse.duration) / 100 }\n        };\n\n        /*** Local Functions ***/\n        function sanityCheck(assetURI, vastResponse) {\n            if (!isString(assetURI) || isEmptyString(assetURI)) {\n                throw new VASTError('on VASTTracker constructor, missing required the URI of the ad asset being played');\n            }\n\n            if (!(vastResponse instanceof VASTResponse)) {\n                throw new VASTError('on VASTTracker constructor, missing required VAST response');\n            }\n        }\n    }\n\n    VASTTracker.prototype.trackURLs = function trackURLs(urls, variables) {\n        if (isArray(urls) && urls.length > 0) {\n            variables = extend({\n                ASSETURI: this.assetURI,\n                CONTENTPLAYHEAD: vastUtil.formatProgress(this.progress)\n            }, variables || {});\n\n            vastUtil.track(urls, variables);\n        }\n    };\n\n    VASTTracker.prototype.trackEvent = function trackEvent(eventName, trackOnce) {\n        this.trackURLs(getEventUris(this.response.trackingEvents[eventName]));\n        if (trackOnce) {\n            this.response.trackingEvents[eventName] = undefined;\n        }\n\n        /*** Local function ***/\n        function getEventUris(trackingEvents) {\n            var uris;\n\n            if (trackingEvents) {\n                uris = [];\n                trackingEvents.forEach(function(event) {\n                    uris.push(event.uri);\n                });\n            }\n            return uris;\n        }\n    };\n\n    VASTTracker.prototype.trackProgress = function trackProgress(newProgressInMs) {\n        var events = [];\n        var ONCE = true;\n        var ALWAYS = false;\n        var trackingEvents = this.response.trackingEvents;\n\n        if (isNumber(newProgressInMs)) {\n            addTrackEvent('start', ONCE, newProgressInMs > 0);\n            addTrackEvent('rewind', ALWAYS, hasRewound(this.progress, newProgressInMs));\n            addQuartileEvents.call(this, newProgressInMs);\n            trackProgressEvents.call(this, newProgressInMs);\n            trackEvents.call(this);\n            this.progress = newProgressInMs;\n        }\n\n        /*** Local function ***/\n        function hasRewound(currentProgress, newProgress) {\n            var REWIND_THRESHOLD = 3000; //IOS video clock is very unreliable and we need a 3 seconds threshold to ensure that there was a rewind an that it was on purpose.\n            return currentProgress > newProgressInMs && Math.abs(newProgress - currentProgress) > REWIND_THRESHOLD;\n        }\n\n        function addTrackEvent(eventName, trackOnce, canBeAdded) {\n            if (trackingEvents[eventName] && canBeAdded) {\n                events.push({\n                    name: eventName,\n                    trackOnce: !!trackOnce\n                });\n            }\n        }\n\n        function addQuartileEvents(progress) {\n            var quartiles = this.quartiles;\n            var firstQuartile = this.quartiles.firstQuartile;\n            var midpoint = this.quartiles.midpoint;\n            var thirdQuartile = this.quartiles.thirdQuartile;\n\n            if (!firstQuartile.tracked) {\n                trackQuartile('firstQuartile', progress);\n            } else if (!midpoint.tracked) {\n                trackQuartile('midpoint', progress);\n            } else {\n                trackQuartile('thirdQuartile', progress);\n            }\n\n            /*** Local function ***/\n            function trackQuartile(quartileName, progress) {\n                var quartile = quartiles[quartileName];\n                if (canBeTracked(quartile, progress)) {\n                    quartile.tracked = true;\n                    addTrackEvent(quartileName, ONCE, true);\n                }\n            }\n        }\n\n        function canBeTracked(quartile, progress) {\n            var quartileTime = quartile.time;\n            //We only fire the quartile event if the progress is bigger than the quartile time by 5 seconds at most.\n            return progress >= quartileTime && progress <= (quartileTime + 5000);\n        }\n\n        function trackProgressEvents(progress) {\n            if (!isArray(trackingEvents.progress)) {\n                return; //Nothing to track\n            }\n\n            var pendingProgressEvts = [];\n            var that = this;\n\n            trackingEvents.progress.forEach(function(evt) {\n                if (evt.offset <= progress) {\n                    that.trackURLs([evt.uri]);\n                } else {\n                    pendingProgressEvts.push(evt);\n                }\n            });\n            trackingEvents.progress = pendingProgressEvts;\n        }\n\n        function trackEvents() {\n            events.forEach(function(event) {\n                this.trackEvent(event.name, event.trackOnce);\n            }, this);\n        }\n    };\n\n    [\n        'rewind',\n        'fullscreen',\n        'exitFullscreen',\n        'pause',\n        'resume',\n        'mute',\n        'unmute',\n        'acceptInvitation',\n        'acceptInvitationLinear',\n        'collapse',\n        'expand'\n    ].forEach(function(eventName) {\n        VASTTracker.prototype['track' + capitalize(eventName)] = function() {\n            this.trackEvent(eventName);\n        };\n    });\n\n    [\n        'start',\n        'skip',\n        'close',\n        'closeLinear'\n    ].forEach(function(eventName) {\n        VASTTracker.prototype['track' + capitalize(eventName)] = function() {\n            this.trackEvent(eventName, true);\n        };\n    });\n\n    [\n        'firstQuartile',\n        'midpoint',\n        'thirdQuartile'\n    ].forEach(function(quartile) {\n        VASTTracker.prototype['track' + capitalize(quartile)] = function() {\n            this.quartiles[quartile].tracked = true;\n            this.trackEvent(quartile, true);\n        };\n    });\n\n    VASTTracker.prototype.trackComplete = function() {\n        if (this.quartiles.thirdQuartile.tracked) {\n            this.trackEvent('complete', true);\n        }\n    };\n\n    VASTTracker.prototype.trackErrorWithCode = function trackErrorWithCode(errorcode) {\n        if (isNumber(errorcode)) {\n            this.trackURLs(this.response.errorURLMacros, { ERRORCODE: errorcode });\n        }\n    };\n\n    VASTTracker.prototype.trackImpressions = function trackImpressions() {\n        this.trackURLs(this.response.impressions);\n    };\n\n    VASTTracker.prototype.trackCreativeView = function trackCreativeView() {\n        this.trackEvent('creativeView');\n    };\n\n    VASTTracker.prototype.trackClick = function trackClick() {\n        this.trackURLs(this.response.clickTrackings);\n    };\n\n    ;\n\n    function VideoClicks(videoClickJTree) {\n        if (!(this instanceof VideoClicks)) {\n            return new VideoClicks(videoClickJTree);\n        }\n\n        this.clickThrough = xml.keyValue(videoClickJTree.clickThrough);\n        this.clickTrackings = parseClickTrackings(videoClickJTree.clickTracking);\n        this.customClicks = parseClickTrackings(videoClickJTree.customClick);\n\n        /*** Local functions ***/\n        function parseClickTrackings(trackingData) {\n            var clickTrackings = [];\n            if (trackingData) {\n                trackingData = isArray(trackingData) ? trackingData : [trackingData];\n                trackingData.forEach(function(clickTrackingData) {\n                    clickTrackings.push(xml.keyValue(clickTrackingData));\n                });\n            }\n            return clickTrackings;\n        }\n    };\n\n    function Wrapper(wrapperJTree) {\n        if (!(this instanceof Wrapper)) {\n            return new Wrapper(wrapperJTree);\n        }\n\n        //Required elements\n        this.adSystem = xml.keyValue(wrapperJTree.adSystem);\n        this.impressions = vastUtil.parseImpressions(wrapperJTree.impression);\n        this.VASTAdTagURI = xml.keyValue(wrapperJTree.vASTAdTagURI);\n\n        //Optional elements\n        this.creatives = vastUtil.parseCreatives(wrapperJTree.creatives);\n        this.error = xml.keyValue(wrapperJTree.error);\n        this.extensions = wrapperJTree.extensions;\n\n        //Optional attrs\n        this.followAdditionalWrappers = isDefined(xml.attr(wrapperJTree, 'followAdditionalWrappers')) ? xml.attr(wrapperJTree, 'followAdditionalWrappers') : true;\n        this.allowMultipleAds = xml.attr(wrapperJTree, 'allowMultipleAds');\n        this.fallbackOnNoAd = xml.attr(wrapperJTree, 'fallbackOnNoAd');\n    }\n\n\n    ;\n    \"use strict\";\n\n    var vastUtil = {\n\n        track: function track(URLMacros, variables) {\n            var sources = vastUtil.parseURLMacros(URLMacros, variables);\n            var trackImgs = [];\n            sources.forEach(function(src) {\n                var img = new Image();\n                img.src = src;\n                trackImgs.push(img);\n            });\n            return trackImgs;\n        },\n\n        parseURLMacros: function parseMacros(URLMacros, variables) {\n            var parsedURLs = [];\n\n            variables = variables || {};\n\n            if (!(variables[\"CACHEBUSTING\"])) {\n                variables[\"CACHEBUSTING\"] = Math.round(Math.random() * 1.0e+10);\n            }\n\n            URLMacros.forEach(function(URLMacro) {\n                parsedURLs.push(vastUtil._parseURLMacro(URLMacro, variables));\n            });\n\n            return parsedURLs;\n        },\n\n        parseURLMacro: function parseMacro(URLMacro, variables) {\n            variables = variables || {};\n\n            if (!(variables[\"CACHEBUSTING\"])) {\n                variables[\"CACHEBUSTING\"] = Math.round(Math.random() * 1.0e+10);\n            }\n\n            return vastUtil._parseURLMacro(URLMacro, variables);\n        },\n\n        _parseURLMacro: function parseMacro(URLMacro, variables) {\n            variables = variables || {};\n\n            forEach(variables, function(value, key) {\n                URLMacro = URLMacro.replace(new RegExp(\"\\\\[\" + key + \"\\\\\\]\", 'gm'), value);\n            });\n\n            return URLMacro;\n        },\n\n        parseDuration: function parseDuration(durationStr) {\n            var durationRegex = /(\\d\\d):(\\d\\d):(\\d\\d)(\\.(\\d\\d\\d))?/;\n            var match, durationInMs;\n\n            if (isString(durationStr)) {\n                match = durationStr.match(durationRegex);\n                if (match) {\n                    durationInMs = parseHoursToMs(match[1]) + parseMinToMs(match[2]) + parseSecToMs(match[3]) + parseInt(match[5] || 0);\n                }\n            }\n\n            return isNaN(durationInMs) ? null : durationInMs;\n\n            /*** local functions ***/\n            function parseHoursToMs(hourStr) {\n                return parseInt(hourStr, 10) * 60 * 60 * 1000;\n            }\n\n            function parseMinToMs(minStr) {\n                return parseInt(minStr, 10) * 60 * 1000;\n            }\n\n            function parseSecToMs(secStr) {\n                return parseInt(secStr, 10) * 1000;\n            }\n        },\n\n        parseImpressions: function parseImpressions(impressions) {\n            if (impressions) {\n                impressions = isArray(impressions) ? impressions : [impressions];\n                return transformArray(impressions, function(impression) {\n                    if (isNotEmptyString(impression.keyValue)) {\n                        return impression.keyValue;\n                    }\n                    return undefined;\n                });\n            }\n            return [];\n        },\n\n        parseCreatives: function parseCreatives(creativesJTree) {\n            var creatives = [];\n            var creativesData;\n            if (isDefined(creativesJTree) && isDefined(creativesJTree.creative)) {\n                creativesData = isArray(creativesJTree.creative) ? creativesJTree.creative : [creativesJTree.creative];\n                creativesData.forEach(function(creative) {\n                    creatives.push(new Creative(creative));\n                });\n            }\n            return creatives;\n        },\n\n        //We assume that the progress is going to arrive in milliseconds\n        formatProgress: function formatProgress(progress) {\n            var hours, minutes, seconds, milliseconds;\n            hours = progress / (60 * 60 * 1000);\n            hours = Math.floor(hours);\n            minutes = (progress / (60 * 1000)) % 60;\n            minutes = Math.floor(minutes);\n            seconds = (progress / 1000) % 60;\n            seconds = Math.floor(seconds);\n            milliseconds = progress % 1000;\n            return toFixedDigits(hours, 2) + ':' + toFixedDigits(minutes, 2) + ':' + toFixedDigits(seconds, 2) + '.' + toFixedDigits(milliseconds, 3);\n        },\n\n        parseOffset: function parseOffset(offset, duration) {\n            if (isPercentage(offset)) {\n                return calculatePercentage(offset, duration);\n            }\n            return vastUtil.parseDuration(offset);\n\n            /*** Local function ***/\n            function isPercentage(offset) {\n                var percentageRegex = /^\\d+(\\.\\d+)?%$/g;\n                return percentageRegex.test(offset);\n            }\n\n            function calculatePercentage(percentStr, duration) {\n                if (duration) {\n                    return calcPercent(duration, parseFloat(percentStr.replace('%', '')));\n                }\n                return null;\n            }\n\n            function calcPercent(quantity, percent) {\n                return quantity * percent / 100;\n            }\n        },\n\n        isVPAID: function isVPAIDMediaFile(mediaFile) {\n            return !!mediaFile && mediaFile.apiFramework === 'VPAID';\n        }\n    };\n})(window, document, videojs);\n//# sourceMappingURL=videojs-vast-vpaid.js.map\n\n/* jshint ignore:end */\n"

/***/ }),
/* 46 */
/***/ (function(module, exports) {

	/**
	 * ExtendDefaultOption for playerManager
	 * This logic will exnted options to have default value
	 * 
	 * @param defaultOptions
	 * @param options_
	 * @returns {*}
	 * @constructor
	 */
	var ExtendDefaultOption = function (defaultOptions, options_) {

	    function isObject(obj) {
	        return typeof obj === 'object';
	    }

	    function isNull(o) {
	        return o === null;
	    }

	    function extend(obj) {
	        var arg, i, k;
	        for (i = 1; i < arguments.length; i++) {
	            arg = arguments[i];
	            for (k in arg) {
	                if (arg.hasOwnProperty(k)) {
	                    if (isObject(obj[k]) && !isNull(obj[k]) && isObject(arg[k])) {
	                        obj[k] = extend({}, obj[k], arg[k]);
	                    } else {
	                        obj[k] = arg[k];
	                    }
	                }
	            }
	        }
	        return obj;
	    }

	    //extend by default options
	    var options = extend({}, defaultOptions, options_ || {});

	    //manual touch
	    if (options.playerTechnology === undefined || options.playerTechnology.length === 0) {
	        options.playerTechnology = ["html5", "flash"];
	    }

	    if (!options.width || typeof options.width === "undefined" || options.width === "" || options.width === 0) {
	        options.autoInitialSize = true;
	    }

	    //handle disableCollapse if it's number or true or false
	    if (typeof(options.disableCollapse) === "number") {
	        if (options.disableCollapse >= 0) {
	            options.disableCollapseForDelay = options.disableCollapse;
	        }
	        options.disableCollapse = false;
	    }


	    //this options should be false anytime.
	    options.enableExplicitPause = true;

	    return options;//TODO is Object.create required for this?

	};

	module.exports = ExtendDefaultOption;



/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var plainCssText = __webpack_require__(48);


	var _logger = __webpack_require__(9);
	var debug = function (message) {
	    _logger.debug("Custom Skinning: " + message);
	};

	var reorderControlBar = function(playerSelf, videojs, iframeDocument, isInline) {
	    var controlBar = videojs.controlBar;

	    var buttonOrderLeft = playerSelf.options.playerSkin.buttonOrderLeft;
	    var buttonOrderRight = playerSelf.options.playerSkin.buttonOrderRight;

	    var process = function(value, index, array, float) {
	        var component;

	        if (controlBar[value]) {
	            component = controlBar[value].el_;
	            if (isInline) {
	                if (value === 'playToggle') {
	                    component = iframeDocument.getElementById('customPlayToggle');
	                } else if (value === 'fullscreenToggle') {
	                    component = iframeDocument.getElementById('customFullscreenToggle');
	                }
	            }
	            if (component) {
	                controlBar.el_.appendChild(component);
	                component.style.float = float;
	            }
	        }
	    };

	    if (buttonOrderLeft) {
	        buttonOrderLeft.forEach(function(value, index, array) {
	            process(value, index, array, 'left');
	        });
	    }

	    if (buttonOrderRight) {
	        buttonOrderRight.reverse().forEach(function(value, index, array) {
	            process(value, index, array, 'right');
	        });
	    }
	};

	var styleElements = function(playerSelf, videojs, IframeDocument, isInline) {

	    debug("Applying custom styles/skins");

	    var cssForIosInlineVideo =  "";
	    if (isInline) {
	        cssForIosInlineVideo = ".vjs-default-skin.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar {display: block !important;visibility: visible !important;opacity: 1 !important} .vjs-loading-spinner { position: absolute; top: 50%; left: 50%; font-size: 4em; line-height: 1; width: 1em; height: 1em; margin-left: -0.5em; margin-top: -0.5em; opacity: 0.75; display: block; -webkit-animation: spin 1.5s infinite linear; -moz-animation: spin 1.5s infinite linear; -o-animation: spin 1.5s infinite linear; animation: spin 1.5s infinite linear; }\n";
	    }
	    var cssForIos = "video::-webkit-media-controls-start-playback-button {display: none !important;-webkit-appearance: none;}\n";
	    // Check VIDLA-815 for details about the replay unicode value
	    var cssForReplay = ".vjs-default-skin .vjs-big-play-button-replay:before {content: \"\\e984\";}\n";

	    var cssForEndCard = ".vjs-default-skin .vjs-ec-button-learnmore:before {content: \"\\e926\";} .ec-button {display: block; cursor: pointer; height: 1em; font-family: VideoJS; margin: 0.5em; padding: 0.3em; border: 2px solid gray; background-color: rgba(128,128,128,0); transition: background-color 0.8s; -webkit-transition: background-color 0.5s;}\n";
	    // Disabling the hover animation because it gets stuck on when tab loses focus or always on iOS when button is clicked
	    //cssForEndCard += ".ec-button:hover {background-color: rgba(128,128,128,0.7);}\n";

	    var skinCss = "\n";

	    var playerSkin = playerSelf.options.playerSkin;

	    if (playerSkin) {
	        if (!playerSkin.bigPlayButtonColor) {
	            playerSkin.bigPlayButtonColor = "#7b7a7d";
	        }
	        if (playerSkin.topBarColor) {
	            skinCss += "#top_chrome { background: " + playerSkin.topBarColor + "; }\n";
	        }
	        if (playerSkin.dividerColor) {
	            skinCss += "#top_chrome { border-bottom-color: " + playerSkin.dividerColor + "; }\n";
	        } else {
	            skinCss += "#top_chrome { border-bottom-color: " + playerSkin.bottomDividerColor + "; }\n";
	        }
	        if (typeof playerSkin.dividerHeight === "number") {
	            skinCss += "#top_chrome { border-bottom-width: " + playerSkin.dividerHeight + "; border-bottom-style: solid; }\n";
	        } else {
	            skinCss += "#top_chrome { border-bottom-width: " + playerSkin.bottomDividerWidth + "; border-bottom-style: solid; }\n";
	        }
	        if (playerSkin.topBarTextColor) {
	            skinCss += ".top-bar-text { color: " + playerSkin.topBarTextColor + "; }\n";
	        }
	        if (playerSkin.controlBarColor) {
	            skinCss += ".vjs-default-skin .vjs-control-bar { background-color: " + playerSkin.controlBarColor + "; }\n";
	        }
	        if (playerSkin.controlBarControlsColor) {
	            skinCss += ".vjs-default-skin .vjs-control-bar { color: " + playerSkin.controlBarControlsColor + "; }\n";
	            skinCss += ".vjs-default-skin:hover .vjs-control-bar { color: " + playerSkin.controlBarControlsColor + "; }\n";
	        }
	        if (playerSkin.bigPlayButtonColor) {
	            skinCss += ".vjs-default-skin .vjs-big-play-button { color: " + playerSkin.bigPlayButtonColor + "; border-color: " + playerSkin.bigPlayButtonColor + "; }\n";
	            skinCss += ".vjs-default-skin:hover .vjs-big-play-button { color: " + playerSkin.bigPlayButtonColor + "; border-color: " + playerSkin.bigPlayButtonColor + "; }\n";
	        }
	        if (playerSkin.progressBarElapsedColor) {
	            skinCss += ".vjs-default-skin .vjs-play-progress { background: " + playerSkin.progressBarElapsedColor + " }\n";
	        }
	        if (playerSkin.volumeBarBackground) {
	            skinCss += ".vjs-default-skin .vjs-volume-level { background: " + playerSkin.volumeBarBackground + " }\n";
	        }
	        if (playerSkin.controlBarHeight) {
	            skinCss += ".vjs-default-skin .vjs-control-bar { height: " + playerSkin.controlBarHeight + "px; }\n";
	            /* for control bar 20px-30px, font size should be one third of the control bar height*/
	            skinCss += ".vjs-default-skin .vjs-control { font-size: " + Math.ceil(playerSkin.controlBarHeight/3) + "px; }\n";
	            /* the time divider is set up different so we need to adjust the size relative to the controlBarHeight */
	            skinCss += ".vjs-default-skin .vjs-time-divider { height: " + playerSkin.controlBarHeight + "px; line-height: " + playerSkin.controlBarHeight/9.7 + "em} \n";
	            /* to ensure the progressBar doesn't change height when we change font-height */
	            skinCss += ".vjs-default-skin .vjs-progress-control { font-size: 0.3em } \n";
	        }

	        if (playerSkin.videoBackgroundColor && (playerSelf.options.isWaterfall === undefined || playerSelf.options.isWaterfall === false)) {//set background color of video area
	            skinCss += ".video-js {background:" + playerSkin.videoBackgroundColor + "} \n";
	        }

	        /*
	        video can have black background on its first frame of the video because a core player shows the first frame of the video every the core player built
	        so in waterfall, logic will always set block for the background and it will have proper background when "video_start" delivered
	        */
	        if (playerSelf.options.sideStream.dynamicBigPlayButtonOnSideStream && playerSelf.options.sideStream.dynamicBigPlayButtonOnSideStream === true) {//disable unnecessary css transition for big play button which caused animation while resizing the button
	            skinCss += ".vjs-default-skin .vjs-big-play-button {-webkit-transition: all 0s;-moz-transition: all 0s;-o-transition: all 0s;transition: all 0s;} \n";
	        }
	    } else {
	        skinCss += "#top_chrome { border-bottom-color: " + playerSkin.bottomDividerColor + "; border-bottom-width: " + playerSkin.bottomDividerWidth + "; border-bottom-style: solid; }\n";
	    }


	    /*
	    //old code
	    if ((playerSelf.isAndroid && playerSelf.isAndroid()) || playerSelf.options.controlBarPosition === "below") {
	        // VIDLA-1176 bottom value needs to be dependent on the height getting used and cannot be static(-3em)
	        //Calculating the proportion.
	        var bottomVal = -3.2;
	        if(playerSkin.controlBarHeight){
	            bottomVal = (-3.2 * playerSkin.controlBarHeight)/30;
	        }
	        skinCss += ".vjs-default-skin .vjs-control-bar { display: block !important;visibility: visible !important;opacity: 1 !important ;bottom:" +bottomVal+ "em }\n";
	    }
	    */


	    if ((playerSelf.isAndroid && playerSelf.isAndroid()) || playerSelf.options.controlBarPosition === "below") {

	        var correctBottomVal = -3.2;

	        if (playerSelf.options.showProgressBar === "text" || playerSelf.options.showProgressBar === true || playerSelf.options.showProgressBar === false) {
	            correctBottomVal = -3.0;//it was -3.2, fix VIDLA-1398
	            //a decision with Jeff for VIDLA-1398
	            //text = -3.0
	            //both = -3.2
	            //bar = -3.2
	            //true = -3.0
	            //false = -3.0
	        }

	        // VIDLA-1176 bottom value needs to be dependent on the height getting used and cannot be static(-3em)
	        //Calculating the proportion.
	        var bottomVal = correctBottomVal;
	        if(playerSkin.controlBarHeight){
	            bottomVal = (correctBottomVal * playerSkin.controlBarHeight)/30;
	        }
	        skinCss += ".vjs-default-skin .vjs-control-bar { display: block !important;visibility: visible !important;opacity: 1 !important ;bottom:" +bottomVal+ "em }\n";
	    }


	    //generate dynamic css
	    debug("Generating css element");
	    var cssStyle = document.createElement("style");
	    cssStyle.type = "text/css";
	    cssStyle.innerHTML = plainCssText + cssForIos + cssForReplay + skinCss + cssForIosInlineVideo + cssForEndCard;

	    IframeDocument.head.appendChild(cssStyle);

	};

	var render = function(playerSelf, videojs, IframeDocument, isInline) {

	    reorderControlBar(playerSelf, videojs, IframeDocument, isInline);
	    styleElements(playerSelf, videojs, IframeDocument, isInline);

	};

	module.exports = {
	    "render": render
	};


/***/ }),
/* 48 */
/***/ (function(module, exports) {

	module.exports = "/* SKIN\n================================================================================\nThe main class name for all skin-specific styles. To make your own skin,\nreplace all occurrences of 'vjs-default-skin' with a new name. Then add your new\nskin name to your video tag instead of the default skin.\ne.g. <video class=\"video-js my-skin-name\">\n*/\n.vjs-default-skin {\n  color: #CCCCCC;\n}\n/* Custom Icon Font\n--------------------------------------------------------------------------------\nThe control icons are from a custom font. Each icon corresponds to a character\n(e.g. \"\\e001\"). Font icons allow for easy scaling and coloring of icons.\n*/\n@font-face {\n  font-family: 'VideoJS';\n  src: url('font/vjs.eot');\n  src: url(data:application/font-woff;base64,d09GRgABAAAAABG0AAsAAAAAEWgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIHUGNtYXAAAAFoAAAAfAAAAHyz47CpZ2FzcAAAAeQAAAAIAAAACAAAABBnbHlmAAAB7AAADTwAAA08MPTaTGhlYWQAAA8oAAAANgAAADYP2gkbaGhlYQAAD2AAAAAkAAAAJAkgBThobXR4AAAPhAAAAGQAAABkW54DGGxvY2EAAA/oAAAANAAAADQeIiIQbWF4cAAAEBwAAAAgAAAAIAAiAIluYW1lAAAQPAAAAVYAAAFWUqTEiXBvc3QAABGUAAAAIAAAACAAAwAAAAMD/AGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6ioDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEAGAAAAAUABAAAwAEAAEAIOAO4B/mAOkm6YTqKv/9//8AAAAAACDgAOAe5gDpJumE6ir//f//AAH/4yAEH/UaFRbwFpMV7gADAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAH//wAPAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAIAAP/ABAADwAAGAA0AAAERJwcnNycDBxchERc3BACgwGDAoKDAoP5goMADwP5goMBgwKD9YMCgAaCgwAAAAAABAMAAQANAA0AAAgAAEwkBwAKA/YADQP6A/oAAAgCAAEADgANAAAMABwAAEyERIQEhESGAAUD+wAHAAUD+wANA/QADAP0AAAABAAAADwHAA3EACwAAATYWFREUBi8BIxEzAZEUGxsU8aCgA3EUDBv8xBsMFPEBgAACAAAADwJHA3EAGAAkAAAlIiYnJjQ3PgE0JicmNDc2MhceARQGBw4BAzYWFREUBi8BIxEzAiUJEgcODh4fHx4ODg4oDiwtLSwHEp0UGxsU8aCg2wcHDigOHk1QTR4OKA4ODixxdHEsBwcClhQMG/zEGwwU8QGAAAADAAAADwNwA3EAHQA2AEIAACUiJicmNDc+ATQmJyY0NzYyFx4DFRQOAgcOASciJicmNDc+ATQmJyY0NzYyFx4BFAYHDgEDNhYVERQGLwEjETMC0AoRBw4OMTExMQ4ODicOHy8gEREgLx8HEbQJEgcODh4fHx4ODg4oDiwtLSwHEp0UGxsU8aCggAcIDicOMnuCezIOJw4PDx5HTVQrK1RNRx4IB1sHBw4oDh5NUE0eDigODg4scXRxLAcHApYUDBv8xBsMFPEBgAAAAAAEAAAADwRAA3EAIwBBAFoAZgAAJSImJyY0Nz4DNTQuAicmNDc2MhceAxUUDgIHDgEjJyImJyY0Nz4BNCYnJjQ3NjIXHgMVFA4CBw4BJyImJyY0Nz4BNCYnJjQ3NjIXHgEUBgcOAQM2FhURFAYvASMRMwN6CRIHDg4hMyISEiIzIQ4ODigOKD0pFhYpPSgHEgmqChEHDg4xMTExDg4OJw4fLyARESAvHwcRtAkSBw4OHh8fHg4ODigOLC0tLAcSnRQbGxTxoKAmBwcOKA4hTFNaLi5aU0whDigODg4oW2VsODhsZVsoBwdaBwgOJw4ye4J7Mg4nDg8PHkdNVCsrVE1HHggHWwcHDigOHk1QTR4OKA4ODixxdHEsBwcClhQMG/zEGwwU8QGAAAEAwP/AA0ADwAADAAAJAwIA/sABQAFAA8D+AP4AAgAABAAA/7oFXgPAAAMALwBSAHUAABMhESEBLgEnLgEnLgMjIg4CBw4BBw4BBx4BFx4BFx4DFz4DNz4BNz4BJS4DIyIOAhUUHgIzMj4CNyMOASMiJjU0NjMyFhczIS4DIyIOAhUUHgIzMj4CNyMOASMiJjU0NjMyFhczAAVe+qIE3QESIAUUCRBVfZxWVZ+AWBAJFAcfEQICER8HFAkQWICfVVacfVUQCRQFIBL9ugQgOE4yLlA7IiA8VjcrSTYjBIoEIyM2ICsmIikDiAHeBCE3TjMtUDsiIDxWNixJNiIFigQjIzcfKyYhKQSIA8D7+gIHh4opCQwHCxAKBAQKEAsHDAkpioeHiSoJDAYMEAoFAQEFChAMBgwJKom2NVM5HyhLa0JDa0soHzpUNSc1WzpPUS8rNVM5HyhLa0JDa0soHzpUNSc1WzpPUS8rAAABAIAAQAOAA0AAAwAAEyERIYADAP0AA0D9AAAACAA4AAADwAPAAAsAFwAjAC8ASABhAHoAhgAAARQWMzI2NTQmIyIGBRQWMzI2NTQmIyIGExQWMzI2NTQmIyIGAxQWMzI2NTQmIyIGBTgBMRQWMzI2NTgBMTgBMTQmIyIGFRQ0MSU4ATEUFjMyNjU4ATE4ATE0JiMiBhUUNDEDOAExFBYzMjY1OAExOAExNCYjIgYVFDQxAxQWMzI2NTQmIyIGAYBLNTVLSzU1SwEQSzU1S0s1NUuwJRsbJSUbGyVwJRsaJiYaGyX+8CUbGyUlGxsl/vAmGhslJRsaJiA5Jyg4OCgnOVgqHh4qKh4eKgNANUtLNTVLS6U1S0s1NUtL/rsbJSUbGyUl/tUaJiYaGyUlixslJRsbJSUbGxtwGiYmGhslJRsaGgIgKDg4KCc5OScoKP7wHioqHh4qKgAAAAACAAD/wAQAA8AABgANAAABEScHJzcnAQcXIREXNwHAoMBgwKAD4MCg/mCgwAGA/mCgwGDAoAHgwKABoKDAAAAAAQAA/8AEAAOAACIAAAEyHgIVFA4CIyImJw4DBzU+ATU0JicuAzU0PgICAGq7i1BQi7tqFCgUKVpdYDAzTQEBLEYxG1CLuwOAQXGYVlaYcUEDAikzHQoCGxpXNAcPBxxIUlwxVphxQQADAAD/wAQAA8AAEwAnAFoAAAEiDgIVFB4CMzI+AjU0LgIDMh4CFRQOAiMiLgI1ND4CAQ4DIyIuAicuAzU0PgI3FzgBMQ4BFBYXHgEzMjY3PgE0Jic3HgMVFA4CAgBqu4tQUIu7amq7i1BQi7tqNV1GKChGXTU1XUYoKEZdAWYeR01UKytUTUceHy8gEREgLx9DMTExMTB7Q0N7MDExMTFDHy8gEREgLwPAUIu7amq7i1BQi7tqaruLUP8AKEZdNTVdRigoRl01NV1GKP3PHy8gEREgLx8eR01UKytUTUceQzJ7gnsyLzMzLzJ7gnsyQx5HTVQrK1RNRwAAAAABAAD/wAQAA8AAMwAAASIGByU+ATU0JiclHgEzMjY1NCYjIgYVFBYXBS4BIyIGFRQWMzI2NwUOARUUFjMyNjU0JgNgIjsW/lEBAQEBAa8WOyJCXl5CQl4BAf5RFjsiQl5eQiI7FgGvAQFeQkJeXgEAGhfYBg0GBg0G2BcaXkJCXl5CBg0G2BcaXkJCXhoX2AYNBkJeXkJCXgAAAAACACD/8AQAA7AAOgByAAABLgEnLgEnLgEnLgEHDgEHDgEHDgEHDgEXHgEXHgEXHgEXHgE3PgE3PgE3PgE3PgE3OgEzMjY1PAE1MQcOAQcOAQcOAScuAScuAScuAScuATc+ATc+ATc+ATc+ARceARceARceARceAQcxHAEVFBYXDgEHBAABFRUUOSQjVC4tYTExXywtTyEhNBESEAEBFBMTNiEiTisrWi4uWSkpSx4fMRAJDgMBAgEbJWYRMx8fSSgoVSoqUycmRR0dLA8PDgEBEhARLh0eQyUlTycnTSQjQBobKQ4NDQEhGAUPCwHAMmMtLlIiIzUSEhEBARUTFDcjIlEtLF4vL1wrK00gIDIQERABARQSEjQhIEwpGTQbJRsBAwGqKEceHi4QDw8BARIRETEeHkcmJ1EpKVAlJUIcGysODw0BAREQEC0cHEEkI0smAQMBGSQDGjMYAAACAAD/wAQAA8AAGQAzAAABIg4CBz4DMzIeAhUUFjMyNjU0LgIDMj4CNw4DIyIuAjU0JiMiBhUUHgICAGm4ilIDAkNxlVVWmHFBOCgoOFCLu2ppuIpSAwJDcZVVVphxQTgoKDhQi7sDwE6Itmhbn3ZERnqjXSg4OChqu4tQ/ABOiLZoW592REZ6o10oODgoaruLUAAAAgAA/8AEAAPAADAAPAAAATUnLgEnNycHLgEvASMHDgEHJwcXDgEPARUXHgEXBxc3HgEfATM3PgE3FzcnPgE/AQUiJjU0NjMyFhUUBgQAkwQLBlaIeQwbDhjAGA4bDHmIVgYLBJOTBQoHV4h6DBoNGcAZDRoMeohXBwoFk/4ANUtLNTVLSwFgwBkNGg15iFYGCwWSkgULBlaIeQ0aDRnAGQ0aDXmIVwYLBZOTBQsGV4h5DRoNGSBLNTVLSzU1SwAABgBA/8ADwAPAABkAIQA3AEUAUwBhAAABLgEnLgEnLgEjISIGFREUFjMhMjY1ETQmJyceARcjNR4BExQGIyEiJjURNDYzMDoCMRUUFjsBAyEiJjU0NjMhMhYVFAYnISImNTQ2MyEyFhUUBichIiY1NDYzITIWFRQGA5YRLRkaMxcnKQv+ECEvLyEC4CEvDhyFFyUNmhEphgkH/SAHCQkHm7qbEw3goP5ADRMTDQHADRMTDf5ADRMTDQHADRMTDf5ADRMTDQHADRMTAtsXMxoZLREcDi8h/KAhLy8hAnALKSc2FykRmg0l/OgHCQkHA2AHCeANE/4AEw0NExMNDROAEw0NExMNDROAEw0NExMNDRMAAAAAAQAA/8AEAAPAAC0AAAEhNy4BIyIGBw4BFRQWFx4BMzI2Nz4BNxcOAyMiLgI1ND4CMzIeAhc3BAD+gJA3jE1NjDc2Ojo2N4xNTYw3BAkEYCNWYmw6aruLUFCLu2o1ZFxSI5YCQJA2Ojo2N4xNTYw3Njo6NgUJBVQoQS0ZUIu7amq7i1AVJzcjlgAAAAACAAAAAAPAA34ADwAqAAABFSMnByM1Nyc1Mxc3MxUHASImLwEjIiY1ETQ2OwE3PgEXHgEVERQGBw4BA8BVa2tVa2tVa2tVa/5LBgwF9nMNExMNc/YHEwkJCwsJAwYBVVVra1Vra1Vra1Vr/kAFBPcTDQFADRP3BgQDBBAK/MAKEAQBAQABAAAAAQAAi1igY18PPPUACwQAAAAAANWuYlIAAAAA1a5iUgAA/7oFXgPAAAAACAACAAAAAAAAAAEAAAPA/8AAAAVeAAAAAAVeAAEAAAAAAAAAAAAAAAAAAAAZBAAAAAAAAAAAAAAAAgAAAAQAAAAEAADABAAAgAQAAAAEAAAABAAAAARAAAAEAADABV4AAAQAAIAEAAA4BAAAAAQAAAAEAAAABAAAAAQAACAEAAAABAAAAAQAAEAEAAAABAAAAAAAAAAACgAUAB4APgBMAGIAegC2ARwBsAHAAmYCdAMUAzQDaAPmBDQE4gUsBYwGFgZcBp4AAQAAABkAhwAIAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAMAAAABAAAAAAACAAcAPAABAAAAAAADAAMAKgABAAAAAAAEAAMAUQABAAAAAAAFAAsACQABAAAAAAAGAAMAMwABAAAAAAAKABoAWgADAAEECQABAAYAAwADAAEECQACAA4AQwADAAEECQADAAYALQADAAEECQAEAAYAVAADAAEECQAFABYAFAADAAEECQAGAAYANgADAAEECQAKADQAdHZqcwB2AGoAc1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMHZqcwB2AGoAc3ZqcwB2AGoAc1JlZ3VsYXIAUgBlAGcAdQBsAGEAcnZqcwB2AGoAc0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=) format(\"woff\"), url('font/vjs.eot?#iefix') format('embedded-opentype'), url('font/vjs.ttf') format('truetype'), url('font/vjs.svg#icomoon') format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n/* Base UI Component Classes\n--------------------------------------------------------------------------------\n*/\n/* Slider - used for Volume bar and Seek bar */\n.vjs-default-skin .vjs-slider {\n  /* Replace browser focus highlight with handle highlight */\n  outline: 0;\n  position: relative;\n  cursor: pointer;\n  padding: 0;\n  /* background-color-with-alpha */\n  background-color: #333333;\n  background-color: rgba(51, 51, 51, 0.9);\n}\n.vjs-default-skin .vjs-slider:focus {\n  /* box-shadow */\n  -webkit-box-shadow: 0 0 2em #fff;\n  -moz-box-shadow: 0 0 2em #fff;\n  box-shadow: 0 0 2em #fff;\n}\n.vjs-default-skin .vjs-slider-handle {\n  position: absolute;\n  /* Needed for IE6 */\n  left: 0;\n  top: 0;\n}\n.vjs-default-skin .vjs-slider-handle:before {\n  content: \"\\e009\";\n  font-family: VideoJS;\n  font-size: 1em;\n  line-height: 1;\n  text-align: center;\n  text-shadow: 0em 0em 1em #fff;\n  position: absolute;\n  top: 0;\n  left: 0;\n  /* Rotate the square icon to make a diamond */\n  /* transform */\n  -webkit-transform: rotate(-45deg);\n  -moz-transform: rotate(-45deg);\n  -ms-transform: rotate(-45deg);\n  -o-transform: rotate(-45deg);\n  transform: rotate(-45deg);\n}\n/* Control Bar\n--------------------------------------------------------------------------------\nThe default control bar that is a container for most of the controls.\n*/\n.vjs-default-skin .vjs-control-bar {\n  /* Start hidden */\n  display: none;\n  position: absolute;\n  /* Place control bar at the bottom of the player box/video.\n     If you want more margin below the control bar, add more height. */\n  bottom: 0;\n  /* Use left/right to stretch to 100% width of player div */\n  left: 0;\n  right: 0;\n  /* Height includes any margin you want above or below control items */\n  height: 3.0em;\n  /* background-color-with-alpha */\n  background-color: #07141E;\n  background-color: rgba(7, 20, 30, 0.7);\n}\n/* Show the control bar only once the video has started playing */\n.vjs-default-skin.vjs-has-started .vjs-control-bar {\n  display: block;\n  /* Visibility needed to make sure things hide in older browsers too. */\n  visibility: visible;\n  opacity: 1;\n  /* transition */\n  -webkit-transition: visibility 0.1s, opacity 0.1s;\n  -moz-transition: visibility 0.1s, opacity 0.1s;\n  -o-transition: visibility 0.1s, opacity 0.1s;\n  transition: visibility 0.1s, opacity 0.1s;\n}\n/* Hide the control bar when the video is playing and the user is inactive  */\n.vjs-default-skin.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar {\n  display: block;\n  visibility: hidden;\n  opacity: 0;\n  /* transition */\n  -webkit-transition: visibility 1s, opacity 1s;\n  -moz-transition: visibility 1s, opacity 1s;\n  -o-transition: visibility 1s, opacity 1s;\n  transition: visibility 1s, opacity 1s;\n}\n.vjs-default-skin.vjs-controls-disabled .vjs-control-bar {\n  display: none;\n}\n.vjs-default-skin.vjs-using-native-controls .vjs-control-bar {\n  display: none;\n}\n/* The control bar shouldn't show after an error */\n.vjs-default-skin.vjs-error .vjs-control-bar {\n  display: none;\n}\n/* Don't hide the control bar if it's audio */\n.vjs-audio.vjs-default-skin.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar {\n  opacity: 1;\n  visibility: visible;\n}\n/* IE8 is flakey with fonts, and you have to change the actual content to force\nfonts to show/hide properly.\n  - \"\\9\" IE8 hack didn't work for this\n  - Found in XP IE8 from http://modern.ie. Does not show up in \"IE8 mode\" in IE9\n*/\n@media \\0screen {\n  .vjs-default-skin.vjs-user-inactive.vjs-playing .vjs-control-bar :before {\n    content: \"\";\n  }\n}\n/* General styles for individual controls. */\n.vjs-default-skin .vjs-control {\n  outline: none;\n  position: relative;\n  float: left;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n  height: 3.0em;\n  width: 4em;\n}\n/* Font button icons */\n.vjs-default-skin .vjs-control:before {\n  font-family: VideoJS;\n  font-size: 1.5em;\n  line-height: 2;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);\n}\n/* Replacement for focus outline */\n.vjs-default-skin .vjs-control:focus:before,\n.vjs-default-skin .vjs-control:hover:before {\n  text-shadow: 0em 0em 1em #ffffff;\n}\n.vjs-default-skin .vjs-control:focus {\n  /*  outline: 0; */\n  /* keyboard-only users cannot see the focus on several of the UI elements when\n  this is set to 0 */\n}\n/* Hide control text visually, but have it available for screenreaders */\n.vjs-default-skin .vjs-control-text {\n  /* hide-visually */\n  border: 0;\n  clip: rect(0 0 0 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n/* Play/Pause\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-play-control {\n  width: 5em;\n  cursor: pointer;\n}\n.vjs-default-skin .vjs-play-control:before {\n  content: \"\\e001\";\n}\n.vjs-default-skin.vjs-playing .vjs-play-control:before {\n  content: \"\\e002\";\n}\n/* Playback toggle\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-playback-rate .vjs-playback-rate-value {\n  font-size: 1.5em;\n  line-height: 2;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);\n}\n.vjs-default-skin .vjs-playback-rate.vjs-menu-button .vjs-menu .vjs-menu-content {\n  width: 4em;\n  left: -2em;\n  list-style: none;\n}\n/* Volume/Mute\n-------------------------------------------------------------------------------- */\n.vjs-default-skin .vjs-mute-control,\n.vjs-default-skin .vjs-volume-menu-button {\n  cursor: pointer;\n  float: right;\n}\n.vjs-default-skin .vjs-mute-control:before,\n.vjs-default-skin .vjs-volume-menu-button:before {\n  content: \"\\e006\";\n}\n.vjs-default-skin .vjs-mute-control.vjs-vol-0:before,\n.vjs-default-skin .vjs-volume-menu-button.vjs-vol-0:before {\n  content: \"\\e003\";\n}\n.vjs-default-skin .vjs-mute-control.vjs-vol-1:before,\n.vjs-default-skin .vjs-volume-menu-button.vjs-vol-1:before {\n  content: \"\\e004\";\n}\n.vjs-default-skin .vjs-mute-control.vjs-vol-2:before,\n.vjs-default-skin .vjs-volume-menu-button.vjs-vol-2:before {\n  content: \"\\e005\";\n}\n.vjs-default-skin .vjs-volume-control {\n  width: 5em;\n  float: right;\n}\n.vjs-default-skin .vjs-volume-bar {\n  width: 5em;\n  height: 0.6em;\n  margin: 1.1em auto 0;\n}\n.vjs-default-skin .vjs-volume-level {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 0.5em;\n  /* assuming volume starts at 1.0 */\n  width: 100%;\n  background: #66A8CC url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGCAYAAADgzO9IAAAAP0lEQVQIHWWMAQoAIAgDR/QJ/Ub//04+w7ZICBwcOg5FZi5iBB82AGzixEglJrd4TVK5XUJpskSTEvpdFzX9AB2pGziSQcvAAAAAAElFTkSuQmCC) -50% 0 repeat;\n}\n.vjs-default-skin .vjs-volume-bar .vjs-volume-handle {\n  width: 0.5em;\n  height: 0.5em;\n  /* Assumes volume starts at 1.0. If you change the size of the\n     handle relative to the volume bar, you'll need to update this value\n     too. */\n  left: 4.5em;\n}\n.vjs-default-skin .vjs-volume-handle:before {\n  font-size: 0.9em;\n  top: -0.2em;\n  left: -0.2em;\n  width: 1em;\n  height: 1em;\n}\n/* The volume menu button is like menu buttons (captions/subtitles) but works\n    a little differently. It needs to be possible to tab to the volume slider\n    without hitting space bar on the menu button. To do this we're not using\n    display:none to hide the slider menu by default, and instead setting the\n    width and height to zero. */\n.vjs-default-skin .vjs-volume-menu-button .vjs-menu {\n  display: block;\n  width: 0;\n  height: 0;\n  border-top-color: transparent;\n}\n.vjs-default-skin .vjs-volume-menu-button .vjs-menu .vjs-menu-content {\n  height: 0;\n  width: 0;\n}\n.vjs-default-skin .vjs-volume-menu-button:hover .vjs-menu,\n.vjs-default-skin .vjs-volume-menu-button .vjs-menu.vjs-lock-showing {\n  border-top-color: rgba(7, 40, 50, 0.5);\n  /* Same as ul background */\n}\n.vjs-default-skin .vjs-volume-menu-button:hover .vjs-menu .vjs-menu-content,\n.vjs-default-skin .vjs-volume-menu-button .vjs-menu.vjs-lock-showing .vjs-menu-content {\n  height: 2.9em;\n  width: 10em;\n}\n/* Progress\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-progress-control {\n  position: absolute;\n  left: 0;\n  right: 0;\n  width: auto;\n  font-size: 0.3em;\n  height: 1.2em;\n  /* Increase default height of progress bar by a decision for VIDLA-1692 */\n  /* Set above the rest of the controls. */\n  top: -1em;\n  /* Shrink the bar slower than it grows. */\n  /* transition */\n  -webkit-transition: all 0.4s;\n  -moz-transition: all 0.4s;\n  -o-transition: all 0.4s;\n  transition: all 0.4s;\n}\n/* On hover, make the progress bar grow to something that's more clickable.\n    This simply changes the overall font for the progress bar, and this\n    updates both the em-based widths and heights, as wells as the icon font */\n.vjs-default-skin:hover .vjs-progress-control {\n  /* commented out by a decision for VIDLA-1692 */\n  /* font-size: .9em; */\n  /* Even though we're not changing the top/height, we need to include them in\n      the transition so they're handled correctly. */\n  /* .transition(all 0.2s);  */\n}\n/* Box containing play and load progresses. Also acts as seek scrubber. */\n.vjs-default-skin .vjs-progress-holder {\n  height: 100%;\n}\n/* Progress Bars */\n.vjs-default-skin .vjs-progress-holder .vjs-play-progress,\n.vjs-default-skin .vjs-progress-holder .vjs-load-progress,\n.vjs-default-skin .vjs-progress-holder .vjs-load-progress div {\n  position: absolute;\n  display: block;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  /* updated by javascript during playback */\n  width: 0;\n  /* Needed for IE6 */\n  left: 0;\n  top: 0;\n}\n.vjs-default-skin .vjs-play-progress {\n  /*\n    Using a data URI to create the white diagonal lines with a transparent\n      background. Surprisingly works in IE8.\n      Created using http://www.patternify.com\n    Changing the first color value will change the bar color.\n    Also using a paralax effect to make the lines move backwards.\n      The -50% left position makes that happen.\n  */\n  background: #66A8CC url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGCAYAAADgzO9IAAAAP0lEQVQIHWWMAQoAIAgDR/QJ/Ub//04+w7ZICBwcOg5FZi5iBB82AGzixEglJrd4TVK5XUJpskSTEvpdFzX9AB2pGziSQcvAAAAAAElFTkSuQmCC) -50% 0 repeat;\n}\n.vjs-default-skin .vjs-load-progress {\n  background: #646464 /* IE8- Fallback */;\n  background: rgba(255, 255, 255, 0.2);\n}\n/* there are child elements of the load progress bar that represent the\n   specific time ranges that have been buffered */\n.vjs-default-skin .vjs-load-progress div {\n  background: #787878 /* IE8- Fallback */;\n  background: rgba(255, 255, 255, 0.1);\n}\n.vjs-default-skin .vjs-seek-handle {\n  width: 1.5em;\n  height: 100%;\n}\n.vjs-default-skin .vjs-seek-handle:before {\n  padding-top: 0.1em /* Minor adjustment */;\n}\n/* Live Mode\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin.vjs-live .vjs-time-controls,\n.vjs-default-skin.vjs-live .vjs-time-divider,\n.vjs-default-skin.vjs-live .vjs-progress-control {\n  display: none;\n}\n.vjs-default-skin.vjs-live .vjs-live-display {\n  display: block;\n}\n/* Live Display\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-live-display {\n  display: none;\n  font-size: 1em;\n  line-height: 3em;\n}\n/* Time Display\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-time-controls {\n  font-size: 1em;\n  /* Align vertically by making the line height the same as the control bar */\n  line-height: 3em;\n}\n.vjs-default-skin .vjs-current-time {\n  float: left;\n}\n.vjs-default-skin .vjs-duration {\n  float: left;\n}\n/* Remaining time is in the HTML, but not included in default design */\n.vjs-default-skin .vjs-remaining-time {\n  display: none;\n  float: left;\n}\n.vjs-time-divider {\n  float: left;\n  line-height: 3em;\n}\n/* Fullscreen\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-fullscreen-control {\n  width: 3.8em;\n  cursor: pointer;\n  float: right;\n}\n.vjs-default-skin .vjs-fullscreen-control:before {\n  content: \"\\e000\";\n}\n/* Switch to the exit icon when the player is in fullscreen */\n.vjs-default-skin.vjs-fullscreen .vjs-fullscreen-control:before {\n  content: \"\\e00b\";\n}\n/* Big Play Button (play button at start)\n--------------------------------------------------------------------------------\nPositioning of the play button in the center or other corners can be done more\neasily in the skin designer. http://designer.videojs.com/\n*/\n.vjs-default-skin .vjs-big-play-button {\n  left: 0.5em;\n  top: 0.5em;\n  font-size: 3em;\n  display: block;\n  z-index: 2;\n  position: absolute;\n  width: 4em;\n  height: 2.6em;\n  text-align: center;\n  vertical-align: middle;\n  cursor: pointer;\n  opacity: 1;\n  /* Need a slightly gray bg so it can be seen on black backgrounds */\n  /* background-color-with-alpha */\n  background-color: #07141E;\n  background-color: rgba(7, 20, 30, 0.7);\n  border: 0.1em solid #3b4249;\n  /* border-radius */\n  -webkit-border-radius: 0.8em;\n  -moz-border-radius: 0.8em;\n  border-radius: 0.8em;\n  /* box-shadow */\n  -webkit-box-shadow: 0px 0px 1em rgba(255, 255, 255, 0.25);\n  -moz-box-shadow: 0px 0px 1em rgba(255, 255, 255, 0.25);\n  box-shadow: 0px 0px 1em rgba(255, 255, 255, 0.25);\n  /* transition */\n  -webkit-transition: all 0.4s;\n  -moz-transition: all 0.4s;\n  -o-transition: all 0.4s;\n  transition: all 0.4s;\n}\n/* Optionally center */\n.vjs-default-skin.vjs-big-play-centered .vjs-big-play-button {\n  /* Center it horizontally */\n  left: 50%;\n  margin-left: -2.1em;\n  /* Center it vertically */\n  top: 50%;\n  margin-top: -1.4em;\n}\n/* Hide if controls are disabled */\n.vjs-default-skin.vjs-controls-disabled .vjs-big-play-button {\n  display: none;\n}\n/* Hide when video starts playing */\n.vjs-default-skin.vjs-has-started .vjs-big-play-button {\n  display: none;\n}\n/* Hide on mobile devices. Remove when we stop using native controls\n    by default on mobile  */\n.vjs-default-skin.vjs-using-native-controls .vjs-big-play-button {\n  display: none;\n}\n.vjs-default-skin:hover .vjs-big-play-button,\n.vjs-default-skin .vjs-big-play-button:focus {\n  outline: 0;\n  border-color: #fff;\n  /* IE8 needs a non-glow hover state */\n  background-color: #505050;\n  background-color: rgba(50, 50, 50, 0.75);\n  /* box-shadow */\n  -webkit-box-shadow: 0 0 3em #fff;\n  -moz-box-shadow: 0 0 3em #fff;\n  box-shadow: 0 0 3em #fff;\n  /* transition */\n  -webkit-transition: all 0s;\n  -moz-transition: all 0s;\n  -o-transition: all 0s;\n  transition: all 0s;\n}\n.vjs-default-skin .vjs-big-play-button:before {\n  content: \"\\e001\";\n  font-family: VideoJS;\n  /* In order to center the play icon vertically we need to set the line height\n     to the same as the button height */\n  line-height: 2.6em;\n  text-shadow: 0.05em 0.05em 0.1em #000;\n  text-align: center /* Needed for IE8 */;\n  position: absolute;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.vjs-error .vjs-big-play-button {\n  display: none;\n}\n/* Error Display\n--------------------------------------------------------------------------------\n*/\n.vjs-error-display {\n  display: none;\n}\n.vjs-error .vjs-error-display {\n  display: block;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n.vjs-error .vjs-error-display:before {\n  content: 'X';\n  font-family: Arial;\n  font-size: 4em;\n  color: #666666;\n  /* In order to center the play icon vertically we need to set the line height\n     to the same as the button height */\n  line-height: 1;\n  text-shadow: 0.05em 0.05em 0.1em #000;\n  text-align: center /* Needed for IE8 */;\n  vertical-align: middle;\n  position: absolute;\n  left: 0;\n  top: 50%;\n  margin-top: -0.5em;\n  width: 100%;\n}\n.vjs-error-display div {\n  position: absolute;\n  bottom: 1em;\n  right: 0;\n  left: 0;\n  font-size: 1.4em;\n  text-align: center;\n  padding: 3px;\n  background: #000000;\n  background: rgba(0, 0, 0, 0.5);\n}\n.vjs-error-display a,\n.vjs-error-display a:visited {\n  color: #F4A460;\n}\n/* Loading Spinner\n--------------------------------------------------------------------------------\n*/\n.vjs-loading-spinner {\n  /* Should be hidden by default */\n  display: none;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  font-size: 4em;\n  line-height: 1;\n  width: 1em;\n  height: 1em;\n  margin-left: -0.5em;\n  margin-top: -0.5em;\n  opacity: 0.75;\n}\n/* Show the spinner when waiting for data and seeking to a new time */\n.vjs-waiting .vjs-loading-spinner,\n.vjs-seeking .vjs-loading-spinner {\n  display: block;\n  /* only animate when showing because it can be processor heavy */\n  /* animation */\n  -webkit-animation: spin 1.5s infinite linear;\n  -moz-animation: spin 1.5s infinite linear;\n  -o-animation: spin 1.5s infinite linear;\n  animation: spin 1.5s infinite linear;\n}\n/* Errors are unrecoverable without user interaction so hide the spinner */\n.vjs-error .vjs-loading-spinner {\n  display: none;\n  /* ensure animation doesn't continue while hidden */\n  /* animation */\n  -webkit-animation: none;\n  -moz-animation: none;\n  -o-animation: none;\n  animation: none;\n}\n.vjs-default-skin .vjs-loading-spinner:before {\n  content: \"\\e01e\";\n  font-family: VideoJS;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 1em;\n  height: 1em;\n  text-align: center;\n  text-shadow: 0em 0em 0.1em #000;\n}\n@-moz-keyframes spin {\n  0% {\n    -moz-transform: rotate(0deg);\n  }\n  100% {\n    -moz-transform: rotate(359deg);\n  }\n}\n@-webkit-keyframes spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(359deg);\n  }\n}\n@-o-keyframes spin {\n  0% {\n    -o-transform: rotate(0deg);\n  }\n  100% {\n    -o-transform: rotate(359deg);\n  }\n}\n@keyframes spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(359deg);\n  }\n}\n/* Menu Buttons (Captions/Subtitles/etc.)\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-menu-button {\n  float: right;\n  cursor: pointer;\n}\n.vjs-default-skin .vjs-menu {\n  display: none;\n  position: absolute;\n  bottom: 0;\n  left: 0em;\n  /* (Width of vjs-menu - width of button) / 2 */\n  width: 0em;\n  height: 0em;\n  margin-bottom: 3em;\n  border-left: 2em solid transparent;\n  border-right: 2em solid transparent;\n  border-top: 1.55em solid #000000;\n  /* Same width top as ul bottom */\n  border-top-color: rgba(7, 40, 50, 0.5);\n  /* Same as ul background */\n}\n/* Button Pop-up Menu */\n.vjs-default-skin .vjs-menu-button .vjs-menu .vjs-menu-content {\n  display: block;\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  width: 10em;\n  bottom: 1.5em;\n  /* Same bottom as vjs-menu border-top */\n  max-height: 15em;\n  overflow: auto;\n  left: -5em;\n  /* Width of menu - width of button / 2 */\n  /* background-color-with-alpha */\n  background-color: #07141E;\n  background-color: rgba(7, 20, 30, 0.7);\n  /* box-shadow */\n  -webkit-box-shadow: -0.2em -0.2em 0.3em rgba(255, 255, 255, 0.2);\n  -moz-box-shadow: -0.2em -0.2em 0.3em rgba(255, 255, 255, 0.2);\n  box-shadow: -0.2em -0.2em 0.3em rgba(255, 255, 255, 0.2);\n}\n.vjs-default-skin .vjs-menu-button:hover .vjs-control-content .vjs-menu,\n.vjs-default-skin .vjs-control-content .vjs-menu.vjs-lock-showing {\n  display: block;\n}\n/* prevent menus from opening while scrubbing (FF, IE) */\n.vjs-default-skin.vjs-scrubbing .vjs-menu-button:hover .vjs-control-content .vjs-menu {\n  display: none;\n}\n.vjs-default-skin .vjs-menu-button ul li {\n  list-style: none;\n  margin: 0;\n  padding: 0.3em 0 0.3em 0;\n  line-height: 1.4em;\n  font-size: 1.2em;\n  text-align: center;\n  text-transform: lowercase;\n}\n.vjs-default-skin .vjs-menu-button ul li.vjs-selected {\n  background-color: #000;\n}\n.vjs-default-skin .vjs-menu-button ul li:focus,\n.vjs-default-skin .vjs-menu-button ul li:hover,\n.vjs-default-skin .vjs-menu-button ul li.vjs-selected:focus,\n.vjs-default-skin .vjs-menu-button ul li.vjs-selected:hover {\n  outline: 0;\n  color: #111;\n  /* background-color-with-alpha */\n  background-color: #ffffff;\n  background-color: rgba(255, 255, 255, 0.75);\n  /* box-shadow */\n  -webkit-box-shadow: 0 0 1em #ffffff;\n  -moz-box-shadow: 0 0 1em #ffffff;\n  box-shadow: 0 0 1em #ffffff;\n}\n.vjs-default-skin .vjs-menu-button ul li.vjs-menu-title {\n  text-align: center;\n  text-transform: uppercase;\n  font-size: 1em;\n  line-height: 2em;\n  padding: 0;\n  margin: 0 0 0.3em 0;\n  font-weight: bold;\n  cursor: default;\n}\n/* Subtitles Button */\n.vjs-default-skin .vjs-subtitles-button:before {\n  content: \"\\e00c\";\n}\n/* Captions Button */\n.vjs-default-skin .vjs-captions-button:before {\n  content: \"\\e008\";\n}\n/* Chapters Button */\n.vjs-default-skin .vjs-chapters-button:before {\n  content: \"\\e00c\";\n}\n.vjs-default-skin .vjs-chapters-button.vjs-menu-button .vjs-menu .vjs-menu-content {\n  width: 24em;\n  left: -12em;\n}\n/* Replacement for focus outline */\n.vjs-default-skin .vjs-captions-button:focus .vjs-control-content:before,\n.vjs-default-skin .vjs-captions-button:hover .vjs-control-content:before {\n  /* box-shadow */\n  -webkit-box-shadow: 0 0 1em #ffffff;\n  -moz-box-shadow: 0 0 1em #ffffff;\n  box-shadow: 0 0 1em #ffffff;\n}\n/*\nREQUIRED STYLES (be careful overriding)\n================================================================================\nWhen loading the player, the video tag is replaced with a DIV,\nthat will hold the video tag or object tag for other playback methods.\nThe div contains the video playback element (Flash or HTML5) and controls,\nand sets the width and height of the video.\n\n** If you want to add some kind of border/padding (e.g. a frame), or special\npositioning, use another containing element. Otherwise you risk messing up\ncontrol positioning and full window mode. **\n*/\n.video-js {\n  background-color: #000;\n  position: relative;\n  padding: 0;\n  /* Start with 10px for base font size so other dimensions can be em based and\n     easily calculable. */\n  font-size: 10px;\n  /* Allow poster to be vertically aligned. */\n  vertical-align: middle;\n  /*  display: table-cell; */\n  /*This works in Safari but not Firefox.*/\n  /* Provide some basic defaults for fonts */\n  font-weight: normal;\n  font-style: normal;\n  /* Avoiding helvetica: issue #376 */\n  font-family: Arial, sans-serif;\n  /* Turn off user selection (text highlighting) by default.\n     The majority of player components will not be text blocks.\n     Text areas will need to turn user selection back on. */\n  /* user-select */\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n/* Playback technology elements expand to the width/height of the containing div\n    <video> or <object> */\n.video-js .vjs-tech {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n/* Fix for Firefox 9 fullscreen (only if it is enabled). Not needed when\n   checking fullScreenEnabled. */\n.video-js:-moz-full-screen {\n  position: absolute;\n}\n/* Fullscreen Styles */\nbody.vjs-full-window {\n  padding: 0;\n  margin: 0;\n  height: 100%;\n  /* Fix for IE6 full-window. http://www.cssplay.co.uk/layouts/fixed.html */\n  overflow-y: auto;\n}\n.video-js.vjs-fullscreen {\n  position: fixed;\n  overflow: hidden;\n  z-index: 1000;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  width: 100% !important;\n  height: 100% !important;\n  /* IE6 full-window (underscore hack) */\n  _position: absolute;\n}\n.video-js:-webkit-full-screen {\n  width: 100% !important;\n  height: 100% !important;\n}\n.video-js.vjs-fullscreen.vjs-user-inactive {\n  cursor: none;\n}\n/* Poster Styles */\n.vjs-poster {\n  background-repeat: no-repeat;\n  background-position: 50% 50%;\n  background-size: contain;\n  background-color: #000000;\n  cursor: pointer;\n  margin: 0;\n  padding: 0;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vjs-poster img {\n  display: block;\n  margin: 0 auto;\n  max-height: 100%;\n  padding: 0;\n  width: 100%;\n}\n/* Hide the poster after the video has started playing */\n.video-js.vjs-has-started .vjs-poster {\n  display: none;\n}\n/* Don't hide the poster if we're playing audio */\n.video-js.vjs-audio.vjs-has-started .vjs-poster {\n  display: block;\n}\n/* Hide the poster when controls are disabled because it's clickable\n    and the native poster can take over */\n.video-js.vjs-controls-disabled .vjs-poster {\n  display: none;\n}\n/* Hide the poster when native controls are used otherwise it covers them */\n.video-js.vjs-using-native-controls .vjs-poster {\n  display: none;\n}\n/* Text Track Styles */\n/* Overall track holder for both captions and subtitles */\n.video-js .vjs-text-track-display {\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 3em;\n  right: 0;\n  pointer-events: none;\n}\n/* Captions Settings Dialog */\n.vjs-caption-settings {\n  position: relative;\n  top: 1em;\n  background-color: #000;\n  opacity: 0.75;\n  color: #FFF;\n  margin: 0 auto;\n  padding: 0.5em;\n  height: 15em;\n  font-family: Arial, Helvetica, sans-serif;\n  font-size: 12px;\n  width: 40em;\n}\n.vjs-caption-settings .vjs-tracksettings {\n  top: 0;\n  bottom: 2em;\n  left: 0;\n  right: 0;\n  position: absolute;\n  overflow: auto;\n}\n.vjs-caption-settings .vjs-tracksettings-colors,\n.vjs-caption-settings .vjs-tracksettings-font {\n  float: left;\n}\n.vjs-caption-settings .vjs-tracksettings-colors:after,\n.vjs-caption-settings .vjs-tracksettings-font:after,\n.vjs-caption-settings .vjs-tracksettings-controls:after {\n  clear: both;\n}\n.vjs-caption-settings .vjs-tracksettings-controls {\n  position: absolute;\n  bottom: 1em;\n  right: 1em;\n}\n.vjs-caption-settings .vjs-tracksetting {\n  margin: 5px;\n  padding: 3px;\n  min-height: 40px;\n}\n.vjs-caption-settings .vjs-tracksetting label {\n  display: block;\n  width: 100px;\n  margin-bottom: 5px;\n}\n.vjs-caption-settings .vjs-tracksetting span {\n  display: inline;\n  margin-left: 5px;\n}\n.vjs-caption-settings .vjs-tracksetting > div {\n  margin-bottom: 5px;\n  min-height: 20px;\n}\n.vjs-caption-settings .vjs-tracksetting > div:last-child {\n  margin-bottom: 0;\n  padding-bottom: 0;\n  min-height: 0;\n}\n.vjs-caption-settings label > input {\n  margin-right: 10px;\n}\n.vjs-caption-settings input[type=\"button\"] {\n  width: 40px;\n  height: 40px;\n}\n/* Hide disabled or unsupported controls */\n.vjs-hidden {\n  display: none !important;\n}\n.vjs-lock-showing {\n  display: block !important;\n  opacity: 1;\n  visibility: visible;\n}\n/*  In IE8 w/ no JavaScript (no HTML5 shim), the video tag doesn't register.\n    The .video-js classname on the video tag also isn't considered.\n    This optional paragraph inside the video tag can provide a message to users\n    about what's required to play video. */\n.vjs-no-js {\n  padding: 2em;\n  color: #ccc;\n  background-color: #333;\n  font-size: 1.8em;\n  font-family: Arial, sans-serif;\n  text-align: center;\n  width: 30em;\n  height: 15em;\n  margin: 0 auto;\n}\n.vjs-no-js a,\n.vjs-no-js a:visited {\n  color: #F4A460;\n}\n/* -----------------------------------------------------------------------------\nThe original source of this file lives at\nhttps://github.com/videojs/video.js/blob/master/src/css/video-js.less */\n"

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Appnexus Viewability Wrapper for core video framework
	 */

	var ANVideoViewabilityTracker = __webpack_require__(50);//appnexus viewability library
	var prefixOfLog = "[PlayerManager_ANVideoViewabilityTracker]";
	var APN_Logger = __webpack_require__(9);
	var debug = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};
	var info = function (message) {
	    APN_Logger.info(prefixOfLog, message);
	};

	var html5VideoViewability = function () {

	    var tracker = null;
	    var mappedActions = {
	        "video_start": "start",
	        "expand": "expand",
	        "collapse": "collapse",
	        "video_unmute": "sound_on",
	        "video_mute": "sound_off",
	        "video_pause": "pause",
	        "video_resume": "resume",
	        "ad-click": "click",
	        "video_skip": "stop",
	        "video_complete": "stop",
	        "fullscreen": "fullscreen",
	        "exitFullscreen": "exitFullscreen"
	    };

	    var fireOnceEvents = {
	        "video_start": false,
	        "video_skip": false,
	        "video_complete": false
	    };

	    var cbNotification, cbTarget;

	    var getConfig = function (options_) {
	        return options_ && options_.viewability && options_.viewability.config;
	    };

	    var getPlayerDOMElement = function (options_) {
	        return options_.targetElement;
	    };

	    var getVideoInfo = function (duration, width, height) {
	        return {duration: duration, w: width, h: height};
	    };

		// return a string that reflect the context in which the viewability is executed
		// Setting this value will make the viewability measurement active only if the
		// viewability config contains a vid_context key matching a known value
	    // (anoutstream for outstream).
		var getContext = function (options_) {
	        if( options_ ){
	    		return options_.playerContextId;
	        }
	    };

		// Using callback for logs helps getting a right logger in each app
		var loggerCallback = function (_level, _message) {
	        if (cbNotification && _message) {
	            // Extract event name from message (if any, only logs for events get passed on to cbNotification)
	            var evtName = /notifyEvent.*\[(.[^\]]+)\]/.exec(_message);
	            if (Array.isArray(evtName) && evtName.length > 1) {
	                evtName = evtName[1];
	            } else {
	                evtName = null;
	            }
	            if (evtName) {
	                cbNotification('VIEW', evtName, cbTarget, _message);
	            }
	        }
			if (_level && _level === "debug") {
				debug(_message);
			} else {
				info(_message);
			}
	    };

	    this.init = function (options_, duration, width, height, checkEventToStartViewability) {
	        info("initialize with duration: " + duration + ", width: " + width + ", height: " + height + ", event: " + checkEventToStartViewability);
	        if (options_) {
	            cbNotification = options_.cbNotification;
	            cbTarget = options_.ASTadId;
	        }
	        try {
	            tracker = new ANVideoViewabilityTracker(
					getConfig(options_),
	                getPlayerDOMElement(options_),
	                getVideoInfo(duration, width, height), // The duration of the video ad
					getContext(options_),
					loggerCallback
	            );
	            this.isReady = true;
	        } catch (ex) {
	            debug("error on viewability library: ");
	            debug(ex);
	        }

	    };

	    this.invokeEvent = function (event_) {
	        if (event_ && mappedActions[event_]) {
	            try {
	                // VIDLA-1513 Ensure firing of specific viewability events only once.
	                if(fireOnceEvents.hasOwnProperty(event_)){
	                    if(fireOnceEvents[event_]){
	                        info("supressing fireOnceEvents event as it is already fired once by viewability library: " + mappedActions[event_]);
	                        return;
	                    } else{
	                        fireOnceEvents[event_] = true; // mark that the event has been fired.
	                    }
	                }
	                info("event invoked by viewability library: " + mappedActions[event_]);
	                tracker.notifyEvent(mappedActions[event_]);
	            } catch (ex) {
	                debug("error on viewability library: ");
	                debug(ex);
	            }
	        }
	    };

	    this.isReady = false;


	};


	module.exports = html5VideoViewability;

/***/ }),
/* 50 */
/***/ (function(module, exports) {

	/**
	 * @namespace ANVideoViewabilityTracker
	 */

	/**
	 * Video Viewability module - Acts as a proxy the CDN based viewability script
	 **/

	/**
	 * @typedef {string} LOG_LEVEL
	 **/
	/**
	 * @enum {LOG_LEVEL}
	 **/
	var LOG_LEVEL = {
		DEBUG: "debug",
		INFO: "info",
		ERROR: "error"
	};

	/**
	 * @typedef {number} errorCode
	 **/
	/**
	 * @enum {errorCode}
	 **/
	var ERROR_CODE = {
		NO_VIEWABILITY_DATA: 100,
		MISSING_MANDATORY_PARAMETER_JS: 101,
		FAILED_TO_LOAD_VIEWABILITY_JS: 102,
		INITIALIZATION_FAILED: 103,
		MISSING_MANDATORY_PARAMETER_CB: 104,
		MISSING_MANDATORY_PARAMETER_RDCB: 105,
		MISSING_MANDATORY_PARAMETER_VC: 106

	};

	/**
	 * Callback used to receive logs emits from the library
	 * @callback loggerCallback
	 * @param {LOG_LEVEL} level the level/severity of the log info|debug|error
	 * @param {string} message emitted message content to log
	 **/

	/**
	 * Callback used to receive errors emits from the library
	 * @callback errorCallback
	 * @param {errorCode} code associated error code
	 * @param {string} message human readable error message
	 **/

	/**
	 * Video Viewability module - Acts as a proxy the CDN based viewability script
	 * @param {string} _viewabilityPayload   the string containing all viewability parameters
	 * @param {string} _domElt the ID of the object to measure
	 * @param {Object} _videoInfos the object containing video attributes
	 * @param {string} _contextKey an optional config. If set, it will be compared to the value provided in the _viewabilityPayload, and avoid measurement if not equals. ex: outstream
	 * @param {loggerCallback} [_loggerCallback] - an optional callback used to forward log from library
	 * @param {errorCallback} [_errorCallback] - an optional callback used to forward errors from library
	 **/

	var ANVideoViewabilityTracker = function (_viewabilityPayload, _domElt, _videoInfos, _contextKey, _loggerCallback, _errorCallback) {
		"use strict";
		this.contextKey = _contextKey;
		if (_loggerCallback) {
			this.loggerCallback = _loggerCallback;
		}
		if (_errorCallback) {
			this.errorCallback = _errorCallback;
		}
		this.adUID = "WR_" + new Date().getTime() + Math.round(Math.random() * 1000);

		// result of contextKey matching, disable any viewability measurement feature if false
		this.viewabilityMeasurementActive = true;

		// Get object with Viewability Payload
		this.viewabilityData = this.decodePayload(_viewabilityPayload);
		if (!this.viewabilityData) {
			// null is used as error indicator.
			// We expect low-layer already send [precise] error, so do not send again here
			this.viewabilityMeasurementActive = false;
			return;
		}

		// Check if contextKey is set
		if (this.contextKey && this.contextKey !== "") {
			// Check if a contextKey is provided in the viewability paylaod
			// Considering the viewability config can contain multiple values in the the contextKey, ex: outstream|overlay
			this.log(LOG_LEVEL.INFO, "contextKey is set in this app, checking contextKey in viewability config");

			if (!this.viewabilityData.hasOwnProperty("contextKey") || this.viewabilityData.contextKey.indexOf(this.contextKey) === -1) {
				// contextKey doesn't match, viewability measurement is disabled
				this.log(LOG_LEVEL.INFO, "contextKey doesn't match, disabling viewability measurement");
				this.viewabilityMeasurementActive = false;
				return;
			}
		}

		// identify document and window of the iframe where the script must be installed
		// get the id of the dom element to analyse (entry could be the id or a dom element)
		var domId = "";
		try {
			if (typeof _domElt === "object") {
				// try to get document form domElt first, if fail, no id will be set
				this.videoNodeDocument = _domElt.ownerDocument;
				this.videoNodeWindow = this.videoNodeDocument.defaultView || this.videoNodeDocument.videoNodeWindow;

				// if dom Element haven't id, set a default
				if (_domElt.id === "") {
					_domElt.id = "an_video_" + this.adUID;
				}
				domId = _domElt.id;
			} else {
				domId = _domElt;
				this.videoNodeDocument = document;
				this.videoNodeWindow = window;
			}
		} catch (e) {
			this.videoNodeDocument = document;
			this.videoNodeWindow = window;
		}

		// Get object containing duration, dimension and position
		this.videoInfo = this.decodeVideoInfos(_videoInfos);

		this.log(LOG_LEVEL.INFO, "ANVideoViewabilityTracker start with parameters  \n" +
			"DomID:\t\t[" + domId + "]\n" +
			"adUID:\t\t[" + this.adUID + "]\n" +
			"Duration:\t[" + this.videoInfo.duration + "]\n" +
			"Payload:\t" + _viewabilityPayload + "\n\n" +
			"Dimension:\t(" + this.videoInfo.w + "," + this.videoInfo.h + ")\n" +
			"Position:\t(" + this.videoInfo.x + "," + this.videoInfo.y + ")"
		);

		try {
			// Create temporary cache, used to store API calls until the viewability script is loaded
			if (typeof this.videoNodeWindow.anxVVAPICache === 'undefined') {
				this.videoNodeWindow.anxVVAPICache = {
					events: Array(),
					init: Array()
				};

				// Injects the viewability script in the page
				var scriptElement = this.videoNodeDocument.createElement('script');
				scriptElement.type = 'text/javascript';
				scriptElement.async = true;
				scriptElement.src = this.viewabilityData.vjs;

				// set handler callbacks for JS loading
				if (scriptElement.readyState) { //IE
					scriptElement.onreadystatechange = function () {
						if (scriptElement.readyState == "loaded" || scriptElement.readyState == "complete") {
							scriptElement.onreadystatechange = null;
						}
					};
				}

				scriptElement.onerror = function (e) {
					this.log(LOG_LEVEL.DEBUG, "script load onerror", e);
					this.error(ERROR_CODE.FAILED_TO_LOAD_VIEWABILITY_JS, "ANVideoViewabilityTracker failed to load viewability script (" + scriptElement.src + ").");
					this.viewabilityMeasurementActive = false;
				}.bind(this);

				var head = this.videoNodeDocument.getElementsByTagName("head")[0];
				head.appendChild(scriptElement);
			}
		} catch (e) {
			this.error(ERROR_CODE.INITIALIZATION_FAILED, { message: "ANVideoViewabilityTracker initialization failed", exception: e });
		}

		// Init module version
		this.extractVersionModule(this.viewabilityData);

		// Initialize Viewability Script if present, cache informations if not
		if (typeof this.videoNodeWindow.anxVVAPI === 'undefined') {
			var createCall = {
				a: this.adUID,
				params: this.viewabilityData.viewParams,
				id: domId,
				v: this.VIEWABILITY_MODULE_VERSION,
				dur: this.videoInfo.duration,
				// Considering the video size is the player size :
				w: this.videoInfo.w,
				h: this.videoInfo.h,
				x: this.videoInfo.x,
				y: this.videoInfo.y
			};
			this.videoNodeWindow.anxVVAPICache.init.push(createCall);
		} else {
			this.videoNodeWindow.anxVVAPI.initializeFromParams(
				this.viewabilityData.viewParams,
				domId,
				this.adUID,
				this.VIEWABILITY_MODULE_VERSION,
				this.videoInfo.duration,
				this.videoInfo.w,
				this.videoInfo.h,
				this.videoInfo.x,
				this.videoInfo.y
			);
		}
	};


	ANVideoViewabilityTracker.prototype = {
		// This module version
		VIEWABILITY_MODULE_VERSION: 1,
		// Default logger/error callback are empty
		loggerCallback: null,
		errorCallback: null,

		log: function (_level, _message) {
			"use strict";
			if (this.loggerCallback) {
				try {
					this.loggerCallback(_level, _message);
				} catch (e) {
					// logging is disabled
					console.trace(e);
				}
			}
		},
		error: function (_code, _message) {
			"use strict";
			if (this.errorCallback) {
				try {
					this.errorCallback(_code, _message);
				} catch (e) {
					// logging is disabled
					console.trace(e);
				}
			} else {
				this.log(LOG_LEVEL.ERROR, "ERR-" + _code + ": " + _message);
			}
		},
		//Sound Tracking
		lastKnownVolume: -1,

		// Internal parsing
		parseUrl: function (_url) {
			"use strict";
			var urlObject = {
				http: "",
				params: ""
			};

			try {
				if (_url && typeof _url === "string") {
					var split = _url.split(/:/);
					if (split.length === 2) {
						_url = split[1];
						urlObject.http = split[0];
					}

					split = _url.split(/\?/);
					if (split.length === 2) {
						urlObject.params = split[1];
					} else if ((urlObject.http === "" || _url.substr(0, 2) !== "//") && _url.indexOf("=") > -1) {
						urlObject.params = split[0];
					}

					if (urlObject.params !== "") {
						split = urlObject.params.split(/&/);
						urlObject.params = {};
						for (var param in split) {
							// get parameter name and value
							var keyValue = split[param].split(/=/);
							if (keyValue.length === 2) {
								urlObject.params[keyValue[0]] = decodeURIComponent(keyValue[1]);
							} else if (keyValue.length > 2) {
								var value = "";
								for (var i = 1; i < keyValue.length; i++) {
									value += "=" + keyValue[i];
								}

								urlObject.params[keyValue[0]] = decodeURIComponent(value.substr(1));
							} else {
								urlObject.params[keyValue[0]] = "";
							}
						}
					}
				}
			} catch (ex) {
				this.log(LOG_LEVEL.DEBUG, ex);
			}

			return urlObject;
		},

		// Internal parsing
		parseConfigs: function (_url) {
			"use strict";
			try {
				if (_url && typeof _url === "string") {
					if (_url.substring(0, 9) === "<![CDATA[") {
						_url = _url.substring(9, _url.length - 3);
					}
					var extracted = this.parseUrl(_url);
					if (extracted.hasOwnProperty("params") && extracted.params !== "") {
						return extracted.params;
					}
				}
			} catch (ex) {
				this.log(LOG_LEVEL.DEBUG, "Error parsing config:" + _url);
				this.log(LOG_LEVEL.DEBUG, ex);
				return;
			}
			// Return null as error indicator
			this.error(ERROR_CODE.NO_VIEWABILITY_DATA, "No viewability data provided");
			return null;
		},

		// Internal parsing
		createViewabilityConfig: function (_payload) {
			var params = [],
				key;

			var hasErrors = false;
			for (key in _payload) {
				var value = _payload[key];
				switch (key) {
				case 'cb':
					if (!value) {
						this.error(ERROR_CODE.MISSING_MANDATORY_PARAMETER_CB, "Missing mandatory parameter: " + key + ".");
						hasErrors = true;
					}
					break;

				case 'rdcb':
					if (!value) {
						this.error(ERROR_CODE.MISSING_MANDATORY_PARAMETER_RDCB, "Missing mandatory parameter: " + key + ".");
						hasErrors = true;
					}
					break;

				case 'vc':
					if (!value) {
						this.error(ERROR_CODE.MISSING_MANDATORY_PARAMETER_VC, "Missing mandatory parameter: " + key + ".");
						hasErrors = true;
					}
					// Possible values for vc:
					// vc=iab
					// vc=iab;cid=1
					// vc=iab;cid=1;samp=100
					// this will become : vc=iab&cid=1&samp=100
					var split = value.split(/;/);
					params.push("vc=" + encodeURIComponent(split[0]));

					for (var i = 1; i < split.length; i++) {
						params.push(split[i]);
					}
					continue; //nobreak
				}

				params.push(key + "=" + encodeURIComponent(value));
			}

			if (true === hasErrors) {
				return null;
			}

			params.sort();
			return params.join("&");
		},


		/**
		 * Decode data string received from the viewability API
		 * @param {string} _payload the string formated viewability config
		 * @returns {Object} validated object with configs
		 */

		decodePayload: function (_payload) {
			"use strict";
			// Object
			var config = this.parseConfigs(_payload);
			if (!config) {
				// null is used as error indicator.
				// We expect low-layer already send [precise] error, so do not send again here
				return null;
			}

			var viewParams = this.createViewabilityConfig(config);
			if (!viewParams) {
				// null is used as error indicator.
				// We expect low-layer already send [precise] error, so do not send again here
				return null;
			}
			var decodedPayload = {
				viewParams: viewParams
			};

			if (config.hasOwnProperty("vjs") && config.vjs !== "") {
				decodedPayload.vjs = config.vjs;
			} else {
				this.error(ERROR_CODE.MISSING_MANDATORY_PARAMETER_JS, "no viewability script js to load");
				this.viewabilityMeasurementActive = false;
				return null;
			}

			if (config.hasOwnProperty("vid_context")) {
				decodedPayload.contextKey = config.vid_context;
			}
			return decodedPayload;
		},

		/**
		 * Extract Ad informations (duration, dimensions and positions)
		 * @param _videoInfos {Object} the oject containing video attributes
		 */
		decodeVideoInfos: function (_videoInfos) {
			"use strict";
			var ad = { duration: 0, w: 0, h: 0, x: 0, y: 0 };

			if (typeof _videoInfos.duration === "number" || _videoInfos.duration > 0) {
				ad.duration = _videoInfos.duration;
			}
			if (typeof _videoInfos.w === "number" || _videoInfos.w > 0) {
				ad.w = _videoInfos.w;
			}
			if (typeof _videoInfos.h === "number" || _videoInfos.h > 0) {
				ad.h = _videoInfos.h;
			}
			if (typeof _videoInfos.x === "number" || _videoInfos.x > 0) {
				ad.x = _videoInfos.x;
			}
			if (typeof _videoInfos.y === "number" || _videoInfos.y > 0) {
				ad.y = _videoInfos.y;
			}

			return ad;
		},

		// Extract module version from viewability script url
		extractVersionModule: function (_viewData) {
			"use strict";


			if (_viewData) {
				var regex = /.+\/(\d+)\/trk\.js/;
				var match = regex.exec(_viewData.viewJS);
				if (match && match[1]) {
					this.VIEWABILITY_MODULE_VERSION = match[1];
				}
			}
		},

		//
		/**
		 * Pass video events to the viewability JS
		 * @param {string} _eventCode the name of the event. <br>
		 * Expected values : <br>
		 * start<br>
		 * stop<br>
		 * pause<br>
		 * resume<br>
		 * fullscreen<br>
		 * exitFullscreen<br>
		 * click<br>
		 */
		notifyEvent: function (_eventCode) {
			"use strict";

			// Avoid any action if viewability is disabled in the config
			if (!this.viewabilityMeasurementActive) {
				this.log(LOG_LEVEL.INFO, "notifyEvent cancelled because viewability is not active");
				return;
			}

			this.log(LOG_LEVEL.INFO, "notifyEvent: [" + _eventCode + "]");

			// VIDKP-1448: GroupM custom definition doesn't require soundon for Outstream
			// Forcing the sound volume to 1
			if (this.contextKey == "an_outstream" && _eventCode == "sound_off") {
				_eventCode = "sound_on";
			}

			// expand and collapse event reserved for Outstream video tag resize, not used by viewJS script
			// fullscreen and exitFullscreen be used instead to notify fullscreen activity to viewJS. These event are known as expand and collapse by viewJS
			switch (_eventCode) {
			case "fullscreen":
				_eventCode = "expand";
				break;
			case "exitFullscreen":
				_eventCode = "collapse";
				break;

				// VIDKP-701 - Avoid conflicts with Outstream
			case "expand":
			case "collapse":
				return;
			}

			var timeData = new Date().getTime();
			try {
				if (typeof this.videoNodeWindow.anxVVAPI === 'undefined') {
					var createCall = {
						a: this.adUID,
						c: _eventCode,
						d: timeData
					};
					this.videoNodeWindow.anxVVAPICache.events.push(createCall);
				} else {
					this.videoNodeWindow.anxVVAPI.notifyEvent(this.adUID, _eventCode);
				}
			} catch (e) {
				this.log(LOG_LEVEL.DEBUG, { message: "notifyEvent failed", exception: e });
			}
		},

		/**
		 * Update volume state and notify event when volume changed
		 * @param {Number} _volume the volume between 0 and 1
		 */
		onVolumeChange: function (_volume) {
			"use strict";

			// Avoid any action if viewability is disabled in the config
			if (!this.viewabilityMeasurementActive) {
				this.log(LOG_LEVEL.INFO, "onVolumeChange cancelled because viewability is not active");
				return;
			}

			if (typeof _volume !== "number") {
				return;
			}

			if (_volume > 1) {
				_volume = 1;
			}

			if (_volume < 0) {
				_volume = 0;
			}

			if (_volume !== this.lastKnownVolume) {
				if (_volume > 0) {
					this.notifyEvent("sound_on");
				} else {
					this.notifyEvent("sound_off");
				}

				this.lastKnownVolume = _volume;
			}
		}
	};

	module.exports = ANVideoViewabilityTracker;

	// export log levels and error list to be accesible outside of library
	// Following js usage: Object.defineProperty(module.exports, "LOG_LEVEL", {
	// is not yet usable due to IE8 support
	// so our 'constants' are not really contants but at least we exported them
	module.exports.LOG_LEVEL = LOG_LEVEL;
	module.exports.ERROR_CODE = ERROR_CODE;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Autoplay Handler
	 * this module supports an auto-play feature to get over limitations on mobile devices
	 *
	 * architecture diagram for this mdule : https://appnexus.slack.com/files/ksong/F3H5U82HX/androidautoplayforoutstream.pdf
	 */
	var APN_Logger = __webpack_require__(9);


	var protocol = (document.location.protocol === "https:") ? "https:" : "http:";
	var APN_MOBILE_VIDEO_PLACEMENT_ID = "apn_mobile_video_placements";//video placement id in iframes which will be used on core video framework
	var APN_MOBILE_IFRAME_NAME_PREFIX = "iframeVideoWrapper";//prefix of iframe names which will be used on core video framework
	var BLANK_VIDEO_URL = protocol + "//acdn.adnxs.com/video/static/res/b2.mp4";//2 seconds 70x70 empty video to resolve human activity for VID-1924,VID-1907,VID-1980
	var timeout = 5000;//timeout for async call

	var prefixOfLog = "[AutoplayHandler]";
	var debug = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};
	var error = function (message) {
	    APN_Logger.error(prefixOfLog, message);
	};
	var warn = function (message) {
	    APN_Logger.warn(prefixOfLog, message);
	};
	var info = function (message) {
	    APN_Logger.info(prefixOfLog, message);
	};

	var hasDoneFakingAutoStartForAndroid = false;//flag to block second execution

	var dummyVideoHavingAudio = protocol + "//acdn.adnxs.com/video/static/res/av2.mp4";
	var donePromiseCheck = {};

	var videoPlacement;

	var videoPolicy = {
	    stopMediaWithSound: 1,//browser only allows autoplay with sound off
	    neverAutoplay: 2,//browser never allow auto play
	    allowAutoplay: 3//browser allows auto play regardless sound status
	};

	var UA_Parser = __webpack_require__(13)();

	/**
	 * get iOSversion as array [major,minor,build] if it's not proper mobile safari it will returen [0,0,0]
	 * this also check iOS Chrome
	 * @returns {*}
	 */
	var iOSversion = function () {
	    var browser = "safari";
	    try {
	        var platform = navigator.platform;
	        var agent = navigator.userAgent;
	        var appVersion = navigator.appVersion;

	        if (/CriOS/.test(agent)) {
	            //do nothing, we decided to allow to use inline for iOS Chrome by VID-1464
	            browser = "chrome";
	        }
	        if (/iP(hone|od|ad)/.test(platform)) {
	            var v = (appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/);//chrome and safari both has iOS version in the user agent string (especially in appVersion)
	            return [parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10), browser];
	        } else {
	            return [0, 0, 0, browser];//return this value when it's not iOS and Mobile Safari browser
	        }
	    } catch (ex) {
	        error(ex);
	        return [0, 0, 0, browser];//return [0,0,0] if any error happens;
	    }
	};

	/**
	 * check iOS incliding phone and pad
	 * @returns {boolean}
	 */
	var isIOS = function () {
	    return (/iphone/i.test(navigator.userAgent.toLowerCase())) || (/ipad/i.test(navigator.userAgent.toLowerCase()));
	};

	/**
	 * retrieve version number of iOS Chrome
	 * @returns {number}
	 */
	var getiOSChromeVersion = function () {
	    var version = -1;
	    if (isIOS()) {
	        try {
	            var tmp = navigator.userAgent.match(/CriOS\/([0-9]+)\./);
	            if (tmp && Array.isArray(tmp) && tmp.length > 1) {
	                version = parseInt(tmp[1]);
	            }
	        } catch (ex) {
	            debug(ex);
	        }
	    }
	    return version;
	};

	/**
	 * detection logic if ad unit requires human activity to initiate adunit itself.
	 * a combination of iOS10 and Chrome53 has a bug on their application which is not dispatching "loadedmetada" event from generic html5 event
	 * @returns {boolean}
	 */
	var doesBrowserNeedUserActionToPlayVideo = function () {//for https://jira.corp.appnexus.com/browse/VID-2557
	    var result = iOSversion();
	    if (result && Array.isArray(result) && result.length >= 4) {
	        var majoriOSVersion = result[0];
	        var kindOfBrowser = result[3];
	        if (kindOfBrowser === "chrome" && majoriOSVersion === 10 && getiOSChromeVersion() === 53) {
	            return true;
	        } else {
	            return false;
	        }
	    }
	};

	/**
	 * This method will create empty video placement and play it to resolve initial playback by human activity
	 * It's required for breaking iOS and Android limitation which is not playing video automatically
	 * @param targetWindow
	 */
	var prepareVideoPlacementsForMobile = function (iframes, type, callback, targetElementId) {

	    var totalStepsForWaterfall = iframes.length;//waterfall will have mutiple iframes to prepare independent execution area for each of waterfall steps
	    var totalCountsOfResolvedHumanActivity = 0;

	    /**
	     * final steps and execute callback of ad unit entry point.
	     *
	     * @param _type
	     */
	    var doFinalSteps = function (_type) {
	        if (totalCountsOfResolvedHumanActivity === totalStepsForWaterfall) {//if this step is last and all steps resolved human activity
	            //proceed AdUnit to start expanding
	            if (typeof(callback) === "function") {
	                hasDoneFakingAutoStartForAndroid = true;
	                warn("set hasDoneFakingAutoStartForAndroid = true by " + _type);
	                callback();
	            }
	        }
	    };

	    /**
	     * store a video placement which is successfully resolved human activiy.
	     *
	     * @param videoPlacement
	     * @param _type
	     * @param targetWindow
	     */
	    var storeResolvedVideo = function (videoPlacement, _type, targetWindow) {
	        if (hasDoneFakingAutoStartForAndroid) {
	            return;
	        }
	        warn("successfully performed autoplay trick by " + _type);
	        targetWindow[APN_MOBILE_VIDEO_PLACEMENT_ID] = videoPlacement;
	        totalCountsOfResolvedHumanActivity++;
	        doFinalSteps(_type);
	    };

	    /**
	     * remove failed iframe to avoid confusion
	     *
	     * @param _iframe
	     * @param index
	     * @param _type
	     */
	    var removeFailedIFrames = function (_iframe, index, _type) {
	        warn("removing failed iframe #" + (index + 1) + " by " + _type);
	        document.getElementById(targetElementId).removeChild(_iframe);
	    };

	    /**
	     * test video play promise to decide which user activity is effective for resolving human activity
	     *
	     * @param _iframe
	     * @param _index
	     * @param _type
	     */
	    var createEmptyVideoPlacementAndTest = function (_iframe, _index, _type) {
	        try {
	            var targetWindow = _iframe.contentWindow;
	            if (!targetWindow[APN_MOBILE_VIDEO_PLACEMENT_ID]) {
	                var videoPlacement;
	                var playPromise;
	                videoPlacement = targetWindow.document.createElement("video");
	                targetWindow.document.body.appendChild(videoPlacement);
	                videoPlacement.src = BLANK_VIDEO_URL;
	                videoPlacement.muted = true;
	                playPromise = videoPlacement.play();
	                videoPlacement.pause();// VID-1726 Chrome issue for Android playback, When load is interrupting in play state Android Chrome sometimes is not showing video
	                //Android Modern Chrome (+50) returns promise object by invoking play() method to handle asyncnorouse action - https://developers.google.com/web/updates/2016/03/play-returns-promise
	                if (playPromise !== undefined) {
	                    playPromise.then(function () {
	                        debug("video promise done successfully by " + _type);
	                        totalCountsOfResolvedHumanActivity++;
	                        doFinalSteps("promise done");
	                    }).catch(function (error) {
	                        var returnedError = {
	                            "code": error.code,
	                            "name": error.name,
	                            "message": error.message
	                        };
	                        //TODO unit test to reproduce when touch-start doesn't work
	                        // if (_type === "touchstart") {
	                        //     returnedError.code = 0;
	                        //     returnedError.name = "testing";
	                        //     returnedError.message = "testing";
	                        // }

	                        //TODO unit test to reproduce when touch-start doesn't work
	                        // if (_type === "touchend") {
	                        //     returnedError.code = 0;
	                        //     returnedError.name = "testing";
	                        //     returnedError.message = "testing";
	                        // }

	                        //TODO unit test to reproduce when all event doesn't work (For fallback play)
	                        // returnedError.code = 0;
	                        // returnedError.name = "testing";
	                        // returnedError.message = "testing";

	                        if (returnedError.code === 0) {//handle not acceptable error case we have to do fallback, at the time, code : 0, name : Not Allowed, message : Failed to execute 'play' on 'HTMLMediaElement': API can only be initiated by a user gesture.
	                            warn("playback failed : " + returnedError.code + "," + returnedError.name + "," + returnedError.message + " by " + _type);
	                            removeFailedIFrames(_iframe, _index, _type);//remove iframes of touchstart to give "touchend" opportunity which is next order of this execution
	                        } else {
	                            //handle accetable error like abort playing
	                            warn("waterfall steps #" + (Number(totalCountsOfResolvedHumanActivity) + 1) + " by " + _type + " : autoplay trick's possible due to video promise be caught with " + error.name);
	                            storeResolvedVideo(videoPlacement, _type, targetWindow);
	                        }
	                    });
	                }
	            }
	        } catch (ex) {
	            debug(ex);
	        }

	    };

	    //start point
	    iframes.forEach(function (_iframe, _index) {
	        createEmptyVideoPlacementAndTest(_iframe, _index, type);
	    });

	};

	/**
	 * check to see if it's mobile device including iOS and Android
	 *
	 * @returns {boolean}
	 */
	var isMobile = function () {
	    var index = navigator.appVersion.indexOf("Mobile");
	    var indexForAndroid = navigator.appVersion.indexOf("Android");
	    return (index > -1) || (indexForAndroid > -1);
	};

	/**
	 * check to see if it's android device
	 *
	 * @returns {boolean}
	 */
	var isAndroid = function () {
	    return (/android/i.test(navigator.userAgent.toLowerCase()));
	};


	/**
	 * retireve android Chrome version
	 *
	 * @returns {number}
	 */
	var getChromeVersion = function () {
	    var version = -1;
	    if (isAndroid()) {
	        try {
	            var tmp = navigator.userAgent.match(/Chrome\/([0-9]+)\./);
	            if (tmp && Array.isArray(tmp) && tmp.length > 1) {
	                version = parseInt(tmp[1]);
	            }
	        } catch (ex) {
	            debug(ex);
	        }
	    }
	    return version;
	};

	/**
	 * check to see whether human actitivy is required for autoplaying or not.
	 *
	 * @param initialPlayback
	 * @param initialAudio
	 * @param automatedTestingOnlyAndroidSkipTouchStart
	 * @param dataSaverEnabled : result of data saver testing
	 * @returns {boolean}
	 */
	var isRequiredHumanInteractionForAutoPlayOnAndroid = function (initialPlayback, initialAudio, automatedTestingOnlyAndroidSkipTouchStart, dataSaverEnabled) {
	    // If "automatedTestingOnlyAndroidSkipTouchStart" flag in options is true don't require a touch to start on android,
	    // used to allow automated tests to run without requiring a human touch.

	    if (isAndroid() === false) {
	        return false;
	    }

	    var isAutoPlay = initialPlayback && (initialPlayback === "auto");
	    var isAudioOn = initialAudio && (initialAudio === "on");

	    // if (getChromeVersion() >= 56 ) {
	    //     return false;//since Chrome 56 beta, autoplay with user interaction will be blocked
	    // }

	    if (getChromeVersion() >= 53) {//Since Chrome53 Google allows autoplay with no-sound refers with https://corpwiki.appnexus.com/display/~ksong/Summarize+HTML5+Video+limitations+on+Mobile+devices
	        if (isAudioOn && isAutoPlay && !automatedTestingOnlyAndroidSkipTouchStart) {
	            return true;//require user action
	        } else {
	            //exception for DataSaver option in Android devices
	            if (isAutoPlay && dataSaverEnabled && !automatedTestingOnlyAndroidSkipTouchStart) {
	                return true;//for Chrome DataSaver option - it needs to have user action for autoplaying
	            }
	            return false;
	        }
	    }

	    if (getChromeVersion() <= 52) {
	        //for old version of Chrome
	        if (isAutoPlay && !automatedTestingOnlyAndroidSkipTouchStart) {
	            return true;//require user action
	        } else {
	            return false;
	        }
	    }


	};

	/**
	 * asyncTestDataSaverForAndroid
	 *
	 * If Data Saver turns on in Chrome, we have to rely on user event for autoplaying since Chrome 53
	 * This method will test that Chrome option by playing empty mute video and will work as async and final callback will be invoked in the end of steps to inform result
	 *
	 * @returns {boolean} callback(true): DataSaver is off, callback(false): DataSaver is on
	 */
	var asyncTestDataSaverForAndroid = function (callback) {
	    info("Start to detect Android Data Saver option in this device");
	    var videoPlacement = window.document.createElement("video");
	    var playPromise;
	    var removeVideo = function (video) {
	        try {
	            if (video) {
	                document.body.removeChild(video);
	            }
	        } catch (ex) {
	            debug(ex);
	        }
	    };
	    try {
	        videoPlacement.src = BLANK_VIDEO_URL;
	        videoPlacement.muted = true;
	        document.body.appendChild(videoPlacement);

	        playPromise = videoPlacement.play();

	        if (playPromise !== undefined) {
	            playPromise.then(function () {
	                info("Android Data Saver option isn't detected in this device");
	                removeVideo(videoPlacement);
	                callback(false);
	            }).catch(function () {
	                info("Android Data Saver option is detected in this device, so auto-play will be initiated by user's activity like touch");
	                removeVideo(videoPlacement);
	                callback(true);
	            });
	        }
	    } catch (ex) {
	        debug(ex);
	        info("failed to detect Android Data Saver option in this device, so auto-play will be initiated by user's activity like touch");
	        removeVideo(videoPlacement);
	        callback(true);
	    }
	};

	/**
	 * check ios inline required
	 *
	 * @param enableInlineVideoForIos
	 * @returns {*}
	 */
	var isIosInlineRequired = function (enableInlineVideoForIos) {
	    var result;
	    try {
	        result = (iOSversion()[0] >= 8 && enableInlineVideoForIos === true);//from iOS8, browser and webview supports a canvas trick to move currentTime of video even if it's not loaded by human's activirty
	    } catch (ex) {
	        error(ex);
	    }
	    return result;
	};

	/**
	 * create iframes to embed video element resolved human activity
	 *
	 * @param type
	 * @param callback
	 * @param waterfallSteps
	 * @param maxWaterfallIframes
	 * @param targetElementId
	 */
	var createAndroidIframes = function (type, callback, waterfallSteps, maxWaterfallIframes, targetElementId) {


	    if (hasDoneFakingAutoStartForAndroid) {
	        //debug("ignored a request to create iframes for Android autoplay by " + type + " due to it's already completed by other events");
	        return;
	    }
	    debug("create iframes for Android autoplay by " + type);
	    //calculate number of total placements
	    var steps = 1;
	    if (!waterfallSteps || waterfallSteps === -1) {
	        // if waterfall steps is set to infinite, then we will create maximum of 5 Android iframes
	        // for resolving Autoplay on android.
	        steps = maxWaterfallIframes;
	    } else {
	        steps = waterfallSteps + 1;
	    }
	    debug("total " + steps + " iframes will be made by waterfall structure with " + type + " event");
	    var iframes = [];
	    //loop to resolve all placements's video element
	    for (var i = 0; i < steps; i++) {
	        var name = "";
	        if (i === 0) {
	            name = APN_MOBILE_IFRAME_NAME_PREFIX;
	        } else {
	            name = APN_MOBILE_IFRAME_NAME_PREFIX + "_Waterfall_" + i;
	        }
	        var iframeVideoWrapper = document.createElement("iframe");
	        document.getElementById(targetElementId).appendChild(iframeVideoWrapper);

	        //generate body tag
	        //VIDLA-90 fix IAS viewability tracking issue to have proper Iframe.location.origin
	        //var defaultTemplate = "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body style=\"margin:0px;overflow:hidden;\">\n</body>\n</html>\n";
	        var defaultTemplate = "<html></html>";//fix VIDLA-320 to have null doctype like we did before - it means this is the same with not invoking .write("") like we did at the begining of this project


	        iframeVideoWrapper.contentWindow.document.open();
	        iframeVideoWrapper.contentWindow.document.write(defaultTemplate);
	        iframeVideoWrapper.contentWindow.document.close();

	        //set name
	        iframeVideoWrapper.name = name;
	        iframeVideoWrapper.style.display = "none";

	        debug("iframes injected for waterfall steps #" + (i + 1) + " by " + type);
	        iframes.push(iframeVideoWrapper);//keep it on array
	    }
	    //pass iframe array to a method
	    if (iframes && Array.isArray(iframes) && iframes.length >= 1 && type !== "general") {
	        prepareVideoPlacementsForMobile(iframes, type, callback, targetElementId);
	    } else {
	        if (typeof(callback) === "function") {
	            callback();
	        }
	    }
	};

	/**
	 * initialize and register callback for calling ad unit entry point
	 *
	 * @param param
	 */
	var initialize = function (param) {

	    //if any of error occurred param.callbackAdUnitEntryPoint() will be inboked, so param.callbackAdUnitEntryPoint is required field at least
	    try {
	        var targetElementId = param.targetElementId;
	        var windowForPublisher = param.windowForPublisher;
	        var callbackAdUnitOverridingAudioToOff = param.callbackAdUnitEntryPoint;
	        var callbackPatchForIOSChrome = param.callbackPatchForIOSChrome;
	        var waterfallSteps = param.waterfallSteps;
	        var maxWaterfallIframes = param.maxWaterfallIframes;
	        var initialPlayback = param.initialPlayback;
	        var initialAudio = param.initialAudio;
	        var automatedTestingOnlyAndroidSkipTouchStart = param.automatedTestingOnlyAndroidSkipTouchStart;
	        var androidDSOverride = param.androidDSOverride;


	        //nested function which will have variables propogated from parent function - don't move this outside, this structure is requried to do aysnc-video-autoplay-test
	        var autoplayDecisionCallback = function (dataSaverEnabled) {

	            var dataSaverEnabledOrigin = dataSaverEnabled;//backup origin value of dataSaver detected by a code
	            //VIDLA-258 autoplay with sound-on and data-saver on will end up click-to-play on Chrome55 and androidDSOverride:false
	            if (androidDSOverride === false && dataSaverEnabled && getChromeVersion() <= 55 && initialAudio === "on" && initialPlayback === "auto") {
	                callbackAdUnitOverridingAudioToOff(false, true);//no override audio, override autoplay to click-to-play
	                return;
	            }

	            if (androidDSOverride === false) {
	                dataSaverEnabled = false;//regard data saver is disabled if androidDSOverride options is false and trust user's decision for saving network traffick
	            }

	            if (getChromeVersion() < 56 && isRequiredHumanInteractionForAutoPlayOnAndroid(initialPlayback, initialAudio, automatedTestingOnlyAndroidSkipTouchStart, dataSaverEnabled)) {
	                /////////////////////////////////////////////////////////////////////////////////
	                //when need to wait humain interaction, inject additional event listener to DOM
	                /////////////////////////////////////////////////////////////////////////////////

	                //only for android autostart - this will use Android auto-play trick to pre-resolve human activity
	                //callback when the trick finished
	                var resolveHumanTouch = function (type) {
	                    createAndroidIframes(type, function () {
	                        callbackAdUnitOverridingAudioToOff(false, false);//no override audio, no override autoplay, start expadning, invoke explicitPlay (vpaid startAd)
	                    }, waterfallSteps, maxWaterfallIframes, targetElementId);
	                };
	                windowForPublisher.addEventListener("touchstart", function () {
	                    resolveHumanTouch("touchstart");
	                }, {passive: true});//passive event will help to avoid race condition when both event happens at a time
	                windowForPublisher.addEventListener("touchend", function () {
	                    setTimeout(function () {
	                        resolveHumanTouch("touchend");
	                    }, 1);//to guaranty touchstart and touchend will be delived to a listener in order (touchstart first, touchend last)
	                }, {passive: true});//passive event will help to avoid race condition when both event happens at a time
	            } else {
	                /////////////////////////////////////////////////////////////////////////////////
	                //when no need to wait humain interaction
	                /////////////////////////////////////////////////////////////////////////////////

	                var shouldOverrideAudioToOff;
	                var shouldOverrideAutoplayToOff;

	                if (getChromeVersion() >= 56) {
	                    shouldOverrideAudioToOff = (initialAudio === "on" && initialPlayback === "auto" && dataSaverEnabledOrigin === false) ? true : false;
	                    shouldOverrideAutoplayToOff = (initialPlayback === "auto" && dataSaverEnabledOrigin === true) ? true : false;
	                } else {
	                    shouldOverrideAutoplayToOff = (initialPlayback === "auto" && dataSaverEnabledOrigin === true) ? true : false;
	                }

	                //to resolve waterfall issue
	                createAndroidIframes("general", function () {
	                    callbackAdUnitOverridingAudioToOff(shouldOverrideAudioToOff, shouldOverrideAutoplayToOff);//a case for click-to-play, autoplay+sound-off (if autoplay is possible by DataSaver options's test)
	                }, waterfallSteps, maxWaterfallIframes, targetElementId);


	            }
	        };

	        if (isMobile()) {//for mobile
	            //mobile needs to have special handling for a case of autoplaying
	            if (isAndroid()) {
	                debug("intialize for Android");
	                asyncTestDataSaverForAndroid(autoplayDecisionCallback);//async test for checking data saver option on Android, test and then will invoke callback to notirfy result
	            } else {
	                debug("intialize for iOS and etc");
	                callbackAdUnitOverridingAudioToOff(false);

	                //this is required for iOS-Chrome 53 which has an bug not dispatching "loadedMetaData" event from generic video element
	                if (doesBrowserNeedUserActionToPlayVideo() && callbackPatchForIOSChrome && typeof(callbackPatchForIOSChrome) === "function") {
	                    windowForPublisher.addEventListener("touchstart", callbackPatchForIOSChrome);
	                }
	            }
	        } else {
	            //for desktop
	            debug("initialize for general html5 browsers");
	            callbackAdUnitOverridingAudioToOff(false);
	        }
	    } catch (ex) {
	        //fallback when error
	        debug(ex);
	        //call adunit next entry point
	        if (param.callbackAdUnitEntryPoint && typeof(param.callbackAdUnitEntryPoint) === "function") {
	            param.callbackAdUnitEntryPoint(false);
	        }
	    }

	};


	/**
	 * checkVideoPromise: create video element and check video promise test
	 * @param videoUrl: test video url
	 * @param callback: callback to notify result
	 * @param isMuted: define mute or unmute for video element
	 * @param videoPlacementId: id value for video element
	 */
	var checkVideoPromise = function (videoUrl, callback, isMuted, videoPlacementId) {

	    var playPromise;

	    //chrome autoplay policy details
	    /*
	    conditions:
	        1. When Chrome has "document user activation is required" as an Chrome options.
	        2. Definition of user's activity: activity in current page or previous page on hyperlink(if it's same domain)

	    correct result:
	        if there's user's activity
	            video+audio promise: ok on same window
	            video+audio promise: error on iframe (different contextWindow with top.window)
	        if there's no user activity
	            video + audio promise: error
	            video + no audio promise: ok
	            unmute by javascript: freeze a video
	     */

	    var browser = UA_Parser.browser.name.toLowerCase();
	    var hasMaxLimitOnVideo = (UA_Parser.os && UA_Parser.os.name === "Android" && parseInt && typeof(parseInt) === "function" && parseInt(UA_Parser.os.version) === 5) ? true : false;//test for video tag limitation on Chrome 62.0.3202.84, Android 5.1.1; Nexus 10 Build/LMY49J which has max video render limitation (allow to render only under 3) on the same page
	    debug("hasMaxLimitOnVideo: " + hasMaxLimitOnVideo);


	    //VIDLA-2517: iOS Safari bug's work-around, if iOS then pass the video testing and returns a result based on what our group knows on Feb 2018.
	    if (isIOS()) {
	        donePromiseCheck[videoPlacementId] = true;
	        callback(isMuted);//iOS can't play video with sound without user's activity on Feb 2018
	        return;
	    }

	    //latest Firefox's video promise won't work in iframe and it doesn't have detection logic by user's activity, so a code doesn't need to do a iframe trick to avoid unnecessary user's activity like Chrome and others
	    if (browser === "firefox") {
	        videoPlacement = document.createElement("video");
	        videoPlacement.style.width = "1px";
	        videoPlacement.style.height = "1px";
	        videoPlacement.src = videoUrl;
	        videoPlacement.id = videoPlacementId;
	        videoPlacement.setAttribute("playsinline","");//to check video promise on iOS-iPhone this attribute is required

	        document.body.appendChild(videoPlacement);

	    } else {

	        //isolatedIframeForBrowserHavingUserActivityDetection
	        var isolatedIframe = document.createElement("iframe");//to block user's gesture on chrome
	        isolatedIframe.style.display = "none";
	        isolatedIframe.id = "iframe_" + videoPlacementId;

	        document.body.appendChild(isolatedIframe);

	        if (hasMaxLimitOnVideo) {//test for video tag limitation on Chrome 62.0.3202.84, Android 5.1.1; Nexus 10 Build/LMY49J which has max video render limitation (allow to render only under 3) on the same page
	            if (!videoPlacement) {
	                videoPlacement = document.createElement("video");
	            }
	        } else {
	            videoPlacement = document.createElement("video");
	        }

	        videoPlacement.style.width = "1px";
	        videoPlacement.style.height = "1px";
	        videoPlacement.src = videoUrl;
	        videoPlacement.id = videoPlacementId;
	        videoPlacement.setAttribute("playsinline","");//to check video promise on iOS-iPhone this attribute is required

	        isolatedIframe.contentWindow.document.body.appendChild(videoPlacement);//this video element will be cleared at getAutoplayPolicy()

	    }


	    videoPlacement.muted = isMuted;

	    if (isMuted === false && videoPlacement.volume) {
	        videoPlacement.volume = 0.001;//silence as much as possible
	    }

	    playPromise = videoPlacement.play();

	    //first this logic will test promise with audio and then test without audio to decide which video policy set on a browser
	    if (playPromise !== undefined) {
	        playPromise.then(function () {
	            donePromiseCheck[videoPlacementId] = true;//set flag for expiration logic to remove used video element and for fallback logic
	            debug("video promise succeeded: " + videoPlacementId + ", muted=" + isMuted);
	            callback(true);
	        }).catch(function (error) {
	            var returnedError = {
	                "code": error.code,
	                "name": error.name,
	                "message": error.message
	            };
	            debug("video promise failed: " + videoPlacementId + ", muted=" + isMuted + "," + returnedError.code + "," + returnedError.name + "," + returnedError.message);
	            donePromiseCheck[videoPlacementId] = true;//set flag for expiration logic to remove used video element and for fallback logic
	            callback(false);
	        });
	    } else {
	        //for edge, ie, firefox oldversion which deosn't have a support of video promise
	        donePromiseCheck[videoPlacementId] = true;//set flag for expiration logic to remove used video element and for fallback logic
	        callback(true);//allow autoplay
	    }

	};


	/**
	 * getAutoplayPolicy for all browsers
	 * @param callback
	 * @param checkAudioSupport: if true, this method will do a sound-on video test
	 */
	var getAutoplayPolicy = function (callback, checkAudioSupport) {

	    var videoPlacementId;//unique id for testing autoplay + sound on
	    var videoPlacementIdForNoAudio;//unique id for testing autoplay + sound off

	    if (typeof(checkAudioSupport) === "undefined") {
	        checkAudioSupport = false;//for VIDLA-2575, Chrome will have more strict ad policy to block an ad which has sound-on video behind like Outstream case
	    }

	    //generate unique video placement id for testing video policy, this id will distinguish video pacement for every call
	    videoPlacementId = "videoPlacementTest_" + new Date().getTime() + Math.floor(Math.random() * 10000);
	    videoPlacementIdForNoAudio = "videoPlacementTest_" + new Date().getTime() + Math.floor(Math.random() * 10000);

	    //set false as a default
	    donePromiseCheck = {}; //object to have a current status of promise (a scope is within this autoplay handler module)
	    donePromiseCheck[videoPlacementId] = false;
	    donePromiseCheck[videoPlacementIdForNoAudio] = false;

	    if (checkAudioSupport) {
	        //create video element and test by video promise then call callback with policy number defined by videoPolicy object
	        //a test video is dummyVideoHavingAudio which has a sound stream on the video
	        checkVideoPromise(dummyVideoHavingAudio, function (result) {
	            if (result === true) {
	                debug("decided to allowAutoplay");
	                callback(videoPolicy.allowAutoplay);//broser allowed autoplay with sound on
	            } else {
	                checkVideoPromise(dummyVideoHavingAudio, function (result) {
	                    if (result === true) {
	                        debug("decided to stopMediaWithSound");
	                        callback(videoPolicy.stopMediaWithSound);//browser allowed autoplay with sound off
	                    } else {
	                        debug("decided to neverAutoplay");
	                        callback(videoPolicy.neverAutoplay);//browser doesn't allow autoplay, usually Safari has this options and suggest api consumer to have click-to-play for this case
	                    }
	                }, true, videoPlacementIdForNoAudio);//test with sound off
	            }
	        }, false, videoPlacementId);//test with sound on
	    } else {
	        checkVideoPromise(dummyVideoHavingAudio, function (result) {
	            if (result === true) {
	                debug("decided to stopMediaWithSound");
	                callback(videoPolicy.stopMediaWithSound);//browser allowed autoplay with sound off
	            } else {
	                debug("decided to neverAutoplay");
	                callback(videoPolicy.neverAutoplay);//browser doesn't allow autoplay, usually Safari has this options and suggest api consumer to have click-to-play for this case
	            }
	        }, true, videoPlacementIdForNoAudio);//test with sound off
	    }

	    // a fallback logic if there's timeout or any other reason like not supporting promise, etc...
	    // used video will be removed here
	    setTimeout(function () {

	        var destDocument = document;

	        //get iframes
	        var iframe = document.getElementById("iframe_" + videoPlacementId);
	        if (iframe) {
	            destDocument = iframe.contentWindow.document;
	        }

	        //getting video element for both sound-on and sound-off case
	        var videoHavingAudio = destDocument.getElementById(videoPlacementId);
	        var videoHavingNoAudio = destDocument.getElementById(videoPlacementIdForNoAudio);

	        //remove used video placement for video + unmute
	        if (videoHavingAudio && videoHavingAudio.parentNode) {
	            videoHavingAudio.parentNode.removeChild(videoHavingAudio);//remove video
	            debug("remove test video placement :" + videoPlacementId);
	        }

	        //remove used video placement for video + mute
	        if (videoHavingNoAudio && videoHavingNoAudio.parentNode) {
	            videoHavingNoAudio.parentNode.removeChild(videoHavingNoAudio);//remove video
	            debug("remove test video placement for sound on case :" + videoPlacementIdForNoAudio);
	        }

	        //fallback if promise doesn't have proper value within timeout. if any of videoPlacementId and videoPlacementForNoAudio has a true it will report it's status properly at checkVideoPromise()
	        if (checkAudioSupport) {
	            if (donePromiseCheck[videoPlacementId] === false && donePromiseCheck[videoPlacementIdForNoAudio] === false) {
	                debug("timeout video test");
	                debug("decided to neverAutoplay");
	                callback(videoPolicy.neverAutoplay);
	            }
	        } else {
	            if (donePromiseCheck[videoPlacementIdForNoAudio] === false) {
	                debug("timeout video test");
	                debug("decided to neverAutoplay");
	                callback(videoPolicy.neverAutoplay);
	            }
	        }


	    }, timeout);


	};


	//shared attribute to other module
	module.exports = {
	    APN_MOBILE_VIDEO_PLACEMENT_ID: APN_MOBILE_VIDEO_PLACEMENT_ID,//video placement id in iframes which will be used on core video framework
	    APN_MOBILE_IFRAME_NAME: APN_MOBILE_IFRAME_NAME_PREFIX,//prefix of iframe names which will be used on core video framework
	    initialize: initialize,//initialize method for ad units
	    iOSversion: iOSversion,//shared method for core video framework
	    isIOS: isIOS,//shared method for core video framework
	    isIosInlineRequired: isIosInlineRequired,//shared method for core video framework
	    isRequiredFakeAndroidAutoStart: isRequiredHumanInteractionForAutoPlayOnAndroid,//shared method for core video framework
	    isMobile: isMobile, //shared method for core video framework
	    testDataSaverForAndroid: asyncTestDataSaverForAndroid, //test data-saver options
	    getAutoplayPolicy: getAutoplayPolicy,
	    videoPolicy: videoPolicy
	};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var APNVideo_VastParser = __webpack_require__(53);
	var APN_RenditionManager = __webpack_require__(21);
	var APN_TrackingManager = __webpack_require__(60);
	var APN_CompanionManager = __webpack_require__(20);
	var APN_Logger = __webpack_require__(23);
	var _reporter = __webpack_require__(24);
	var _defaultWaterfallTimeout = 15000;
	var _ratbaitPath = 'https://rb.adnxs.com/pack?log=log_rb_video_waterfall_events&format=json';

	var debug = function (message) {
	    APN_Logger.debug(message, "AdHandler");
	};

	// Tracking Documentation
	// https://corpwiki.appnexus.com/display/SSV/Enhanced+Video+Mediation+Reporting+for+Waterfall+Processing
	var WF_STATUS_ATTEMPT = 1;
	var WF_STATUS_REJECTED_BY_CREATIVE = 2;
	var WF_STATUS_REJECTED_BY_TIMEOUT = 3;
	var WF_STATUS_ACCEPTED = 4;
	var WF_STATUS_TIMEOUT = 5;
	var WF_STATUS_STEP_LIMIT = 6;
	var WF_STATUS_NOT_ATTEMPTED = 7;
	var WF_STATUS_DISABLED_PUBLISHER = 8;
	var WF_STATUS_DISABLED_BROWSER = 9;
	var WF_STATUS_REJECTED_BY_AD_TIMEOUT = 10;
	var WF_STATUS_INTERRUPTED_BY_AD_TIMEOUT = 11;

	var WF_EVENT_TYPE = {
	    // Waterfall step start
	    // indicates the start of a waterfall step being attempted
	    STEP_START: 0,

	    // Waterfall step end
	    // indicates the end of a waterfall step being attempted
	    STEP_END: 1,

	    // Waterfall step not attempted;
	    // these are the waterfall steps not reached due to some kind of timeout
	    // or if a creative in a previous waterfall successfully played.
	    STEP_NOT_ATTEMPTED: 2,

	    // Waterfall has been disabled
	    DISABLED: 3
	};

	var WF_RESULT_CODE = {
	    AD_DELIVERED: 0,
	    AD_ERROR: 1,
	    WATERFALL_TIMEOUT: 2,
	    MAX_WATERFALL_STEPS_REACHED: 3,
	    PREVIOUS_AD_DELIVERED: 4,
	    NON_WATERFALL_TIMEOUT: 5,
	    PUBLISHER_DISABLED: 11,
	    INCOMPATIBILITY_DISABLED: 12
	};

	//common part to load video player
	module.exports = function (targetElement, options, cbAdunits) {
	    if (!options._vastObjArr || !Array.isArray(options._vastObjArr)) {
	        options._vastObjArr = [];
	    }

	    var VAST_ERROR_UNDEFINED = 900;
	    var ERROR_TYPE_VAST = 1;//vast-error (one of the error codes specified in the VAST spec)
	    var isDoneCbHandlingRendition = false;//flag for checking callback is done
	    var timeToWaitFor = 3000;//callback waiting
	    var vastVersion = "2.0";
	    var adId = new Date().getTime() + Math.floor(Math.random() * 10000);
	    var rtbAd;
	    var currentAd;
	    var impressionSent = false;
	    var isWaterfall = false;
	    var waterfallTimeout = options.waterfallTimeout;
	    var waterfallTimeoutHandler;
	    var waterfallTimeoutOccurred = false;
	    var adCount = 0;
	    var maxNonRtbAdCount = 0;
	    var totalAvailableAds = 0;
	    var waterfallSteps = options.waterfallSteps;
	    var waterfallStartTimestamp;
	    var replayObjectExists = (options.disableCollapse && options.disableCollapse.replay !== undefined);
	    var originalReplayValue;
	    var previousStatusCode = '';
	    if (replayObjectExists) {
	        originalReplayValue = options.disableCollapse.replay;
	    }
	    // callback for sent waterfall step details to the adUnit
	    var waterfallCallback = function (obj){
	        if (cbAdunits.cbWhenWaterfall) {
	            cbAdunits.cbWhenWaterfall(obj);
	        }
	    };
	    // inject additional callback (getting override whenDestory callback)
	    var completeCallback = cbAdunits.cbWhenVideoComplete;
	    var audioCallback = cbAdunits.cbWhenAudio;
	    var quartileCallback = cbAdunits.cbWhenQuartile;
	    var clickOpenUrlCallback = cbAdunits.cbWhenClickOpenUrl;
	    var tmpCallback = cbAdunits.cbWhenDestroy;
	    // callback for impression sent event
	    var impCallback = cbAdunits.cbWhenImpression;
	    var cbCoreVideoEvent = cbAdunits.cbCoreVideoEvent;

	    var notificationEventMapping = {
	        "creative-view": "creativeView",
	        "video-start": "start",
	        "video-mid": "midpoint",
	        "video-first-quartile": "firstQuartile",
	        "video-third-quartile": "thirdQuartile",
	        "video-complete": "complete",
	        "audio-mute": "mute",
	        "audio-unmute": "unmute",
	        "video-pause": "pause",
	        "rewind": "rewind",
	        "video-resume": "resume",
	        "video-fullscreen": "fullscreen",
	        "ad-expand": "expand",
	        "ad-collapse": "collapse",
	        "video-stopped": "close",
	        "video-exit-fullscreen": "exitFullscreen",
	        "video-skip": "skip",
	        "ad-progress": "progress",
	        "acceptInvitation": "acceptInvitation",
	        "acceptInvitationLinear": "acceptInvitationLinear",
	        "closeLinear": "closeLinear",
	        "impression": "impression",
	        "error": "error",
	        "video-failed": "error",
	        "ad-click": "ClickTracking",
	        "volume-change": "volumeChange"
	    };

	    // delay tracking
	    var delayTracking = false;
	    var arrDelayEvents = [];
	    var arrReadyEvents = [];

	    // companions
	    var companionAdsObj = null;
	    var currentVastObj = null;

	    // viewability
	    var useViewabilityFromOptions = (options && options.viewability && options.viewability.config) ? true : false;

	    var isIphone = function () {
	        var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
	        return isFlag;
	    };

	    var isIos = function () {
	        var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
	        return isFlag;
	    };

	    var reportRemainingWaterfallAds = function (step) {
	        var remainingAds = options._vastObjArr.slice(0);

	        if (rtbAd) {
	            remainingAds.push(rtbAd);
	        }

	        if (remainingAds.length) {
	            for (var i = 0; i < remainingAds.length; i++) {
	                var vastObj = remainingAds[i];
	                if (!vastObj.rtb || !currentAd.rtb) {
	                    reportWaterfallTracker(vastObj, WF_STATUS_NOT_ATTEMPTED, step);
	                }
	            }
	        }
	    };

	    var reportWaterfallTracker = function (vastObj, statusCode, step) {
	        try {
	            if (!vastObj) {
	                throw(new Error('vastObj required to track waterfall step'));
	            }
	            // TODO: to be added to media manager
	            var creative_id = vastObj.creative_id;
	            var event_type = '';
	            var result_code = '';
	            var latency = '';
	            var trackRemaining = false;
	            if (currentAd && _reporter && _reporter.loadPost && typeof _reporter.loadPost === 'function') {
	                if (!options) {
	                    throw(new Error('options required to track waterfall steps'));
	                }

	                switch (statusCode) {
	                    case WF_STATUS_ATTEMPT:
	                        event_type = WF_EVENT_TYPE.STEP_START;
	                        currentAd.startWFStepTimer = (new Date()).getTime();
	                        break;
	                    case WF_STATUS_NOT_ATTEMPTED:
	                        event_type = WF_EVENT_TYPE.STEP_NOT_ATTEMPTED;
	                        break;
	                    case WF_STATUS_DISABLED_PUBLISHER:
	                        event_type = WF_EVENT_TYPE.DISABLED;
	                        result_code = WF_RESULT_CODE.PUBLISHER_DISABLED;
	                        break;
	                    case WF_STATUS_DISABLED_BROWSER:
	                        event_type = WF_EVENT_TYPE.DISABLED;
	                        result_code = WF_RESULT_CODE.INCOMPATIBILITY_DISABLED;
	                        break;
	                    case WF_STATUS_REJECTED_BY_AD_TIMEOUT:
	                        event_type = WF_EVENT_TYPE.STEP_NOT_ATTEMPTED;
	                        result_code = WF_RESULT_CODE.NON_WATERFALL_TIMEOUT;
	                        break;
	                    case WF_STATUS_INTERRUPTED_BY_AD_TIMEOUT:
	                        event_type = WF_EVENT_TYPE.STEP_END;
	                        result_code = WF_RESULT_CODE.NON_WATERFALL_TIMEOUT;
	                        break;
	                    case WF_STATUS_STEP_LIMIT:
	                        event_type = WF_EVENT_TYPE.STEP_NOT_ATTEMPTED;
	                        result_code = WF_RESULT_CODE.MAX_WATERFALL_STEPS_REACHED;
	                        trackRemaining = true;
	                        break;
	                    case WF_STATUS_REJECTED_BY_CREATIVE:
	                        event_type = WF_EVENT_TYPE.STEP_END;
	                        result_code = WF_RESULT_CODE.AD_ERROR;
	                        break;
	                    default:
	                        event_type = WF_EVENT_TYPE.STEP_END;
	                }

	                if (event_type === WF_EVENT_TYPE.STEP_END) {
	                    if (currentAd.startWFStepTimer) {
	                        latency = (new Date()).getTime() - currentAd.startWFStepTimer;
	                    }
	                    switch (statusCode) {
	                        case WF_STATUS_ACCEPTED:
	                            result_code = WF_RESULT_CODE.AD_DELIVERED;
	                            trackRemaining = true;
	                            break;
	                        case WF_STATUS_REJECTED_BY_TIMEOUT:
	                            result_code = WF_RESULT_CODE.NON_WATERFALL_TIMEOUT;
	                            break;
	                        case WF_STATUS_TIMEOUT:
	                            result_code = WF_RESULT_CODE.WATERFALL_TIMEOUT;
	                            trackRemaining = true;
	                            break;
	                        default:
	                    }
	                }

	                if (event_type === WF_EVENT_TYPE.STEP_NOT_ATTEMPTED) {
	                    switch (previousStatusCode) {
	                        case WF_STATUS_ACCEPTED:
	                            result_code = WF_RESULT_CODE.PREVIOUS_AD_DELIVERED;
	                            break;
	                        case WF_STATUS_TIMEOUT:
	                            result_code = WF_RESULT_CODE.WATERFALL_TIMEOUT;
	                            break;
	                        case WF_STATUS_STEP_LIMIT:
	                            result_code = WF_RESULT_CODE.MAX_WATERFALL_STEPS_REACHED;
	                            break;
	                        default:
	                    }
	                }

	                var auction_id = options.auction_id;
	                var timeout = options && options.waterfallTimeout ? options.waterfallTimeout : _defaultWaterfallTimeout;
	                var stepVal = options && (options.waterfallSteps || options.waterfallSteps === 0) ? options.waterfallSteps : -1;

	                // TODO: not available in outstream, only mediation manager knows about this
	                var mediation_timeout = 2000;

	                var trackerObj = {
	                    "auction_id_64": auction_id,
	                    "event_type": event_type,
	                    "version": options.productVersion,
	                    "timestamp": (new Date()).getTime(),
	                    "timeout": timeout,
	                    "waterfall_steps": stepVal,
	                    "mediation_timeout": mediation_timeout
	                };

	                if (latency !== '') {
	                    trackerObj.latency = latency;
	                }

	                if (result_code !== '') {
	                    trackerObj.result_code = result_code;
	                }

	                if (step) {
	                    trackerObj.waterfall_position = step;
	                }

	                // TODO: creative_id currently not available in outstream (mediation manager)
	                if (creative_id) {
	                    trackerObj.creative_id = creative_id;
	                }

	                //VIDLA-1987 This is a trick used to deal with 64 bit int.
	                var data = JSON.stringify(trackerObj).replace(/"auction_id_64":"(\d+)"/, '"auction_id_64":$1');
	                debug("Waterfall RATBAIT POST tracker fired path :" + _ratbaitPath + " -- " + data);
	                _reporter.loadPost(_ratbaitPath, data);

	                if (trackRemaining) {
	                    previousStatusCode = statusCode;
	                    reportRemainingWaterfallAds(step);
	                }
	            }
	        } catch(err) {
	            debug("Error in reporting to RATBAIT " + err);
	        }
	    };

	    var printWaterfallLog = function (stepLog, succ, errObj) {
	        // TODO: track disabled by pub WF_STATUS_DISABLED_PUBLISHER
	        // only possible if we support disabling waterfall in outstream
	        if (!isWaterfall) {
	            return;
	        }

	        if (!currentAd) {
	            return;
	        }

	        var type = currentAd.rtb ? "rtb" : "csm";
	        var notifyurl = currentAd.notifyurl;
	        var currentTimestamp = new Date().getTime();
	        var statusCode = WF_STATUS_ATTEMPT;
	        var statusObj = {
	            adId: currentAd.adId,
	            step: adCount,
	            totalAvailableSteps: totalAvailableAds,
	            stepLimit: waterfallSteps,
	            maxTime: waterfallTimeout,
	            timeRemaining: waterfallTimeout,
	            auction_id: options.auction_id,
	            creative_id: currentAd.creative_id,
	            productVersion: options.productVersion
	        };

	        if (waterfallStartTimestamp) {
	            statusObj.timeRemaining = waterfallTimeout - (currentTimestamp - waterfallStartTimestamp);
	        }

	        if (stepLog) {
	            statusCode = WF_STATUS_ATTEMPT;
	            statusObj.status = 'stepStart';
	            options.waterfallStepId = "Waterfall_Step_"+ new Date().getTime() + Math.floor(Math.random() * 10000);
	            debug("Waterfall Step #" + adCount +" , type=" + type + ", adId=" + statusObj.adId +", timeout="+ waterfallTimeout +  ", notifyurl=" + notifyurl + ", creativeId=" + statusObj.creative_id);
	        }

	        if (succ) {
	            statusCode = WF_STATUS_ACCEPTED;
	            statusObj.status = 'stepSuccess';
	            debug("Waterfall outcome, Step #" + adCount + ": ACCEPTED, type= " + type +", adId=" + statusObj.adId +", timeout="+ waterfallTimeout + ", notifyurl=" + notifyurl + ", creativeId=" + statusObj.creative_id);
	        }

	        if (errObj) {
	            statusCode = WF_STATUS_REJECTED_BY_CREATIVE;
	            statusObj.status = 'stepFail';

	            if (errObj.code && errObj.code === 402) {
	                statusCode = WF_STATUS_REJECTED_BY_TIMEOUT;
	            }

	            debug("Waterfall outcome, Step #" + adCount + ": REJECTED, type= " + type +", adId=" + statusObj.adId +", timeout="+ waterfallTimeout+ ", reason=" + errObj.message + ", creativeId=" + statusObj.creative_id);
	        }

	        if (waterfallTimeoutOccurred) {
	            statusCode = WF_STATUS_TIMEOUT;
	            statusObj.status = 'timeout';
	            debug("Waterfall outcome, Step #" + adCount + ": TIMED-OUT, type= " + type +", timeout="+ waterfallTimeout +", ads processed="+ adCount + ", creativeId=" + statusObj.creative_id);
	        }

	        reportWaterfallTracker(currentAd, statusCode, statusObj.step);
	        return waterfallCallback(statusObj);
	    };

	    var notifyVastTracking = function(eventName, payload) {
	        var vastEvent = notificationEventMapping[eventName];
	        if (!vastEvent) {
	            // internal event
	            return;
	        }

	        options.cbNotification('VAST', vastEvent, options.targetId, payload);

	        // remove one time deal events
	        if (eventName === "impression" || eventName === "video-complete" || eventName === "video-start") {
	            if (notificationEventMapping.hasOwnProperty(eventName)) {
	                delete notificationEventMapping[eventName];
	            }
	        }
	    };

	    var companionCallback = function(obj) {
	        if (!obj || !obj.command || !obj.uniqueId) {
	            return;
	        }

	        var command = obj.command;
	        debug("Companion callback command: " + command + ", unique companion id: " + obj.uniqueId);

	        switch(command) {
	            case 'addTrackingEvents': {
	                var companion = obj.data;
	                if (companion) {
	                    //prepare tracking manager
	                    var unrestrictedEvents = [
	                        "error",
	                        "creative-view",
	                        "companion-click"
	                    ];
	                    var i;
	                    APN_TrackingManager.init(unrestrictedEvents, obj.uniqueId);//set unrestricted event (multiple invokes)
	                    if (companion.CompanionClickTracking && companion.CompanionClickTracking.length > 0) {
	                        for (i = 0; i < companion.CompanionClickTracking.length; i++) {
	                            APN_TrackingManager.addTrackingEvent("companion-click", companion.CompanionClickTracking[i], obj.uniqueId);
	                        }
	                    }
	                    if (companion.TrackingEvents && companion.TrackingEvents.length > 0) {
	                        for (i = 0; i < companion.TrackingEvents.length; i++) {
	                            if (companion.TrackingEvents[i].eventType === 'creativeView') {
	                                // only creativeView event is available for companion
	                                APN_TrackingManager.addTrackingEvent("creative-view", companion.TrackingEvents[i].url, obj.uniqueId);
	                            }
	                        }
	                    }
	                }
	            }
	            break;

	            case 'requestTracking':	{
	                var eventName = obj.data;
	                if (eventName) {
	                    APN_TrackingManager.requestTracking(eventName, obj.uniqueId);
	                }
	            }
	            break;
	        }
	    };

	    //function for handle callback invoke from video player framework
	    var cbForHandlingDispatchedEvent = function (eventObject, skipTracking) {

	        if (cbCoreVideoEvent && typeof(cbCoreVideoEvent) === "function") {
	            cbCoreVideoEvent("AdHandler", eventObject.name);
	        }

	        if (!skipTracking) {
	            debug("TM>requesting - dispatch : " + eventObject.name);
	        }

	        var eventName = eventObject.name;
	        //normalizated values in tracking manager
	        /*
	         * 	- bid-impression
	         *  - network-request
	         *  - network-response
	         * 	- impression
	         * 	- video-start
	         *  - video-first-quartile
	         *  - video-mid
	         *  - video-third-quartile
	         *  - video-complete
	         *  - ad-click
	         *  - video-pause
	         *  - video-rewind
	         *  - video-resume
	         *  - audio-mute
	         *  - audio-unmute
	         *  - video-fullscreen
	         *  - video-exit-fullscreen
	         *  - creative-view
	         *  - ad-expand
	         *  - ad-collapse
	         *  - user-accept-invitation
	         *  - user-close
	         *  - ad-progress
	         *  - error
	         */
	        var evenetMappingForFlash = {
	            "video_start": "video-start",
	            "video_impression": "impression",
	            "video_mute": "audio-mute",
	            "video_click": "video-click",
	            "video_complete": "video-complete",
	            "video_fullscreen": "video-fullscreen",
	            "quartile_event": "quartile-event",
	            "video_pause": "video-pause",
	            "video_unmute": "audio-unmute",
	            "video_failed": "video-failed",
	            "video_time": "video-time",
	            "video_resume": "video-resume",
	            "video_stopped": "video-stopped",
	            "video-first-quartile": "video-first-quartile",
	            "video-mid": "video-mid",
	            "video-third-quartile": "video-third-quartile",
	            "fullscreenchange": "video-fullscreen",
	            "video_click_open_url": "video-click-open-url",
	            "video_skip": "video-skip"
	        };

	        var invokeEventName = evenetMappingForFlash[eventName];
	        var doNotTrack = false;

	        if (delayTracking && arrDelayEvents.indexOf(invokeEventName) !== -1) {
	            doNotTrack = true;
	        }

	        //convert flash quartile events
	        if (invokeEventName === "quartile-event") {
	            switch (eventObject.quartile) {
	                case 1 :
	                    invokeEventName = "video-first-quartile";
	                    break;
	                case 2 :
	                    invokeEventName = "video-mid";
	                    break;
	                case 3 :
	                    invokeEventName = "video-third-quartile";
	                    break;
	            }
	        }


	        //handle vast3 full-screen-exit
	        if (invokeEventName === "video-fullscreen" && vastVersion === "3.0") {
	            switch (eventObject.fullscreenStatus) {
	                case "enter" :
	                    invokeEventName = "video-fullscreen";
	                    break;
	                case "exit" :
	                    invokeEventName = "video-exit-fullscreen";
	                    break;
	                default :
	                    invokeEventName = "video-fullscreen";
	                    break;
	            }
	        }

	        //if it's for flash, just use it.
	        if (invokeEventName === undefined) {
	            invokeEventName = eventName;
	        }

	        if (eventObject && eventObject.name && eventObject.name === "ad-click" && !eventObject.trackClick){
	            // Where clickThru landing url was not found. Do not track click and Do not send VAST notifications for ClickTracking
	            return;
	        } else if (!skipTracking) {
	            //comment out due to a change of VIDLA-92 spec.
	            //fix fox VIDLA-92 only report skip event when VAST video is skippable which is defiend by VAST XML (creative skipoffset)
	            //if (eventObject && eventObject.name === "video_skip" && options && options.data.isVastVideoSkippable === false) {
	            //    debug("tracking video_skip got canceled because VAST video is not skippable (skipOffset doesn't exist in VAST)");
	            //} else {
	            if (doNotTrack) {
	                arrReadyEvents.push(invokeEventName);
	            } else {
	                APN_TrackingManager.requestTracking(invokeEventName, adId);
	            }
	            //}
	        }

	        if (options.hasOwnProperty('cbNotification')) {
	            if (eventObject.eventType === "AdUnit") {
	                options.cbNotification(eventObject.eventType, invokeEventName, options.targetId, eventObject.obj);
	            } else {
	                notifyVastTracking(invokeEventName, eventObject.obj);
	            }
	        }

	        if (options.cbApnVastPlayer) {
	            options.cbApnVastPlayer(invokeEventName);
	        }

	        if (invokeEventName === "canplay") {
	            if (eventObject.companionAds) {
	                currentVastObj.companionAds = APN_CompanionManager.parse(eventObject.companionAds);
	            }
	        }

	        if(invokeEventName === "impression"){
	            // waterfall
	            impressionSent = true;

	            if (impCallback && typeof(impCallback) === "function") {
	                impCallback();
	            }

	            if (isWaterfall) {
	                if (waterfallTimeoutHandler) {
	                    clearTimeout(waterfallTimeoutHandler);
	                }
	                printWaterfallLog(false, true);
	                APN_TrackingManager.requestTracking("notifyurl", adId);
	            } else if (options.overlayPlayer) {
	                APN_TrackingManager.requestTracking("notifyurl", adId);
	            }

	            // companion support
	            if (currentVastObj.hasOwnProperty('companionAds') && currentVastObj.companionAds.companions.length > 0 &&
	                options.hasOwnProperty('companionContainers')) {
	                companionAdsObj = APN_CompanionManager.renderCompanions(currentVastObj.companionAds, options, companionCallback);
	            }
	        }


	        //Changes made by mobile team to send callback for quartile trackers fired
	        if (invokeEventName === "video-first-quartile" || invokeEventName === "video-mid" || invokeEventName === "video-third-quartile") {
	            if (quartileCallback && typeof(quartileCallback) === "function") {
	                quartileCallback(invokeEventName);
	            }
	        }

	        if (invokeEventName === "video-complete") {
	            if (completeCallback && typeof(completeCallback) === "function") {
	                completeCallback(invokeEventName);
	            }
	        }

	        if (invokeEventName === "audio-mute" || invokeEventName === "audio-unmute") {
	            if (audioCallback && typeof(audioCallback) === "function") {
	                audioCallback(invokeEventName);
	            }
	        }
	        // send callback when the video is clicked so that we can open it with mraid
	        // for pricecheck for the mobile team
	        if (invokeEventName === "video-click-open-url") {
	            clickOpenUrlCallback(eventObject);
	        }
	        //END


	    };

	    // only events without data could be delayed
	    var cbDelayEventsTracking = function (delay, events) {
	    	delayTracking = delay;
	    	if (delayTracking) {
	    		arrDelayEvents = events;
	    	} else {
	            for (var i = 0; i < arrReadyEvents.length; i++) {
	                APN_TrackingManager.requestTracking(arrReadyEvents[i], adId);
	            }
	            arrDelayEvents = [];
	            arrReadyEvents = [];
	    	}
	    };

	    //function for registring tracking event based on impbus object
	    var fnRegisterTracking = function (vastObject) {
	        vastVersion = vastObject.vastVersion;

	        //prepare tracking manager
	        var unrestrictedEvents = [
	            "video-pause",
	            "video-play",
	            "video-fullscreen",
	            "ad-click",
	            "rewind",
	            "video-resume",
	            "audio-mute",
	            "audio-unmute",
	            "video-fullscreen",
	            "video-exit-fullscreen",
	            "ad-expand",
	            "ad-collapse",
	            "ad-progress",
	            "creative-view"
	        ];


	        //add unresticted rule for ad icon
	        if (vastObject && vastObject.icons && vastObject.icons.length > 0) {
	            for (var idx_icon = 0; idx_icon < vastObject.icons.length; idx_icon++) {
	                var icon = vastObject.icons[idx_icon];
	                if (icon && icon.IconViewTracking && icon.IconViewTracking.length > 0) {
	                    unrestrictedEvents.push("IconViewTracking_" + icon.program);
	                }
	                if (icon && icon.IconClickTracking && icon.IconClickTracking.length > 0) {
	                    unrestrictedEvents.push("IconClickTracking_" + icon.program);
	                }
	            }
	        }


	        APN_TrackingManager.init(unrestrictedEvents, adId);//set unrestricted event (multiple invokes)

	        //register all tracking nodes in trackins
	        APN_TrackingManager.addTrackingEvents(vastObject.trackingUrls, adId);
	        //console.log(vastObject.trackingUrls);

	        //register indivisual tracking
	        /*
	         elemenet to be handled by
	         vastObject.clickTrackingUrls
	         vastObject.clickUrls
	         vastObject.errorUrls
	         vastObject.impressionUrls
	         vastObject.trackingUrls
	         */


	        var cnt;
	        var url;

	        //handle clickTrackingUrls
	        var clickTrackingUrls = vastObject.clickTrackingUrls;
	        for (cnt = 0; cnt < clickTrackingUrls.length; cnt++) {
	            url = clickTrackingUrls[cnt];
	            debug("register clickTrackingUrls : " + url);
	            APN_TrackingManager.addTrackingEvent("ad-click", url, adId);//TODO make sure eventname
	        }


	        //handle errorUrls
	        var errorUrls = vastObject.errorUrls;

	        for (cnt = 0; cnt < errorUrls.length; cnt++) {
	            url = errorUrls[cnt];
	            debug("register errorUrls  : " + url);
	            APN_TrackingManager.addTrackingEvent("error", url, adId);
	        }
	        //handle impressionUrls
	        var impressionUrls = vastObject.impressionUrls;

	        for (cnt = 0; cnt < impressionUrls.length; cnt++) {
	            url = impressionUrls[cnt];
	            debug("register impressionUrls  : " + url);
	            APN_TrackingManager.addTrackingEvent("impression", url, adId);
	        }

	        //handle Notify URL:
	        var notifyUrl = vastObject.notifyurl;

	        if ((isWaterfall || options.overlayPlayer) && notifyUrl) {
	            debug("register notifyurl  : " + notifyUrl);
	            APN_TrackingManager.addTrackingEvent("notifyurl", notifyUrl, adId);
	        }

	        //handle adicon tracking
	        //IconViewTracking, IconClickTracking
	        if (vastObject && vastObject.icons && vastObject.icons.length > 0) {
	            for (var idx_icon_trk = 0; idx_icon_trk < vastObject.icons.length; idx_icon_trk++) {
	                var icon_tracking = vastObject.icons[idx_icon_trk];

	                if (icon_tracking && icon_tracking.IconViewTracking && icon_tracking.IconViewTracking.length > 0) {
	                    for (var idx_icon_trk_view = 0; idx_icon_trk_view < icon_tracking.IconViewTracking.length; idx_icon_trk_view++) {
	                        var IconViewTrackingForRegister = icon_tracking.IconViewTracking[idx_icon_trk_view];
	                        APN_TrackingManager.addTrackingEvent("IconViewTracking_" + icon_tracking.program, IconViewTrackingForRegister, adId);
	                        debug("register " + IconViewTrackingForRegister + "_" + icon_tracking.program + " for icon IconViewTracking");
	                    }
	                }

	                if (icon_tracking && icon_tracking.IconClickTracking && icon_tracking.IconClickTracking.length > 0) {
	                    for (var idx_icon_trk_click = 0; idx_icon_trk_click < icon_tracking.IconClickTracking.length; idx_icon_trk_click++) {
	                        var IconClickTrackingForRegister = icon_tracking.IconClickTracking[idx_icon_trk_click];
	                        APN_TrackingManager.addTrackingEvent("IconClickTracking_" + icon_tracking.program, IconClickTrackingForRegister, adId);
	                        debug("register " + IconClickTrackingForRegister + "_" + icon_tracking.program + " for icon IconClickTracking");
	                    }
	                }
	            }
	        }
	    };

	    var setWaterfallTimeout = function(){
	        if (isWaterfall && !waterfallTimeoutHandler) {
	            waterfallStartTimestamp = new Date().getTime();
	            waterfallTimeoutHandler = setTimeout(function () {
	                waterfallTimeoutOccurred = true;
	            }, waterfallTimeout);
	        }
	    };

	    //callback to handle a step from vast varser
	    var cbHandlingRendition = function (vastObject) {

	        var errorDescr;
	        try {
	            fnRegisterTracking(vastObject);//regist tracking event
	            APN_RenditionManager.init(vastObject.mediaFiles);
	            var renditionResult = APN_RenditionManager.getUrl(options.width, options.height, null, options);


	            if (renditionResult !== null && renditionResult.success === true) {

	                //expected result from rendtion manager
	                /*
	                 renditionResult.bitrate;
	                 renditionResult.delivery;
	                 renditionResult.width;
	                 renditionResult.height;
	                 renditionResult.maintainAspectRatio;
	                 renditionResult.scalable;
	                 renditionResult.type;
	                 renditionResult.url;
	                 renditionResult.variation;
	                 renditionResult.requiredPlayer;//0 - any, 1 - html5, 2 - flash
	                 */

	                //VIDLA-2240
	                options.finalVastUri = vastObject.finalVastUri;


	                //define options by result of rendition manager
	                options.video = {};
	                options.video.url = renditionResult.url;

	                options.video.width = renditionResult.width;
	                options.video.height = renditionResult.height;

	                // set viewability configuration parameters from vastObject
	                if (!useViewabilityFromOptions) {
	                	if (vastObject.viewabilityConfig) {
	                		options.viewability = {config: vastObject.viewabilityConfig};
	                	}
	                	else {
	                		options.viewability = null;
	                	}
	                }

	                if (vastObject.userSyncUrl) {
	                	options.usersync_url = vastObject.userSyncUrl;
	                }

	                //add AdIcon to share by options.data.xxx
	                options.data.adIcons = (vastObject && vastObject.icons) ? vastObject.icons : null;

	                //set vast skippable here for VIDLA-92
	                options.data.skipOffset = (vastObject && vastObject.skipOffset) ? vastObject.skipOffset : "";

	                //gather progress event
	                var vastProgressEvent = {};
	                for (var tmp in vastObject.trackingUrls) {
	                    if (tmp.indexOf("progress_") >= 0) {
	                        vastProgressEvent[tmp] = null;
	                    }
	                }

	                options.data.vastProgressEvent = vastProgressEvent;

	                if (renditionResult.maintainAspectRatio && renditionResult.maintainAspectRatio !== undefined) {
	                    options.video.maintainAspectRatio = renditionResult.maintainAspectRatio;
	                    options.maintainAspectRatio = renditionResult.maintainAspectRatio;
	                } else {
	                    options.video.maintainAspectRatio = true;
	                    options.maintainAspectRatio = true;
	                }

	                if (renditionResult.scalable && renditionResult.scalable !== undefined) {
	                    options.video.scalable = renditionResult.scalable;
	                    options.canScale = renditionResult.scalable;
	                } else {
	                    options.video.scalable = true;
	                    options.canScale = true;
	                }

	                options.video.apiFramework = renditionResult.apiFramework;
	                options.video.type = renditionResult.type;
	                options.requiredPlayer = renditionResult.requiredPlayer;
	                options.videoUrl = renditionResult.url;//TODO refactoricing needed
	                options.clickUrls = vastObject.clickUrls;
	                options.adParameters = vastObject.adParameters;	//TODO check adParams
	                options.extensions = vastObject.extensions;
	                options.data.vastDurationMsec = vastObject.durationMsecs;

	                // If a companion ad for end-card enabled then save them in the options so end card has access to them.
	                if (options.endCard && options.endCard.showCompanion && vastObject.companionAds) {
	                    options.endCard.companionAds = vastObject.companionAds.companions;
	                    options.endCard.companionCallback = companionCallback;  // use same callback function in end card
	                }

	                if (options.video.apiFramework && options.video.apiFramework.toLowerCase().indexOf('vpaid') >= 0) {
	                    options.vpaid = true;
	                } else {
	                    options.vpaid = false;
	                }

	                // no replay for vpaid
	                if (replayObjectExists) {
	                    options.disableCollapse.replay = options.vpaid ? false : originalReplayValue;
	                }

	                //define target element in publisher page
	                options.targetElement = targetElement;

	                //link dispatch callback
	                cbAdunits.cbForHandlingDispatchedEvent = cbForHandlingDispatchedEvent;
	                cbAdunits.cbDelayEventsTracking = cbDelayEventsTracking;

	                //override cbWhenReady to insert a logic to get duration of video metadata, usually this logic will get called by playerManager when it got video-meta-data to norify video is ready to play
	                var original_cbWhenReady = cbAdunits.cbWhenReady;//keep original function reference

	                cbAdunits.cbWhenReady = function(playerManager) {//override
	                    //set VAST3 attributes to options
	                    playerManager.setVastAttribute();

	                    // @exclude
	                    //do unit test if it's configured by options
	                    playerManager.test("VIDLA163", playerManager.options.data);
	                    // @endexclude

	                    //call original cbWhenReady callback to continue a flow
	                    original_cbWhenReady(playerManager);
	                };
	                //render video
	                cbAdunits.cbRenderVideo(cbAdunits, options, setWaterfallTimeout);

	                isDoneCbHandlingRendition = true;

	                currentVastObj = vastObject;
	                return;
	            } else {
	                isDoneCbHandlingRendition = true;
	                cbAdunits.cbWhenDestroy({
	                    type: 1,
	                    code: renditionResult.errorCode,
	                    message: "Unable to select rendition"
	                });
	                return;
	            }

	        } catch (ex) {
	            debug(ex);
	            errorDescr = 'Exception error: ' + ex;
	        }

	        isDoneCbHandlingRendition = true;
	        cbAdunits.cbWhenDestroy({type: 0, code: 0, message: errorDescr});
	    };

	    var handleNextAd = function(vastObj) {
	        isDoneCbHandlingRendition = false;

	        if (vastObj) {
	            cbHandlingRendition(vastObj);
	        }
	    };

	    var handleStepLimit = function () {
	        if (options._vastObjArr.length) {
	            var nextAd = options._vastObjArr.shift();
	            reportWaterfallTracker(nextAd, WF_STATUS_STEP_LIMIT, adCount);
	        }
	    };

	    var getRtbAd = function() {
	        var obj = null;

	        if (rtbAd) {
	            obj = rtbAd;
	            rtbAd = null;
	        } else {
	            handleStepLimit();
	        }

	        return obj;
	    };

	    var getNextEligibleAd = function(totalNonRtbAttempts) {
	        var obj = null;

	        if (adCount < totalNonRtbAttempts) {
	            obj = options._vastObjArr.shift();
	        } else {
	            obj = getRtbAd();
	        }

	        return obj;
	    };

	    var getNextAd = function() {
	        isDoneCbHandlingRendition = false;
	        var vastObj = null;

	        if (options._vastObjArr && isWaterfall) {
	            switch (waterfallSteps){
	                case 0:
	                    if (adCount === 0) {
	                        vastObj = options._vastObjArr.shift();
	                        if (!vastObj) {
	                            vastObj = getRtbAd();
	                        }
	                    }
	                    break;
	                case -1:
	                    vastObj = getNextEligibleAd(maxNonRtbAdCount);
	                    break;
	                default:
	                    if(waterfallSteps < maxNonRtbAdCount){
	                        vastObj = getNextEligibleAd(waterfallSteps);
	                    } else {
	                        vastObj = getNextEligibleAd(maxNonRtbAdCount);
	                    }
	                    break;
	            }
	        } else {
	            vastObj = options._vastObjArr.shift();
	        }

	        currentAd = vastObj;
	        adCount++;
	        printWaterfallLog(true, null, null);

	        if (vastObj) {
	            adId = vastObj.adId;
	        }

	        return vastObj;
	    };

	    var cbHandlingParsedVAST = function (succ, id, vast, errorUrls, notifyurl){

	        if (succ) {
	            if (Array.isArray(vast)) {
	                // VID-1861 Disable waterfall when non inline IOS player is used due to autoplay limitation
	                if (!isIos() ||(isIos() && options.enableInlineVideoForIos)) {
	                    // Ad Waterfall is on.
	                    isWaterfall = true;
	                    options.isWaterfall = true;
	                    options._vastObjArr = vast;
	                    totalAvailableAds = options._vastObjArr.length;
	                    // find Rtb Ad
	                    for (var index= 0; index< options._vastObjArr.length; index++) {
	                        var obj= options._vastObjArr[index];
	                        if (obj.rtb) {
	                            rtbAd = obj;
	                            options._vastObjArr.splice(index, 1);
	                            break;
	                        }
	                    }
	                    maxNonRtbAdCount = options._vastObjArr.length;
	                } else{
	                    isWaterfall = false;
	                    options._vastObjArr = vast;
	                }
	            } else {
	                //if not water fall
	                isWaterfall = false;
	                options._vastObjArr.push(vast);
	            }
	            var vastObj = getNextAd();
	            if(vastObj) {
	                handleNextAd(vastObj);
	            }
	        }
	        else {
	            if(notifyurl && notifyurl.length > 0){
	                // VIDLA-1748 If a valid Notify url is sent by the VAST parser then
	                // this implies that waterfall has encountered a parsing issue, eg: compatible media etc
	                // We register the url and immediately fire it
	                APN_TrackingManager.addTrackingEvent("notifyurl", notifyurl, id);
	                APN_TrackingManager.requestTracking("notifyurl", id);
	            }
	            //if not successful by vast-parser
	            var msg = "Vast Parser error (" + vast + ")";

	            //register error tracking to handle errorUrls if errorUrls returns from vast parser in order to handle internal error happened from vast parser
	            if (errorUrls && errorUrls.length > 0) {
	                errorUrls.forEach(function(url) {
	                    debug("register errorUrls  : " + url);
	                    APN_TrackingManager.addTrackingEvent("error", url, adId);
	                });
	                cbAdunits.cbWhenDestroy({type: ERROR_TYPE_VAST, code: VAST_ERROR_UNDEFINED, message: msg});
	            } else {
	                cbAdunits.cbWhenDestroy({type: 0, code: 0, message: msg});
	            }

	        }
	    };


	    cbAdunits.cbWhenDestroy = function (errorObject, keepFullscreen, _options) {

	        //errorObject.type: type of error (0 = general appnexus error, 1 = vast-error (one of the error codes specified in the VAST spec), 2 = http error
	        //errorObject.code: code for identifying error condition
	        //errorObject.message: message of error

	        // Default to use global options if no options were given (VIDLA-1834)
	        if (!_options) {
	            _options = options;
	        }

	        if (_options.stopWaterfall) {
	            isWaterfall = _options.isWaterfall;
	        }

	        if(isWaterfall){
	            if( _options && _options.waterfallStepId !== options.waterfallStepId){
	                return;
	            }
	            options = _options;
	            printWaterfallLog(false, false, errorObject);
	        }

	        if(isWaterfall && !impressionSent && !waterfallTimeoutOccurred){
	            var nextAd = getNextAd();
	            if(nextAd){
	                handleNextAd(nextAd);
	                return;
	            }
	        }

	        if (errorObject && typeof(errorObject.type) !== "undefined") {
	            debug("requesting error in whenDestroy callback : " + errorObject.code + "," + errorObject.type + "," + errorObject.message);
	            // VID-2661 - Decision to not report Errors once Impression is sent(as Vast 3.0 spec says report errors before Ad Load.)
	            // Deferring skipOffset error reporting mentioned in Vast 3.0 TODO: need to decide on that with product
	            if(!impressionSent){
	                if(!options.overlayWaterfall){
	                    if(isWaterfall || _options.stopWaterfall) {
	                        // VIDLA-1743 As Waterfall  has either timeouted out or For final error in waterfall we would be requesting notifyurl;
	                        APN_TrackingManager.requestTracking("notifyurl", adId);
	                    }
	                }
	                if (options.overlayPlayer) {
	                    // The error tracking happens at a higher level. (VIDLA-1843)
	                    var errorUrls = APN_TrackingManager.requestErrorTrackingUrls(errorObject.code, errorObject.type, errorObject.message, adId);
	                    errorObject.errorUrls = errorUrls;
	                } else {
	                    APN_TrackingManager.requestErrorTracking(errorObject.code, errorObject.type, errorObject.message, adId);
	                }
	            }else{
	                debug("not requesting error tracker because the Ad Impression was already reported");
	            }
	        } else {
	            debug("requesting error in whenDestroy callback : " + errorObject + "," + (errorObject ? true : false));
	        }

	        if (companionAdsObj) {
	            APN_CompanionManager.stopCompanions(companionAdsObj);
	            companionAdsObj = null;
	        }

	        //invoke override whenDestory callback
	        if (typeof(tmpCallback) === "function") {
	            tmpCallback(errorObject ? errorObject : false, keepFullscreen);
	        }
	    };


	    //get value from vastXM to decide video URL
	    if (options !== undefined && options && options.vastXml) {
	        setTimeout(function () {
	            if (!isDoneCbHandlingRendition) {
	                cbAdunits.cbWhenDestroy({type: 0, code: 0, message: "VAST Parser didn't answer until timeout"});
	            }

	        }, timeToWaitFor);
	        debug("Ad XML : " + options.vastXml);

	        //APNVideo_VastParser.parse(options.vastXml, cbHandlingParsedVAST, null, 2000, null, null, options);
	        APNVideo_VastParser.parse(
	            options.vastXml,
	            function(succ, id, vast, errorUrls, notifyurl) {
	                options.finalVastXml = (vast && vast.vastXml) ? vast.vastXml : "";//final vast xml which vast parser set //VIDLA-2241
	                cbHandlingParsedVAST(succ, id, vast, errorUrls, notifyurl);
	            },
	            null,
	            2000,
	            null,
	            null,
	            options
	        );
	    }

	    //get value from adObj to decide video URL
	    if (options !== undefined && options && options.useAdObj && options.adObj) {
	        cbHandlingRendition(options.adObj);
	    }
	};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VAST Parser module.
	 * @module VastParser
	 */

	var VastXMLParserHelper = __webpack_require__(54);

	var APN_CompanionAds = __webpack_require__(55);
	var APN_Icons = __webpack_require__(56);

	var uaParser = __webpack_require__(13);
	var ua = uaParser();

	var VastParser = function (id, nMsecTimeout, options) {

	    var _logger = __webpack_require__(9);
	    var _prefix = 'VAST Parser';

	    var _callback = null;
	    var _options = options;
	    var _sourceVastXml = null;
	    var _id = id;
	    var _nTimeOut = nMsecTimeout && nMsecTimeout > 0 ? nMsecTimeout : 1000;	// 1 second default
	    var _arrMediaFiles = [],
	    	_mezzanine = null,
	    	_arrInteractiveCreatives = [],
	        _arrTrackings = {},
	        _arrImpressions = [],
	        _arrClickUrls = [],
	        _arrClickTrackings = [],
	        _arrErrorUrls = [],
	        _arrInternalErrorUrls = [],
	        _sExtensions = '',
	        _adParameters = '',
	        _nMsecDuration = 0,
	        _strSkipOffset = '';
	    
	    var _errors303 = null;
	    var _arrError303Urls = [];

	    var _arrTrackingsMerge = {},
	        _arrImpressionsMerge = [],
	        _arrClickUrlsMerge = [],
	        _arrClickTrackingsMerge = [],
	        _arrErrorUrlsMerge = [],
	    	_arrViewableImpressionsMerge = {viewable: [], notViewable: [], undeterminated: []};

	    var _helper = new VastXMLParserHelper();
	    var _startTime = null;
	    var _withWrapper = false;
	    var _vastVersion = '';
	    var _conditionalAd = false;
	    var _fallbackOnNoAd;

	    var _adTree = [];
	    var _currTreeIdx = -1;

	    var _terminated = false;

	    var _capabilityDetection = __webpack_require__(57);

	    var _waterfall = false;
	    var _vastObjects = [];
	    var _topLevel = false;
	    var _notifyurls = {};
	    var _curNotifyUrl = '';
	    var _buyerMemberIds = {};
	    var _curBuyerMemberId = '';
	    var _viewabilityConfigs = {};
	    var _curViewabilityConfig = '';
	    var _creativeIds = {};
	    var _curCreativeId = '';

	    var _csmCount = 0;
	    var _rtbCount = 0;
	    
	    var _vmap = options.vmap;

	    var _finalVastUri = '';//VIDLA-2240 to keep final VAST URI

	    _logger.always(_prefix, 'Version 3.1.12');

	    function getVASTVersion(vastNode) {
	        var version = 'unknown';
	        if (vastNode) {
	            version = _helper.getNodeAttributeValue(vastNode, 'version');
	            version = version.trim();
	            if (version.length > 3) {
	                version = version.substr(0, 3);
	            }
	        }
	        return version;
	    }

	    function substituteErrorCode(arrErrorUrls, errorCode) {
	        if (arrErrorUrls && arrErrorUrls.length > 0) {
	            for (var i = 0; i < arrErrorUrls.length; i++) {
	                arrErrorUrls[i] = arrErrorUrls[i].replace('[ERRORCODE]', errorCode);
	            }
	        }
	    }

	    function traceTreePath(idx, message) {
	        var curIdx = idx;
	        var text = 'AD DETECTED=' + (message.substr(0, 7) === 'SUCCESS' ? 'SUCCESS' : 'NONE') + ' :: Reason=' + message +
	            ', playerTechnology=' + (_options.hasOwnProperty('playerTechnology') ? JSON.stringify(_options.playerTechnology) : 'unknown') +
	            ', platform=' + _capabilityDetection.getPlatformType() + ', Ad tree path=';
	        var tree = '';
	        while (curIdx !== -1) {
	            var ad = _adTree[curIdx].children[0];
	            if (ad) {
	                var val = _helper.getNodeAttributeValue(ad, 'id');
	                if (tree.length > 0) {
	                    tree = ' -> ' + tree;
	                }
	                tree = val + tree;
	            }
	            curIdx = _adTree[curIdx].parentIdx;
	        }
	        _logger.info(_prefix, text + tree);
	    }

	    function processWrapper(parentNode) {
	        var node = _helper.getSubNode(parentNode, 'VASTAdTagURI');
	        if (!node) {
	            traceTreePath(_currTreeIdx, 'INVALID WRAPPER NODE');
	            if (_adTree.length === 0) {
	                reportError('300', 'invalid wrapper node');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        var url = _helper.getNodeValues(node);
	        if (!url || url.length === 0) {
	            traceTreePath(_currTreeIdx, 'EMPTY VASTAdTagURI');
	            if (_adTree.length === 0) {
	                reportError('300', 'Invalid VASTAdTagURI node value');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }

	        if (_terminated) {
	            traceTreePath(_currTreeIdx, 'terminated');
	            _callback(false, _id, 'terminated', null, _curNotifyUrl);		// terminated
	            return;
	        }

	        _withWrapper = true;
	        
	        if (_vastVersion === '4.0') {
	        	var val = _helper.getNodeAttributeBooleanValue(parentNode, 'followAdditionalWrappers', true);
	        	_adTree[_currTreeIdx].state.followAdditionalWrappers = val;
	        	
	        	val = _helper.getNodeAttributeBooleanValue(parentNode, 'allowMultipleAds', false);
	        	_adTree[_currTreeIdx].state.allowMultipleAds = val;
	        	
	        	val = _helper.getNodeAttributeValue(parentNode, 'fallbackOnNoAd');
	        	if (val !== '') {
	        		_fallbackOnNoAd = _helper.getNodeAttributeBooleanValue(parentNode, 'fallbackOnNoAd');
	        	}
	        }

	        //keep final URI for VIDLA-2240
	        _finalVastUri = url;

	        var UrlLoader = __webpack_require__(24);
	        UrlLoader.load(url,
	            function (error, responseText) {
	                if (_terminated) {
	                    traceTreePath(_currTreeIdx, 'terminated');
	                    _callback(false, _id, 'terminated', null, _curNotifyUrl);		// terminated
	                    return;
	                }
	                if (error || responseText.length === 0) {
	                    traceTreePath(_currTreeIdx, 'VASTAdTagURI TIMED OUT: ' + url);
	                    if (_adTree.length === 0) {
	                        reportError('301', 'Timeout of VAST URI provided in wrapper element');
	                    }
	                    else {
	                        processNextAd();
	                    }
	                }
	                else {
	                    _topLevel = false;
	                    parseXML(responseText);
	                }
	            }, _options.adServerTimeout ? _options.adServerTimeout : _nTimeOut);
	    }

	    function isInArray(arr, value) {
	        for (var i = 0; i < arr.length; i++) {
	            if (arr[i] === value) {
	                return true;
	            }
	        }
	        return false;
	    }

	    function addErrorUrls(parentNode, arrErrorUrls) {
	        if (parentNode) {
	            var nodes = _helper.getSubNodes(parentNode, 'Error');
	            if (nodes) {
	                for (var i = 0; i < nodes.length; i++) {
	                    var node = nodes[i];
	                    var url = _helper.getNodeValues(node);
	                    if (url && !isInArray(arrErrorUrls, url)) {
	                        arrErrorUrls.push(url);
	                    }
	                }
	            }
	        }
	    }

	    function addImpressions(parentNode, arrImpressions) {
	        if (parentNode) {
	            var nodes = _helper.getSubNodes(parentNode, 'Impression');
	            if (nodes) {
	                for (var i = 0; i < nodes.length; i++) {
	                    var node = nodes[i];
	                    var url = _helper.getNodeValues(node);
	                    if (url && !isInArray(arrImpressions, url)) {
	                        arrImpressions.push(url);
	                    }
	                }
	            }
	        }
	    }

	    function addTrackings(parentNode, arrTrackings) {
	        //var _nMsecDuration;
	        if (parentNode) {
	            var linear = _helper.getSubNode(parentNode, 'Linear', 0);
	            if (linear) {

	                //comment out by VIDLA-163
	                //var duration_node = _helper.getSubNode(linear, 'Duration');
	                //if (duration_node) {
	                //var str = _helper.getNodeValue(duration_node);
	                //_nMsecDuration = getMsecTime(str, -1);
	                //}


	                var node = _helper.getSubNode(linear, 'TrackingEvents');
	                if (node) {
	                    var nodes = _helper.getSubNodes(node, 'Tracking');
	                    if (nodes) {
	                        for (var i = 0; i < nodes.length; i++) {
	                            node = nodes[i];
	                            var url = _helper.getNodeValues(node);
	                            if (url) {


	                                var event = _helper.getNodeAttributeValue(node, 'event');

	                                //VIDLA-422 progress event also can be multiple in wrapper case
	                                if (event === 'progress') {
	                                    var offset = _helper.getNodeAttributeValue(node, 'offset');
	                                    if (offset) {
	                                        //event = 'progress_' + getMsecTime(offset,_nMsecDuration);
	                                        event = 'progress_' + offset;
	                                    } else {
	                                        event = '';
	                                    }
	                                }
	                                if (event) {
	                                    if (arrTrackings.hasOwnProperty(event)) {
	                                        if (!isInArray(arrTrackings[event], url)) {
	                                            arrTrackings[event].push(url);
	                                        }
	                                    }
	                                    else {
	                                        arrTrackings[event] = [];
	                                        arrTrackings[event].push(url);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }

	    function addExtensions(parentNode, treeIdx) {
	        if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'Extensions');
	            if (node && node.innerHTML && node.innerHTML.length > 0) {
	                _adTree[treeIdx].state.sExtensions = _adTree[treeIdx].state.sExtensions + node.innerHTML.toString();
	            }
	            else if (node && node.textContent && node.textContent.length > 0) {
	                _adTree[treeIdx].state.sExtensions = _adTree[treeIdx].state.sExtensions + node.textContent.toString();
	            }
	        }
	    }

	    function addCompanions(parentNode, treeIdx) {
	        if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'CompanionAds');
	            if (node &&
	                ((node.innerHTML && node.innerHTML.length > 0) ||
	                (node.textContent && node.textContent.length > 0))) {
	                APN_CompanionAds.parse(_adTree[treeIdx].state.companions, node, _helper);
	            }
	        }
	    }

	    function addIcons(parentNode, treeIdx) {
	        if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'Icons');
	            if (node &&
	                ((node.innerHTML && node.innerHTML.length > 0) ||
	                (node.textContent && node.textContent.length > 0))) {
	                APN_Icons.parse(_adTree[treeIdx].state.icons, node, _helper);
	            }
	        }
	    }

	    function addClickUrls(parentNode, arrClickUrls, arrClickTrackings) {
	        if (parentNode) {
	            var linear = _helper.getSubNode(parentNode, 'Linear', 0);
	            if (linear) {
	                var url = null;
	                var parentNode2 = _helper.getSubNode(linear, 'VideoClicks');
	                if (parentNode2) {
	                    var node = _helper.getSubNode(parentNode2, 'ClickThrough');
	                    if (node) {
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrClickUrls, url)) {
	                            arrClickUrls.push(url);
	                        }
	                    }
	                    var nodes = _helper.getSubNodes(parentNode2, 'ClickTracking');
	                    if (nodes) {
	                        for (var i = 0; i < nodes.length; i++) {
	                            node = nodes[i];
	                            url = _helper.getNodeValues(node);
	                            if (url && !isInArray(arrClickTrackings, url)) {
	                                arrClickTrackings.push(url);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }

	    function addViewableImpression(parentNode, arrViewableImpression) {
	        if (parentNode) {
	            var viewImps = _helper.getSubNode(parentNode, 'ViewableImpression', 0);
	            if (viewImps) {
	                var url = null;
	                var node = null;
	                var i;
	                var subNodes = _helper.getSubNodes(viewImps, 'Viewable');
	                if (subNodes && subNodes.length > 0) {
	                    for (i = 0; i < subNodes.length; i++) {
	                        node = subNodes[i];
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrViewableImpression.viewable, url)) {
	                        	arrViewableImpression.viewable.push(url);
	                        }
	                    }
	                }
	                subNodes = _helper.getSubNodes(viewImps, 'NotViewable');
	                if (subNodes && subNodes.length > 0) {
	                    for (i = 0; i < subNodes.length; i++) {
	                        node = subNodes[i];
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrViewableImpression.notViewable, url)) {
	                        	arrViewableImpression.notViewable.push(url);
	                        }
	                    }
	                }
	                subNodes = _helper.getSubNodes(viewImps, 'ViewUndeterminated');
	                if (subNodes && subNodes.length > 0) {
	                    for (i = 0; i < subNodes.length; i++) {
	                        node = subNodes[i];
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrViewableImpression.undeterminated, url)) {
	                        	arrViewableImpression.undeterminated.push(url);
	                        }
	                    }
	                }
	            }
	        }
	    }

	    function getMsecTime(strTime, duration) {
	        var nPos = strTime.indexOf('%');
	        if (nPos > 0) {
	            if (duration && duration > 0) {
	                return Number(strTime.substring(0, nPos));
	            }
	            else {
	                return 0;
	            }
	        } else {
	            nPos = strTime.indexOf('.');
	            var msecs = nPos > 0 ? Number(strTime.substring(nPos + 1)) : 0;
	            if (nPos > 0) {
	                strTime = strTime.substring(0, nPos);
	            }
	            var arr = strTime.split(':');
	            if (arr.length === 3) {
	                return (Number(arr[0]) * 3600 + Number(arr[1]) * 60 + Number(arr[2])) * 1000 + msecs;
	            }
	            else {
	                return 0;
	            }
	        }
	    }

	    function isCapable(type, codec) {
	        return _capabilityDetection.canPlay(type, codec);
	    }

	    function isFlashOnlyType(type) {
	        return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
	            type === 'application/x-shockwave-flash';
	    }

	    function isHtml5OnlyType(type) {
	        return type === 'video/webm' || type === 'video/ogg' || type === 'application/javascript' ||
	            type === 'application/x-javascript';
	    }

	    function isVpaidType(type) {
	        return type === 'application/x-shockwave-flash' || type === 'application/javascript' ||
	            type === 'application/x-javascript';
	    }

	    function isOptionsValidated(type) {
	        if (_options.playerTechnology && Array.isArray(_options.playerTechnology) && _options.playerTechnology.length > 0) {
	            var supported = false;
	            for (var i = 0; i < _options.playerTechnology.length; i++) {
	                var tech = _options.playerTechnology[i].toLowerCase();
	                if (!isFlashOnlyType(type.toLowerCase()) && !isHtml5OnlyType(type.toLowerCase())) {
	                    supported = true;
	                    break;
	                }
	                if (tech === 'flash' && !isHtml5OnlyType(type.toLowerCase())) {
	                    supported = true;
	                    break;
	                }
	                if (tech === 'html5' && !isFlashOnlyType(type.toLowerCase())) {
	                    supported = true;
	                    break;
	                }
	            }
	            if (!supported) {
	                return false;
	            }
	        }
	        if (_options.hasOwnProperty('supportVpaid') && !_options.supportVpaid) {
	            if (isVpaidType(type.toLowerCase())) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function configureMediaRendition(node, url, num, mediaTypes) {
	        var rendition = null;
	        if (node) {
	            rendition = {};
	            rendition.type = _helper.getNodeAttributeValue(node, 'type');
	            if (mediaTypes.indexOf(rendition.type) === -1) {
	                mediaTypes.push(rendition.type);
	            }
	            // check capability
	            if (!rendition.type || rendition.type.length === 0) {
	                return null;
	            }
	            var codec = _helper.getNodeAttributeValue(node, 'codec');
	            if (codec && codec.length > 0) {
	                rendition.codec = codec;
	            }
	            if (!isCapable(rendition.type, codec)) {
	                return null;
	            }
	            if (_options) {
	                if (!isOptionsValidated(rendition.type)) {
	                    return null;
	                }
	            }
	            rendition.url = url;
	            rendition.variation = 'Media#' + num;
	            rendition.delivery = _helper.getNodeAttributeValue(node, 'delivery');
	            var bitrate = _helper.getNodeAttributeNumberValue(node, 'bitrate', -1);
	            if (bitrate !== -1) {
	                rendition.bitrate = bitrate;
	            }
	            rendition.width = _helper.getNodeAttributeNumberValue(node, 'width');
	            rendition.height = _helper.getNodeAttributeNumberValue(node, 'height');
	            var valNode = _helper.getNodeAttributeValue(node, 'scalable');
	            if (valNode.length > 0) {
	                rendition.scalable = _helper.getNodeAttributeBooleanValue(node, 'scalable', true);
	            }
	            valNode = _helper.getNodeAttributeValue(node, 'maintainAspectRatio');
	            if (valNode.length > 0) {
	                rendition.maintainAspectRatio = _helper.getNodeAttributeBooleanValue(node, 'maintainAspectRatio', true);
	            }
	            var apiFramework = _helper.getNodeAttributeValue(node, 'apiFramework');
	            if (apiFramework && apiFramework.length > 0) {
	                rendition.apiFramework = apiFramework.toUpperCase();
	            }
	        }

	        return rendition;
	    }

	    function addMediaFilesAndDuration(parentNode) {
	        _nMsecDuration = 0;
	        _strSkipOffset = '';
	        _adParameters = '';
	        _arrMediaFiles = [];
	    	_mezzanine = null;
	    	_arrInteractiveCreatives = [];
	        var message = '';
	        var mediaTypes = [];
	        if (parentNode) {
	            var linear = _helper.getSubNode(parentNode, 'Linear', 0);
	            if (linear) {
	                var node = _helper.getSubNode(linear, 'Duration');
	                if (node) {
	                    var str = _helper.getNodeValue(node);
	                    _nMsecDuration = getMsecTime(str, -1);
	                }
	                var strSkipOffset = _helper.getNodeAttributeValue(linear, 'skipoffset');

	                //comment out by VIDLA-163
	                //if (strSkipOffset && strSkipOffset.length > 0) {
	                //    _nSkipOffset = getMsecTime(strSkipOffset, _nMsecDuration);
	                //}
	                _strSkipOffset = strSkipOffset;

	                //_adParameters = _helper.getSubNodeValue(linear, 'AdParameters', '');
	                _adParameters = _helper.getSubNodeWholeValue(linear, 'AdParameters', '');

	                node = _helper.getSubNode(linear, 'MediaFiles');
	                if (node) {
	                	var url;
	                    var nodes = _helper.getSubNodes(node, 'MediaFile');
	                    if (nodes) {
	                        for (var i = 0; i < nodes.length; i++) {
	                            node = nodes[i];
	                            url = _helper.getNodeValues(node);

	                            if (url.length > 0) {
	                                var rendition = configureMediaRendition(node, url, i, mediaTypes);

	                                if (rendition) {
	                                    _arrMediaFiles.push(rendition);
	                                }
	                            }
	                        }
	                        if (_arrMediaFiles.length === 0) {
	                            message = 'INCOMPATIBLE MEDIA TYPE, Available = ' + JSON.stringify(mediaTypes);
	                        }
	                        else {
	                        	// for VAST 4
	                            node = _helper.getSubNode(linear, 'MediaFiles');
	                        	_mezzanine = _helper.getSubNodeWholeValue(node, 'Mezzanine', '');
	                        	var interactiveNodes = _helper.getSubNodes(node, 'InteractiveCreativeFile');
	                        	if (interactiveNodes && interactiveNodes.length > 0) {
	                        		for (var j = 0; j < interactiveNodes.length; j++) {
	                        			var interactiveCreative = interactiveNodes[j];
	                        			url = _helper.getNodeValues(interactiveCreative);
	                        			if (url) {
	                        				var type = _helper.getNodeAttributeValue(interactiveCreative, 'type');
	                        				var framework = _helper.getNodeAttributeValue(interactiveCreative, 'apiFramework');
	                        				_arrInteractiveCreatives.push({url: url, type: type, apiFramework: framework});
	                        			}
	                        		}
	                        	}
	                        }
	                    }
	                    else {
	                        message = 'MISSING MEDIA FILES';
	                    }
	                }
	                else {
	                    message = 'MISSING MEDIA FILES';
	                }
	            }
	            else {
	                message = 'INVALID VAST STRUCTURE';
	            }
	        }
	        return message;
	    }

	    function trimXml(strVastXml) {
	        var nPos = strVastXml.indexOf('<');
	        var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
	        nPos = strXml.lastIndexOf('>');
	        if (nPos !== -1) {
	            strXml = strXml.substr(0, nPos + 1);
	        }
	        return strXml.trim();
	    }

	    function isValidVastVersion(vastVersion) {
	        return vastVersion === '2.0' || vastVersion === '3.0' || vastVersion === '4.0';
	    }

	    function reportError(errCode, message) {
	        var arrErrorForInternalAndExternal = _arrErrorUrls.concat(_arrInternalErrorUrls);//merge with internal error and external error
	        substituteErrorCode(arrErrorForInternalAndExternal, errCode);
	        if (_arrError303Urls && _arrError303Urls.length > 0) {
	        	substituteErrorCode(_arrError303Urls, '303');
	        	arrErrorForInternalAndExternal = arrErrorForInternalAndExternal.concat(_arrError303Urls);
	        }
	        _logger.error(_prefix, 'Error ' + errCode + ' - ' + message);
	        _callback(false, _id, 'vast' + errCode, arrErrorForInternalAndExternal, _curNotifyUrl);
	    }

	    function processNextAd() {

	        //push error urls to global variable _arrInternalErrorUrls which has empty array as an default, it will be used for reportError() to return array of error urls to _callback
	        //the _arrInternalErrorUrls will be emptied by processAd() when exit out of siblings and if there's no internal parsing error
	        var arrStateOfNode = _adTree[_currTreeIdx].state;
	        if (arrStateOfNode && Array.isArray(arrStateOfNode.arrErrorUrls)) {
	            arrStateOfNode.arrErrorUrls.forEach(function (element) {
	                _arrInternalErrorUrls.push(element);
	            });
	        }

	        if (_currTreeIdx >= 0) {
	            _adTree[_currTreeIdx].children[0] = null;
	            _adTree[_currTreeIdx].children.splice(0, 1);
	            if (_adTree[_currTreeIdx].children.length === 0) {
	                var parentIdx = _adTree[_currTreeIdx].parentIdx;
	                _adTree.splice(_currTreeIdx, 1);
	                _currTreeIdx = parentIdx;
	                if (_currTreeIdx === -1) {
	                    if (_waterfall && _vastObjects.length > 0) {
	                        _logger.info(_prefix, 'Waterfall: Vast XML node count detected: # csm nodes: ' + _csmCount + ', # rtb nodes: ' + _rtbCount);
	                        _callback(true, _id, _vastObjects, null);
	                    }
	                    else if (_vmap && _vastObjects.length > 0) {
	                        _logger.info(_prefix, 'VMAP: Ad XML node count detected: ' + _vastObjects.length);
	                        _callback(true, _id, _vastObjects, null);
	                    }
	                    else {
	                        reportError('900', 'no Ad available');
	                    }
	                    return;
	                }
	                else {
	                    processNextAd();
	                    return;
	                }
	            }
	            _adTree[_currTreeIdx].state = preapareAdStateData();
	            processAd(_adTree[_currTreeIdx].children[0]);
	        }
	    }

	    function preapareAdStateData() {
	        var state = {
	            arrTrackings: {},
	            arrImpressions: [],
	            arrClickUrls: [],
	            arrClickTrackings: [],
	            arrErrorUrls: [],
	            sExtensions: '',
	            sequence: _vmap ? 0 : 1,
	            companions: {required: 'unknown', companions: []},
	            icons: [],
	            arrViewableImpressions: {viewable: [], notViewable: [], undeterminated: []}
	        };
	        return state;
	    }

	    function saveNotificationUrl(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var url = _helper.getNodeAttributeValue(adNode, 'notifyurl');
	            if (url && url.length > 0) {
	                _notifyurls[id] = url;
	            }
	        }
	    }

	    function saveCreativeId(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var crId = _helper.getNodeAttributeValue(adNode, 'creativeId');
	            if (crId && crId.length > 0) {
	                _creativeIds[id] = crId;
	            }
	        }
	    }

	    function saveBuyerMemberId(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var buyerId = _helper.getNodeAttributeValue(adNode, 'buyerMemberId');
	            if (buyerId && buyerId.length > 0) {
	                _buyerMemberIds[id] = buyerId;
	            }
	        }
	    }

	    function saveViewabilityConfig(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var config = _helper.getNodeAttributeValue(adNode, 'viewabilityConfig');
	            if (config && config.length > 0) {
	                _viewabilityConfigs[id] = config;
	            }
	        }
	    }
	    
	    function saveNoAdsErrors() {
	    	if (_errors303 && _errors303.length > 0) {
	    		for (var i = 0; i < _errors303.length; i++) {
	                var node = _errors303[i];
	                var url = _helper.getNodeValues(node);
	                if (url && !isInArray(_arrError303Urls, url)) {
	                	_arrError303Urls.push(url);
	                }
	    		}
	    	}
	    }

	    function parseXML(strVastXml) {
	        _startTime = (new Date()).getTime();
	    	_arrError303Urls = [];	// make sure we keep error url for last vast

	        _sourceVastXml = strVastXml;
	        var strXml = trimXml(strVastXml);
	        if (strXml.length === 0) {
	            traceTreePath(_currTreeIdx, 'EMPTY VAST');
	            if (_adTree.length === 0) {
	                reportError('110', 'no bid response for mediation');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        var xmlDoc = null;
	        if (typeof window.DOMParser !== 'undefined') {
	            xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
	            if (xmlDoc.documentElement.nodeName === 'parsererror') {
	                try {
	                    _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
	                }
	                catch (e) {
	                }
	                traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	                if (_adTree.length === 0) {
	                    reportError('100', 'VAST XML parsing error');
	                }
	                else {
	                    processNextAd();
	                }
	                return;
	            }
	        }
	        else if (typeof window.ActiveXObject !== 'undefined') {
	            try {
	                xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
	                xmlDoc.loadXML(strXml);
	                if (xmlDoc.parseError.errorCode !== 0) {
	                    _logger.error(_prefix, xmlDoc.parseError);
	                    traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	                    if (_adTree.length === 0) {
	                        reportError('100', xmlDoc.parseError.errorCode + ', Error reason = ' + xmlDoc.parseError.reason);
	                    }
	                    else {
	                        processNextAd();
	                    }
	                    return;
	                }
	            }
	            catch (ex) {
	                _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
	                traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	                if (_adTree.length === 0) {
	                    reportError('100', 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
	                }
	                else {
	                    processNextAd();
	                }
	                return;
	            }
	        }
	        else {
	            _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
	            traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	            if (_adTree.length === 0) {
	                reportError('100', 'Failed to get vast xml');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        if (!xmlDoc) {
	            traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	            if (_adTree.length === 0) {
	                reportError('102', 'VAST XML parsing error');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        var vastNode = _helper.getSubNode(xmlDoc, 'VAST');
	        if (!vastNode || !vastNode.firstChild) {
	            traceTreePath(_currTreeIdx, 'EMPTY VAST');
	            if (_adTree.length === 0) {
	                reportError('110', 'no bid response for mediation');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        
	    	_errors303 = _helper.getSubNodes(vastNode, 'Error');
	 
	        var vastVersion = getVASTVersion(vastNode);
	        if (isValidVastVersion(vastVersion)) {
	            if (_topLevel) {
	                _waterfall = _helper.getNodeAttributeBooleanValue(vastNode, 'apn_waterfall');
	                if (_waterfall) {
	                    _options.waterfall = true;
	                }
	            }
	            var ads = _helper.getSubNodes(vastNode, 'Ad');
	            if (!ads || ads.length === 0) {
	            	saveNoAdsErrors();
	                traceTreePath(_currTreeIdx, 'NO AD NODE');
	                if (_adTree.length === 0) {
	                    reportError('900', 'no Ad available');
	                }
	                else {
	                    processNextAd();
	                }
	                return;
	            }
	            var children = [];
	            for (var i = 0; i < ads.length; i++) {
	            	if (_topLevel) {
	                	// make unique Ad id attribute
	            		var adIdTop = _helper.getNodeAttributeValue(ads[i], 'id');
	            		if (adIdTop) {
	            			adIdTop += ('_suffix' + i);
	            			ads[i].id = adIdTop;
	            		}
	            	}
	            	
	            	if (_vastVersion === '4.0' && _currTreeIdx > 0) {
	            		if (!_adTree[_currTreeIdx].state.allowMultiAds) {
	            			var sequence = _helper.getNodeAttributeValue(ads[i], 'sequence');
	            			if (sequence) {
	            				continue;
	            			}
	            			if (children.length > 0) {
	            				break;
	            			}
	            		}
	            	}
	                children.push(ads[i]);
	                if (_waterfall && _topLevel) {
	                    saveNotificationUrl(ads[i]);
	                }
	                if (_topLevel) {
	                    saveBuyerMemberId(ads[i]);
	                    saveCreativeId(ads[i]);
	                    saveViewabilityConfig(ads[i]);
	                }
	            }
	            if (children.length === 0) {
	            	saveNoAdsErrors();
	                traceTreePath(_currTreeIdx, 'NO VALID AD NODES');
	                if (_adTree.length === 0) {
	                    reportError('900', 'no Ad available');
	                }
	                else {
	                    processNextAd();
	                }
	            	return;
	            }
	            var treeElem = {parentIdx: _currTreeIdx, currentIdx: 0, children: children, state: preapareAdStateData()};
	            _adTree.push(treeElem);
	            treeElem.currentIdx = _adTree.length - 1;
	            _currTreeIdx = treeElem.currentIdx;
	            processAd(_adTree[_currTreeIdx].children[0], vastVersion);
	        }
	        else {
	            traceTreePath(_currTreeIdx, 'INVALID VAST VERSION: ' + vastVersion);
	            if (_adTree.length === 0) {
	                reportError('102', 'VAST version not supported');
	            }
	            else {
	                processNextAd();
	            }
	        }
	    }

	    function mergeTrackings(idx) {
	        for (var event in _adTree[idx].state.arrTrackings) {
	            for (var i = 0; i < _adTree[idx].state.arrTrackings[event].length; i++) {
	                if (_arrTrackingsMerge.hasOwnProperty(event)) {
	                    if (!isInArray(_arrTrackingsMerge[event], _adTree[idx].state.arrTrackings[event][i])) {
	                        _arrTrackingsMerge[event].push(_adTree[idx].state.arrTrackings[event][i]);
	                    }
	                }
	                else {
	                    _arrTrackingsMerge[event] = [];
	                    _arrTrackingsMerge[event].push(_adTree[idx].state.arrTrackings[event][i]);
	                }
	            }
	        }
	        return _arrTrackingsMerge;
	    }

	    function mergeTreeTrackings(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeTrackings(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrTrackingsMerge;
	    }

	    function mergeImpressions(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrImpressions.length; i++) {
	            if (!isInArray(_arrImpressionsMerge, _adTree[idx].state.arrImpressions[i])) {
	                _arrImpressionsMerge.push(_adTree[idx].state.arrImpressions[i]);
	            }
	        }
	        return _arrImpressionsMerge;
	    }

	    function mergeTreeImpressions(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeImpressions(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrImpressionsMerge;
	    }

	    function mergeClickUrls(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrClickUrls.length; i++) {
	            if (!isInArray(_arrClickUrlsMerge, _adTree[idx].state.arrClickUrls[i])) {
	                _arrClickUrlsMerge.push(_adTree[idx].state.arrClickUrls[i]);
	            }
	        }
	        return _arrClickUrlsMerge;
	    }

	    function mergeTreeClickUrls(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeClickUrls(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrClickUrlsMerge;
	    }

	    function mergeClickTrackings(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrClickTrackings.length; i++) {
	            if (!isInArray(_arrClickTrackingsMerge, _adTree[idx].state.arrClickTrackings[i])) {
	                _arrClickTrackingsMerge.push(_adTree[idx].state.arrClickTrackings[i]);
	            }
	        }
	        return _arrClickTrackingsMerge;
	    }

	    function mergeTreeClickTrackings(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeClickTrackings(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrClickTrackingsMerge;
	    }

	    function mergeErrorUrls(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrErrorUrls.length; i++) {
	            if (!isInArray(_arrErrorUrlsMerge, _adTree[idx].state.arrErrorUrls[i])) {
	                _arrErrorUrlsMerge.push(_adTree[idx].state.arrErrorUrls[i]);
	            }
	        }
	        return _arrErrorUrlsMerge;
	    }

	    function mergeTreeErrorUrls(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeErrorUrls(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrErrorUrlsMerge;
	    }

	    function mergeExtensions(idx) {
	        if (_adTree[idx].state.sExtensions.length > 0) {
	            _sExtensions = _sExtensions + _adTree[idx].state.sExtensions;
	        }
	        return _sExtensions;
	    }

	    function mergeTreeExtensions(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeExtensions(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _sExtensions;
	    }

	    function mergeCompanions(treeIdx) {
	        var idx = treeIdx;
	        while (idx > 0) {
	            var parentIdx = _adTree[idx].parentIdx;
	            APN_CompanionAds.mergeCompanions(_adTree[parentIdx].state.companions, _adTree[idx].state.companions);
	            idx = parentIdx;
	        }
	        if (_adTree[idx].state.companions.required === 'unknown') {
	            delete _adTree[idx].state.companions.required;
	        }
	        return _adTree[idx].state.companions;
	    }

	    function mergeTreeCompanions(treeIdx) {
	        var arrCompanions = {required: 'unknown', companions: []};
	        var idx = treeIdx;
	        while (idx >= 0) {
	            APN_CompanionAds.mergeCompanions(arrCompanions, _adTree[idx].state.companions);
	            idx = _adTree[idx].parentIdx;
	        }
	        return arrCompanions;
	    }

	    function isProgramExist(arrIcons, program) {
	        for (var i = 0; i < arrIcons.length; i++) {
	            if (arrIcons[i].program.toLowerCase() === program.toLowerCase()) {
	                return true;
	            }
	        }
	        return false;
	    }

	    function removeProgram(arrIcons, program) {
	        for (var i = 0; i < arrIcons.length; i++) {
	            if (arrIcons[i].program.toLowerCase() === program.toLowerCase()) {
	                //arrIcons[i].splice(i, 1);
	                arrIcons.splice(i, 1);//one of arrIcons should be removed if it has same program for VIDLA-625
	                return;
	            }
	        }
	    }

	    function mergeIcons(treeIdx) {
	        var idx = treeIdx;
	        while (idx > 0) {
	            var parentIdx = _adTree[idx].parentIdx;
	            for (var i = 0; i < _adTree[idx].state.icons.length; i++) {
	                // avoid duplicate icons with same program (replace if exist)
	                if (isProgramExist(_adTree[parentIdx].state.icons, _adTree[idx].state.icons[i].program)) {
	                    removeProgram(_adTree[parentIdx].state.icons, _adTree[idx].state.icons[i].program);
	                }
	                _adTree[parentIdx].state.icons.push(_adTree[idx].state.icons[i]);
	            }
	            idx = parentIdx;
	        }
	        return _adTree[idx].state.icons;
	    }

	    function mergeTreeIcons(treeIdx) {
	        var arrIcons = [];
	        var idx = treeIdx;
	        while (idx >= 0) {
	            for (var i = 0; i < _adTree[idx].state.icons.length; i++) {
	                // avoid duplicate icons with same program
	                if (!isProgramExist(arrIcons, _adTree[idx].state.icons[i].program)) {
	                    arrIcons.push(_adTree[idx].state.icons[i]);
	                }
	            }
	            idx = _adTree[idx].parentIdx;
	        }
	        return arrIcons;
	    }

	    function aggregateCompanions(companionsObj) {
	        // get companions with resources and without resorces
	        var resCompanions = [];
	        var noresCompanions = [];
	        var companions = companionsObj.companions;
	        if (!companionsObj.companions) {
	            return companionsObj;
	        }
	        var companion;
	        var i, j;
	        for (i = companions.length - 1; i >= 0; i--) {
	            companion = companions[i];
	            if (companion.StaticResource || companion.IFrameResource || companion.HTMLResource) {
	                var sameSize = false;
	                for (j = 0; j < resCompanions.length; j++) {
	                    if (companion.width === resCompanions[j].width &&
	                        companion.height === resCompanions[j].height) {
	                        sameSize = true;
	                        break;
	                    }
	                }
	                if (!sameSize) {
	                    resCompanions.push(companion);
	                }
	            }
	            else {
	                noresCompanions.push(companion);
	            }
	        }

	        // aggregate companions without resorces into companions with resources
	        for (i = 0; i < noresCompanions.length; i++) {
	            for (j = 0; j < resCompanions.length; j++) {
	                if (noresCompanions[i].width === resCompanions[j].width && noresCompanions[i].height === resCompanions[j].height) {
	                    if ((noresCompanions[i].id && noresCompanions[i].id === resCompanions[j].id) || (!noresCompanions[i].id)) {
	                        // add click trackings
	                        if (noresCompanions[i].CompanionClickTracking) {
	                            if (!resCompanions[j].CompanionClickTracking) {
	                                resCompanions[j].CompanionClickTracking = [];
	                            }
	                            resCompanions[j].CompanionClickTracking = resCompanions[j].CompanionClickTracking.concat(noresCompanions[i].CompanionClickTracking);
	                        }
	                        // add view trackings
	                        if (noresCompanions[i].TrackingEvents) {
	                            if (!resCompanions[j].TrackingEvents) {
	                                resCompanions[j].TrackingEvents = [];
	                            }
	                            resCompanions[j].TrackingEvents = resCompanions[j].TrackingEvents.concat(noresCompanions[i].TrackingEvents);
	                        }
	                    }
	                }
	            }
	        }
	        var ret = {companions: resCompanions};
	        if (companionsObj.required) {
	            ret.required = companionsObj.required;
	        }
	        return ret;
	    }
	    
	    function getCategories(node) {
	    	var categories = [];
	    	var nodes = _helper.getSubNodes(node, 'Category');
	    	if (nodes && nodes.length > 0) {
	    		for (var i = 0; i < nodes.length; i++) {
	    			var val = _helper.getNodeValues(nodes[i]);
	    			var authority = _helper.getNodeAttributeValue(nodes[i], 'authority');
	    			categories.push({category: val, authority: authority});
	    		}
	    	}
	    	return categories.length > 0 ? categories : null;
	    }

	    function mergeViewableImpressions(idx) {
	    	var i;
	        for (i = 0; i < _adTree[idx].state.arrViewableImpressions.viewable.length; i++) {
	            if (!isInArray(_arrViewableImpressionsMerge.viewable, _adTree[idx].state.arrViewableImpressions.viewable[i])) {
	            	_arrViewableImpressionsMerge.viewable.push(_adTree[idx].state.arrViewableImpressions.viewable[i]);
	            }
	        }
	        for (i = 0; i < _adTree[idx].state.arrViewableImpressions.notViewable.length; i++) {
	            if (!isInArray(_arrViewableImpressionsMerge.notViewable, _adTree[idx].state.arrViewableImpressions.notViewable[i])) {
	            	_arrViewableImpressionsMerge.notViewable.push(_adTree[idx].state.arrViewableImpressions.notViewable[i]);
	            }
	        }
	        for (i = 0; i < _adTree[idx].state.arrViewableImpressions.undeterminated.length; i++) {
	            if (!isInArray(_arrViewableImpressionsMerge.undeterminated, _adTree[idx].state.arrViewableImpressions.undeterminated[i])) {
	            	_arrViewableImpressionsMerge.undeterminated.push(_adTree[idx].state.arrViewableImpressions.undeterminated[i]);
	            }
	        }
	        return _arrViewableImpressionsMerge;
	    }

	    function mergeTreeViewableImpressions(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	        	mergeViewableImpressions(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrViewableImpressionsMerge;
	    }
	    
	    function getUniversalAdId(node) {
	    	var creatieves = _helper.getSubNodes(node, 'Creative');
	    	if (creatieves && creatieves.length > 0) {
	    		for (var i = 0; i < creatieves.length; i++) {
	    			var linear = _helper.getSubNode(creatieves[i], 'Linear');
	    			if (linear) {
	        			var universalAdId = _helper.getSubNode(creatieves[i], 'UniversalAdId');
	        			return universalAdId;
	    			}
	    		}
	    	}
	    	return null;
	    }
	    
	    function getAdVerifications(node) {
	    	var verifications = [];
	    	var adVer = _helper.getSubNode(node, 'AdVerifications');
	    	if (adVer) {
	    		var nodes = _helper.getSubNodes(adVer, 'Verification');
	    		if (nodes && nodes.length > 0) {
	    			for (var i = 0; i < nodes.length; i++) {
	    				var verification = nodes[i];
	    				var vendor = _helper.getNodeAttributeValue(verification, 'vendor');
	    				var jsResources = [];
	    				var flashResources = [];
	    				var val;
	    				var attr;
	    				var j;
	    				var resources = _helper.getSubNodes(verification, 'JavaScriptResource');
	    				if (resources && resources.length > 0) {
	    					for (j = 0; j < resources.length; j++) {
	    						val = _helper.getNodeValues(resources[j]);
	    						attr = _helper.getNodeAttributeValue(resources[j], 'apiFramework');
	    						jsResources.push({url: val, framework: attr});
	    					}
	    				}
	    				resources = _helper.getSubNodes(verification, 'FlashResource');
	    				if (resources && resources.length > 0) {
	    					for (j = 0; j < resources.length; j++) {
	    						val = _helper.getNodeValues(resources[j]);
	    						attr = _helper.getNodeAttributeValue(resources[j], 'apiFramework');
	    						flashResources.push({url: val, framework: attr});
	    					}
	    				}
	    				var viewableImpression = _helper.getSubNodeWholeValue(verification, 'ViewableImpression');
	    				var verData = {};
	    				if (vendor) {
	    					verData.vendor = vendor;
	    				}
	    				if (jsResources.length > 0) {
	    					verData.jsResources = jsResources;
	    				}
	    				if (flashResources.length > 0) {
	    					verData.flashResources = flashResources;
	    				}
	    				if (viewableImpression) {
	    					verData.viewableImpression = viewableImpression;
	    				}
	    				verifications.push(verData);
	    			}
	    		}
	    	}
	    	
	    	return verifications.length > 0 ? verifications : null;
	    }
	    
	    function normalizeAdId(id) {
	    	var retId = id;
	    	var idx = retId.indexOf('_suffix');
	    	if (idx > 0) {
	    		retId = retId.substring(0, idx);
	    	}
	    	return retId;
	    }

	    function processAd(adNode, vastVersion) {
	        var inLineWrapperNode = _helper.getSubNode(adNode, 'Wrapper');
	        var isWrapper = inLineWrapperNode !== null;
	        if (!isWrapper) {
	            inLineWrapperNode = _helper.getSubNode(adNode, 'InLine');
	        }
	        if (!inLineWrapperNode) {
	        	saveNoAdsErrors();
	            traceTreePath(_currTreeIdx, 'MISSING WRAPPER / INLINE NODE');
	            processNextAd();
	            return;
	        }

	        if (vastVersion > _vastVersion) {
	            _vastVersion = vastVersion;
	        }

	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (_notifyurls.hasOwnProperty(id)) {
	            _curNotifyUrl = _notifyurls[id];
	        }
	        if (_creativeIds.hasOwnProperty(id)) {
	            _curCreativeId = _creativeIds[id];
	        }
	        if (_buyerMemberIds.hasOwnProperty(id)) {
	            _curBuyerMemberId = _buyerMemberIds[id];
	        }
	        if (_viewabilityConfigs.hasOwnProperty(id)) {
	            _curViewabilityConfig = _viewabilityConfigs[id];
	        }
	        // worried only about top level ad sequence attribute
	        if (_currTreeIdx === 0) {
	            var seq = _helper.getNodeAttributeValue(adNode, 'sequence');
	            if (seq) {
	                _adTree[_currTreeIdx].state.sequence = parseInt(seq);
	            }
	            var conditional = _helper.getNodeAttributeValue(adNode, 'conditionalAd');
	            if (conditional) {
	            	_conditionalAd = _helper.getNodeAttributeBooleanValue(adNode, 'conditionalAd');
	            }
	        }

	        addErrorUrls(inLineWrapperNode, _adTree[_currTreeIdx].state.arrErrorUrls);
	        addImpressions(inLineWrapperNode, _adTree[_currTreeIdx].state.arrImpressions);
	        addTrackings(inLineWrapperNode, _adTree[_currTreeIdx].state.arrTrackings);
	        addClickUrls(inLineWrapperNode, _adTree[_currTreeIdx].state.arrClickUrls, _adTree[_currTreeIdx].state.arrClickTrackings);
	        addExtensions(inLineWrapperNode, _currTreeIdx);
	        addCompanions(inLineWrapperNode, _currTreeIdx);
	        addIcons(inLineWrapperNode, _currTreeIdx);
	        addViewableImpression(inLineWrapperNode, _adTree[_currTreeIdx].state.arrViewableImpressions);

	        _arrInternalErrorUrls = [];//clear _arrInternalErrorUrls at this time, all same sibiling's error will be gathered by processNextAd()

	        if (isWrapper) {
	        	if (_vastVersion === '4.0' && _currTreeIdx > 0) {
	        		if (!_adTree[_currTreeIdx - 1].state.followAdditionalWrappers) {
	                    traceTreePath(_currTreeIdx, 'Additional Wrappers are not allowed');
	                    processNextAd();
	                    return;
	        		}
	        	}
	            processWrapper(inLineWrapperNode);
	        }
	        else {
	            var message = addMediaFilesAndDuration(inLineWrapperNode);
	            if (_arrMediaFiles.length === 0 || message.length > 0) {
	                traceTreePath(_currTreeIdx, message);
	                processNextAd();
	                return;
	            }
	            _arrTrackingsMerge = JSON.parse(JSON.stringify(_arrTrackings));
	            _arrImpressionsMerge = _arrImpressions.slice(0);
	            _arrClickUrlsMerge = _arrClickUrls.slice(0);
	            _arrClickTrackingsMerge = _arrClickTrackings.slice(0);
	            _arrErrorUrlsMerge = _arrErrorUrls.slice(0);
	            _sExtensions = '';

	            var strTrackingUrls = JSON.stringify(mergeTreeTrackings(_adTree[_currTreeIdx].parentIdx));
	            var strImpressionUrls = JSON.stringify(mergeTreeImpressions(_adTree[_currTreeIdx].parentIdx));
	            var strClickUrls = JSON.stringify(mergeTreeClickUrls(_adTree[_currTreeIdx].parentIdx));
	            var strClickTrackingUrls = JSON.stringify(mergeTreeClickTrackings(_adTree[_currTreeIdx].parentIdx));
	            var strErrorUrls = JSON.stringify(mergeTreeErrorUrls(_adTree[_currTreeIdx].parentIdx));
	            var strExtensions = mergeTreeExtensions(_adTree[_currTreeIdx].parentIdx);
	            var strCompanions = JSON.stringify(mergeTreeCompanions(_adTree[_currTreeIdx].parentIdx));
	            var strIcons = JSON.stringify(mergeTreeIcons(_adTree[_currTreeIdx].parentIdx));
	            _sExtensions = '';
	            var companions = mergeCompanions(_currTreeIdx);
	            companions = aggregateCompanions(companions);
	            var vastObj = {
	                vastVersion: _vastVersion,
	                withWrapper: _withWrapper,
	                mediaFiles: _arrMediaFiles,
	                trackingUrls: mergeTrackings(_currTreeIdx),
	                impressionUrls: mergeImpressions(_currTreeIdx),
	                clickUrls: mergeClickUrls(_currTreeIdx),
	                clickTrackingUrls: mergeClickTrackings(_currTreeIdx),
	                errorUrls: mergeErrorUrls(_currTreeIdx),
	                durationMsecs: _nMsecDuration,
	                skipOffset: _strSkipOffset,
	                extensions: mergeExtensions(_currTreeIdx),
	                adParameters: _adParameters,
	                vastXml: _sourceVastXml,			// inline vast xml
	                extTrackingUrls: strTrackingUrls,
	                extImpressionUrls: strImpressionUrls,
	                extClickUrls: strClickUrls,
	                extClickTrackingUrls: strClickTrackingUrls,
	                extErrorUrls: strErrorUrls,
	                extExtensions: strExtensions,
	                adId: normalizeAdId(id),
	                sequence: _adTree[0].state.sequence,
	                companionAds: companions,
	                extCompanions: strCompanions,
	                icons: mergeIcons(_currTreeIdx),
	                extIcons: strIcons,
	                finalVastUri: _finalVastUri //VIDLA-2240
	            };
	            
	            // vast 4 data
	            if (_vastVersion.substr(0, 1) > '3') {
	        		var universalAdId = getUniversalAdId(inLineWrapperNode);
	        		if (!universalAdId) {
	                    traceTreePath(_currTreeIdx, 'universalAdId is not provided');
	                    processNextAd();
	                    return;
	        		}
	        		var idRegistry = _helper.getNodeAttributeValue(universalAdId, 'idRegistry');
	        		var idValue = _helper.getNodeAttributeValue(universalAdId, 'idValue');
	        		if (idRegistry.length === 0 || idValue.length === 0) {
	                    traceTreePath(_currTreeIdx, 'universalAdId is invalid');
	                    processNextAd();
	                    return;
	        		}
	        		vastObj.universalAdId = {idRegistry: idRegistry, idValue: idValue};
	        		
	            	vastObj.conditionalAd = _conditionalAd;
	            	var categories = getCategories(inLineWrapperNode);
	            	if (categories) {
	            		for (var j = 0; j < categories.length; j++) {
	            			if (!categories[j].category || !categories[j].authority) {
	                            traceTreePath(_currTreeIdx, 'invalide Category node');
	                            processNextAd();
	                            return;
	            			}
	            		}
	                	vastObj.categories = categories;
	            	}
	            	
	                var strViewableImpressions = JSON.stringify(mergeTreeViewableImpressions(_adTree[_currTreeIdx].parentIdx));
	            	var viewImpressions = mergeViewableImpressions(_currTreeIdx);
	            	if (viewImpressions) {
	                	vastObj.extViewableImpression = strViewableImpressions;
	                	vastObj.viewableImpression = viewImpressions;
	            	}
	            	
	            	var adVerifications = getAdVerifications(inLineWrapperNode);
	        		if (adVerifications && adVerifications.length > 0) {
	                	vastObj.adVerifications = adVerifications;
	        		}
	        		
	        		if (_mezzanine) {
	        			vastObj.mezzanine = _mezzanine;
	        		}
	        		if (_arrInteractiveCreatives && _arrInteractiveCreatives.length > 0) {
	        			vastObj.interactiveCreativeFiles = _arrInteractiveCreatives;
	        		}
	        		
	        		if (_fallbackOnNoAd !== undefined) {
	        			vastObj.fallbackOnNoAd = _fallbackOnNoAd;
	        		}
	            }
	            
	            if (_waterfall && _curNotifyUrl.length > 0) {
	                vastObj.notifyurl = _curNotifyUrl;
	            }
	            if (_curCreativeId.length > 0) {
	                vastObj.creative_id = _curCreativeId;
	            }
	            if (_curBuyerMemberId.length > 0) {
	                vastObj.buyerMemberId = _curBuyerMemberId;
	            }
	            if (_curViewabilityConfig.length > 0) {
	                vastObj.viewabilityConfig = _curViewabilityConfig;
	            }
	            // becaurse waterfall xml always unwrapped, we can set rtb flag base on current ad node
	            var rtb = false;
	            if (_waterfall) {
	                var rtbAttr = _helper.getNodeAttributeValue(adNode, 'rtb');
	                if (rtbAttr && rtbAttr === 'true') {
	                    rtb = true;
	                    vastObj.rtb = true;
	                }
	            }
	            if (_terminated) {
	                traceTreePath(_currTreeIdx, 'terminated');
	                _callback(false, _id, 'terminated', null, _curNotifyUrl);		// terminated
	                return;
	            }
	            var mediaTypes = [];
	            for (var i = 0; i < _arrMediaFiles.length; i++) {
	                if (mediaTypes.indexOf(_arrMediaFiles[i].type) === -1) {
	                    mediaTypes.push(_arrMediaFiles[i].type);
	                }
	            }
	            traceTreePath(_currTreeIdx, 'SUCCESS, Available=' + JSON.stringify(mediaTypes));
	            if (_waterfall) {
	                _vastObjects.push(vastObj);
	                if (rtb) {
	                    _rtbCount++;
	                }
	                else {
	                    _csmCount++;
	                }
	                processNextAd();
	            }
	            else if (_vmap) {
	            	vastObj.vastXml = getXmlForSequence(vastObj.vastXml, vastObj.sequence);
	            	_vastObjects.push(vastObj);
	                processNextAd();
	            }
	            else {
	                _callback(true, _id, vastObj, null);
	            }
	        }
	    }
	    
	    function getXmlForSequence(xml, sequence) {
	        var xmlDoc = (new DOMParser()).parseFromString(xml, 'text/xml');
	        var vastNode = _helper.getSubNode(xmlDoc, 'VAST');
	        var adNodes = _helper.getSubNodes(vastNode, 'Ad');
	        for (var i = 0; i < adNodes.length;) {
	        	var adSequence = _helper.getNodeAttributeValue(adNodes[i], 'sequence');
	        	if (adSequence && parseInt(adSequence) !== sequence) {
	        		// delete ad with different sequence attribute
	        		vastNode.removeChild(adNodes[i]);
	        	}
	        	else {
	        		i++;
	        	}
	        }
	    	var browser = ua.browser.name.toLowerCase();    
	        var xmlOut;
	        if (browser === 'ie') {
	        	xmlOut = (new XMLSerializer()).serializeToString(xmlDoc.childNodes[0]);
	        }
	        else {
	            xmlOut = xmlDoc.childNodes[0].outerHTML; 
	        }
	        return xmlOut;
	    }

	    function prepareExternalTrackers(videoTrackers, impTracker) {

	        var url;
	        var i;
	        var arr;
	        var name;
	        if (impTracker) {
	            _arrImpressions.push(impTracker.trim());
	        }
	        if (videoTrackers) {
	            if (Array.isArray(videoTrackers) && videoTrackers.length === 1) {
	                // new format
	                var trackers = videoTrackers[0];
	                if (trackers.impression_urls) {
	                    for (i = 0; i < trackers.impression_urls.length; i++) {
	                        url = trackers.impression_urls[i].trim();
	                        _arrImpressions.push(url);
	                    }
	                }
	                if (trackers.error_urls) {
	                    for (i = 0; i < trackers.error_urls.length; i++) {
	                        url = trackers.error_urls[i].trim();
	                        _arrErrorUrls.push(url);
	                    }
	                }
	                if (trackers.video_click_urls) {
	                    for (i = 0; i < trackers.video_click_urls.length; i++) {
	                        url = trackers.video_click_urls[i].trim();
	                        _arrClickTrackings.push(url);
	                    }
	                }
	                for (name in trackers.video_events) {
	                    arr = trackers.video_events[name];
	                    for (i = 0; i < arr.length; i++) {
	                        url = arr[i].trim();
	                        if (_arrTrackings.hasOwnProperty(name)) {
	                            if (!isInArray(_arrTrackings[name], url)) {
	                                _arrTrackings[name].push(url);
	                            }
	                        }
	                        else {
	                            _arrTrackings[name] = [url];
	                        }
	                    }
	                }
	            }
	            else {
	                for (name in videoTrackers) {
	                    if (name === 'service') {	// ignore not vast related trackers
	                        continue;
	                    }
	                    if (Array.isArray(videoTrackers[name])) {
	                        arr = videoTrackers[name];
	                        for (i = 0; i < arr.length; i++) {
	                            url = arr[i].trim();
	                            if (name === 'click') {
	                                _arrClickTrackings.push(url);
	                            }
	                            else if (name === 'error') {
	                                _arrErrorUrls.push(url);
	                            }
	                            else if (name === 'impression') {
	                                _arrImpressions.push(url);
	                            }
	                            else {
	                                if (_arrTrackings.hasOwnProperty(name)) {
	                                    if (!isInArray(_arrTrackings[name], url)) {
	                                        _arrTrackings[name].push(url);
	                                    }
	                                }
	                                else {
	                                    _arrTrackings[name] = [url];
	                                }
	                            }
	                        }
	                    }
	                    else {
	                        url = videoTrackers[name].trim();
	                        if (name === 'click') {
	                            _arrClickTrackings.push(url);
	                        }
	                        else if (name === 'error') {
	                            _arrErrorUrls.push(url);
	                        }
	                        else if (name === 'impression') {
	                            _arrImpressions.push(url);
	                        }
	                        else {
	                            if (_arrTrackings.hasOwnProperty(name)) {
	                                if (!isInArray(_arrTrackings[name], url)) {
	                                    _arrTrackings[name].push(url);
	                                }
	                            }
	                            else {
	                                _arrTrackings[name] = [url];
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }

	    this.parse = function (strVastXml, videoTrackers, impTracker, callback) {
	        _callback = callback;
	        prepareExternalTrackers(videoTrackers, impTracker);
	        _topLevel = true;
	        parseXML(strVastXml);
	    };

	    this.terminate = function () {
	        _terminated = true;
	    };
	};

	var VastModifier = __webpack_require__(58);

	var VastMerger = __webpack_require__(59);

	module.exports = {
	    /** Describe Parser Main Entry Point Here.
	     * @param {string} strVastXml - VAST xml.
	     * @param {function} fnCallback - Callback function.
	     *        Callback parameters:
	     *            succ: true if success, false otherwise
	     *            sourceId: mediation element identificator
	     *            data: object is success, error code otherwise
	     *            arrErrorUrl: null if success, list of tracking url parsed from vast xml untill parsing has failed
	     * @param {object} id - mediation element identificator.
	     * @param {number} nMsecTimeout - time out in miliseconds for loading wrapper xml.
	     * @param {object} videoTrackers - video_trackings field from impbus request.
	     * @param {string} videoTrackers - imp_tracking_url field from impbus request.
	     * @param {object} options - publisher options.
	     * 		  If adServerTimeout is present in options, VAST parser uses adServerTimeout value for loading wrapper xml instead of nMsecTimeout.
	     */
	    parse: function (strVastXml, fnCallback, id, nMsecTimeout, videoTrackers, impTracker, options) {
	        var parserObj = new VastParser(id, nMsecTimeout, options);
	        parserObj.parse(strVastXml, videoTrackers, impTracker,
	            function (succ, sourceId, data, arrErrorUrls, notifUrl) {
	                if (fnCallback) {
	                    fnCallback(succ, sourceId, data, arrErrorUrls, notifUrl);
	                }
	                parserObj = null;
	            });
	        return parserObj;
	    },

	    /** Describe Vast Unwrapping Entry Point Here.
	     * @param {object} parserData - object returned after successful parsing.
	     * @param {string} adToken - optional ad identificator used for debug mode
	     * @return {string} - unwrapped VAST xml.
	     */
	    getUnwrappedVastTag: function (parserData, adToken, notifyUrl, contentSource, buyerMemberId, viewabilityConfig, additionalTrackers, creativeId) {
	        if (!parserData || !parserData.vastXml) {
	            return null;
	        }
	        var obj = new VastModifier(parserData, adToken, notifyUrl, contentSource, buyerMemberId, viewabilityConfig, additionalTrackers, creativeId);
	        var xml = obj.addTrackers();
	        obj = null;
	        return xml;
	    },

	    /** Describe Vast Merging VAST XMLs Entry Point Here.
	     * @param {object} xmlListData - object containes XMLs and additional data:
	     *                    xml: VAST XML
	     *                    notifyUrl: notification url from impbus response
	     *                    buyerMemberId: buyer member idenfificator from impbus response
	     * @return {string} - merged VAST xml.
	     */
	    getMergedVastTag: function (xmlList) {
	        if (!xmlList || xmlList.length === 0) {
	            return null;
	        }
	        var obj = new VastMerger(xmlList);
	        var xml = obj.getVastXml();
	        obj = null;
	        return xml;
	    }
	};


/***/ }),
/* 54 */
/***/ (function(module, exports) {

	var XMLParserHelper = function () {
	    this.getSubNodes = function (node, subNodeName) {
	        var nodes = node.getElementsByTagName(subNodeName);
	        if (nodes.length > 0) {
	            return nodes;
	        }
	        return null;
	    };

	    this.getSubNode = function (node, subNodeName, index) {
	        if (!index) {
	            index = 0;
	        }
	        var nodes = node.getElementsByTagName(subNodeName);
	        if (nodes.length > index) {
	            return nodes[index];
	        }
	        return null;
	    };

	    this.getNodeValue = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var val = node.childNodes[0].nodeValue;
	        if (val) {
	            return val.trim();
	        }
	        return '';
	    };

	    this.getNodeValues = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var wholeVal = '';
	        for (var i = 0; i < node.childNodes.length; i++) {
	            var val = node.childNodes[i].nodeValue;
	            if (val) {
	            	wholeVal += val;
	            }
	        }
	        return wholeVal.trim();
	    };

	    this.getNodeAttributeValue = function (node, attributeName) {
	        var val = node.getAttribute(attributeName);
	        if (val === null) {
	            val = '';
	        }
	        return val;
	    };

	    this.getNodeAttributeNumberValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = 0;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            if (val.indexOf('.') >= 0) {
	                answer = parseFloat(val);
	            }
	            else {
	                answer = parseInt(val);
	            }
	        }

	        return answer;
	    };

	    this.getNodeAttributeBooleanValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = false;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            var char = val.toLowerCase().charAt(0);
	            answer = (char === 't');
	        }

	        return answer;
	    };

	    this.getSubNodeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValue(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeWholeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValues(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeBooleanValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? 'false' : defaultValue;

	        var value = this.getSubNodeValue(parentNode, subNodeName);
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 't') {
	            return true;
	        }
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 'f') {
	            return false;
	        }
	        return defaultValue;
	    };
	};

	module.exports = XMLParserHelper;


/***/ }),
/* 55 */
/***/ (function(module, exports) {

	var CompanionAds = {

	    parse: function (companionAdsDest, companionAdsNode, helper) {
	        var req = helper.getNodeAttributeValue(companionAdsNode, 'required');
	        if (req && req.length > 0) {
	            companionAdsDest.required = req;
	        }

	        var nodes = helper.getSubNodes(companionAdsNode, 'Companion');
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
	                //var companion = JSON.parse(JSON.stringify(APN_Companion));
	                var companion = {};

	                // required attributes
	                var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
	                var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
	                if (width <= 0 || height <= 0) {
	                    continue;
	                }
	                companion.width = width;
	                companion.height = height;

	                // optional attributes and subnodes
	                var val = helper.getNodeAttributeValue(node, 'id');
	                if (val) {
	                    companion.id = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'assetWidth', -1);
	                if (val > 0) {
	                    companion.assetWidth = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'assetHeight', -1);
	                if (val > 0) {
	                    companion.assetHeight = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'expandedWidth', -1);
	                if (val > 0) {
	                    companion.expandedWidth = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'expandedHeight', -1);
	                if (val > 0) {
	                    companion.expandedHeight = val;
	                }

	                val = helper.getNodeAttributeValue(node, 'apiFramework');
	                if (val) {
	                    companion.apiFramework = val;
	                }

	                val = helper.getNodeAttributeValue(node, 'adSlotID');
	                if (val) {
	                    companion.adSlotID = val;
	                }

	                var pxratio = helper.getNodeAttributeNumberValue(node, 'pxratio', 1.0);
	                if (pxratio !== 1.0) {
	                	companion.pxratio = pxratio;
	                }
	                
	                val = helper.getNodeAttributeValue(node, 'required');
	                if (val) {
	                    companion.required = val;
	                }

	                val = helper.getSubNodeValue(node, 'AltText');
	                if (val) {
	                    companion.AltText = val;
	                }

	                val = helper.getSubNodeValue(node, 'AdParameters');
	                if (val) {
	                    companion.AdParameters = val;
	                }

	                var resource = helper.getSubNode(node, 'StaticResource');
	                if (resource) {
	                    val = helper.getNodeAttributeValue(resource, 'creativeType');
	                    if (val) {
	                        // validate capability
	                        var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
	                        var isMobile = false;
	                        if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
	                            isMobile = true;
	                        }
	                        if (isMobile && flashOnlyType) {
	                            // ignore this companion
	                            continue;
	                        }

	                        var staticResource = {type: val};
	                        val = helper.getNodeValues(resource);
	                        if (val) {
	                            staticResource.src = val;
	                            companion.StaticResource = staticResource;
	                        }
	                    }
	                }

	                val = helper.getSubNodeWholeValue(node, 'IFrameResource');
	                if (val) {
	                    companion.IFrameResource = val;
	                }

	                val = helper.getSubNodeWholeValue(node, 'HTMLResource');
	                if (val) {
	                    companion.HTMLResource = val;
	                }

	                val = helper.getSubNodeValue(node, 'CompanionClickThrough');
	                if (val) {
	                    companion.CompanionClickThrough = val;
	                }

	                var j;
	                var trackingNode;
	                var url;
	                var clickTrackinEvents = helper.getSubNodes(node, 'CompanionClickTracking');
	                if (clickTrackinEvents) {
	                    companion.CompanionClickTracking = [];
	                    for (j = 0; j < clickTrackinEvents.length; j++) {
	                        trackingNode = clickTrackinEvents[j];
	                        url = helper.getNodeValues(trackingNode);
	                        if (url) {
	                            companion.CompanionClickTracking.push(url);
	                        }
	                    }
	                }

	                var trackinEvents = helper.getSubNodes(node, 'Tracking');
	                if (trackinEvents) {
	                    companion.TrackingEvents = [];
	                    for (j = 0; j < trackinEvents.length; j++) {
	                        trackingNode = trackinEvents[j];
	                        var event = helper.getNodeAttributeValue(trackingNode, 'event');
	                        url = helper.getNodeValues(trackingNode);
	                        if (event && url) {
	                            companion.TrackingEvents.push({eventType: event, url: url});
	                        }
	                    }
	                }

	                companionAdsDest.companions.push(companion);
	            }
	        }
	    },

	    mergeCompanions: function (companionAdsDest, companionAds) {
	        if (companionAdsDest.required === 'unknown') {
	            companionAdsDest.required = companionAds.required;
	        }
	        companionAdsDest.companions = companionAdsDest.companions.concat(companionAds.companions);
	    },

	    createCompanionNode: function (xmlDoc, data) {
	        var companion = xmlDoc.createElement('Companion');
	        var i;
	        var elem;
	        var attr;
	        var cdata;

	        var arrAttrs = ['id', 'width', 'height', 'assetWidth', 'assetHeight', 'expandedWidth', 'expandedHeight',
	            'apiFramework', 'adSlotID', 'required'];
	        for (i = 0; i < arrAttrs.length; i++) {
	            if (data.hasOwnProperty(arrAttrs[i])) {
	                attr = xmlDoc.createAttribute(arrAttrs[i]);
	                attr.value = data[arrAttrs[i]];
	                companion.setAttributeNode(attr);
	            }
	        }

	        if (data.hasOwnProperty('StaticResource')) {
	            elem = xmlDoc.createElement('StaticResource');
	            attr = xmlDoc.createAttribute('creativeType');
	            attr.value = data.StaticResource.type;
	            elem.setAttributeNode(attr);
	            cdata = xmlDoc.createCDATASection(data.StaticResource.src);
	            elem.appendChild(cdata);
	            companion.appendChild(elem);
	        }

	        var arrNodes = ['AdParameters', 'IFrameResource', 'HTMLResource', 'CompanionClickThrough'];
	        for (i = 0; i < arrNodes.length; i++) {
	            if (data.hasOwnProperty(arrNodes[i])) {
	                elem = xmlDoc.createElement(arrNodes[i]);
	                cdata = xmlDoc.createCDATASection(data[arrNodes[i]]);
	                elem.appendChild(cdata);
	                companion.appendChild(elem);
	            }
	        }

	        if (data.hasOwnProperty('AltText')) {
	            elem = xmlDoc.createElement('AltText');
	            try {
	                elem.innerHTML = data.AltText;
	            }
	            catch (ex) {
	                // IE 11 does not allow set innerHTML property
	                try {
	                    elem.textContent = data.AltText;
	                }
	                catch (ex2) {

	                }
	            }
	            companion.appendChild(elem);
	        }

	        if (data.hasOwnProperty('CompanionClickTracking')) {
	            for (i = 0; i < data.CompanionClickTracking.length; i++) {
	                var tracking = xmlDoc.createElement('CompanionClickTracking');
	                cdata = xmlDoc.createCDATASection(data.CompanionClickTracking[i]);
	                tracking.appendChild(cdata);
	                companion.appendChild(tracking);
	            }
	        }

	        if (data.hasOwnProperty('TrackingEvents')) {
	            elem = xmlDoc.createElement('TrackingEvents');
	            // enumerate trackers
	            for (i = 0; i < data.TrackingEvents.length; i++) {
	                var event = xmlDoc.createElement('Tracking');
	                attr = xmlDoc.createAttribute('event');
	                attr.value = data.TrackingEvents[i].eventType;
	                event.setAttributeNode(attr);
	                cdata = xmlDoc.createCDATASection(data.TrackingEvents[i].url);
	                event.appendChild(cdata);
	                elem.appendChild(event);
	            }
	            companion.appendChild(elem);
	        }

	        return companion;
	    }
	};

	module.exports = CompanionAds;

/***/ }),
/* 56 */
/***/ (function(module, exports) {

	var Icons = {

	    parse: function (IconsDest, IconsNode, helper) {
	        var nodes = helper.getSubNodes(IconsNode, 'Icon');
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
	                var icon = {};

	                // required attributes
	                var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
	                var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
	                var program = helper.getNodeAttributeValue(node, 'program');
	                var xPosition = helper.getNodeAttributeValue(node, 'xPosition');
	                var yPosition = helper.getNodeAttributeValue(node, 'yPosition');
	                if (width <= 0 || height <= 0 || program.length === 0 || xPosition.length === 0 || yPosition.length === 0) {
	                    continue;
	                }
	                icon.width = width;
	                icon.height = height;
	                icon.program = program;
	                icon.xPosition = xPosition;
	                icon.yPosition = yPosition;

	                // optional attributes and subnodes
	                var val = helper.getNodeAttributeValue(node, 'apiFramework');
	                if (val) {
	                    icon.apiFramework = val;
	                }

	                var pxratio = helper.getNodeAttributeNumberValue(node, 'pxratio', 1.0);
	                if (pxratio !== 1.0) {
	                	icon.pxratio = pxratio;
	                }
	                
	                val = helper.getNodeAttributeValue(node, 'offset');
	                if (val) {
	                    // validate
	                    if (isNaN(Date.parse('January 1, 1970 ' + val))) {
	                        // invalid time format
	                        continue;
	                    }
	                    icon.offset = val;
	                }

	                val = helper.getNodeAttributeValue(node, 'duration');
	                if (val) {
	                    // validate
	                    if (isNaN(Date.parse('January 1, 1970 ' + val))) {
	                        // invalid time format
	                        continue;
	                    }
	                    icon.duration = val;
	                }

	                var resource = helper.getSubNode(node, 'StaticResource');
	                if (resource) {
	                    val = helper.getNodeAttributeValue(resource, 'creativeType');
	                    if (val) {
	                        // validate capability
	                        var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
	                        var isMobile = false;
	                        if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
	                            isMobile = true;
	                        }
	                        if (isMobile && flashOnlyType) {
	                            // ignore this companion
	                            continue;
	                        }

	                        var staticResource = {type: val};
	                        val = helper.getNodeValues(resource);
	                        if (val) {
	                            staticResource.src = val;
	                            icon.StaticResource = staticResource;
	                        }
	                    }
	                }

	                val = helper.getSubNodeWholeValue(node, 'IFrameResource');
	                if (val) {
	                    icon.IFrameResource = val;
	                }

	                val = helper.getSubNodeWholeValue(node, 'HTMLResource');
	                if (val) {
	                    icon.HTMLResource = val;
	                }
	                
	                // icon must contain a resource
	                if (!icon.StaticResource && !icon.IFrameResource && !icon.HTMLResource) {
	                	continue;
	                }

	                var iconClicks = helper.getSubNode(node, 'IconClicks');
	                if (iconClicks) {
	                    val = helper.getSubNodeValue(node, 'IconClickThrough');
	                    if (val) {
	                        icon.IconClickThrough = val;
	                    }

	                    //IconClickTracking can be multiple by a VAST3.0 spec 2.4.3.5 Icon Clicks and Tracking
	                    val = helper.getSubNodes(iconClicks, 'IconClickTracking');
	                    if (val) {
	                        icon.IconClickTracking = [];
	                        for (var cntIconClick = 0; cntIconClick < val.length; cntIconClick++) {
	                            icon.IconClickTracking.push(helper.getNodeValues(val[cntIconClick]));
	                        }
	                    }
	                }

	                /* VAST3 XML schema explains IconViewTracking can be multiple like below
	                 <xs:element name="IconViewTracking" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded">
	                 <xs:annotation>
	                 <xs:documentation>URLs to ping when icon is shown.</xs:documentation>
	                 </xs:annotation>
	                 </xs:element>
	                 */
	                var iconViewTracking = helper.getSubNodes(node, 'IconViewTracking');
	                if (iconViewTracking) {
	                    icon.IconViewTracking = [];
	                    for (var cntIconView = 0; cntIconView < iconViewTracking.length; cntIconView++) {
	                        icon.IconViewTracking.push(helper.getNodeValues(iconViewTracking[cntIconView]));
	                    }
	                }


	                var removeExistingProgram = function (IconsDest, program) {
	                    for (var cntIconDest = 0; cntIconDest < IconsDest.length; cntIconDest++) {
	                        if (IconsDest[cntIconDest].program === program) {
	                            IconsDest.splice(cntIconDest, 1);
	                        }
	                    }
	                };

	                //VIDLA-625 if same program exists in Icons node last one will be used.
	                removeExistingProgram(IconsDest, program);

	                IconsDest.push(icon);

	            }
	        }
	    },

	    createIconNode: function (xmlDoc, data) {
	        var icon = xmlDoc.createElement('Icon');
	        var i;
	        var elem;
	        var attr;
	        var cdata;

	        var arrAttrs = ['width', 'height', 'program', 'xPosition', 'yPosition', 'apiFramework', 'offset', 'duration'];
	        for (i = 0; i < arrAttrs.length; i++) {
	            if (data.hasOwnProperty(arrAttrs[i])) {
	                attr = xmlDoc.createAttribute(arrAttrs[i]);
	                attr.value = data[arrAttrs[i]];
	                icon.setAttributeNode(attr);
	            }
	        }

	        if (data.hasOwnProperty('StaticResource')) {
	            elem = xmlDoc.createElement('StaticResource');
	            attr = xmlDoc.createAttribute('creativeType');
	            attr.value = data.StaticResource.type;
	            elem.setAttributeNode(attr);
	            cdata = xmlDoc.createCDATASection(data.StaticResource.src);
	            elem.appendChild(cdata);
	            icon.appendChild(elem);
	        }

	        var arrNodes = ['IFrameResource', 'HTMLResource', 'IconViewTracking'];
	        for (i = 0; i < arrNodes.length; i++) {
	            if (data.hasOwnProperty(arrNodes[i])) {
	                elem = xmlDoc.createElement(arrNodes[i]);
	                cdata = xmlDoc.createCDATASection(data[arrNodes[i]]);
	                elem.appendChild(cdata);
	                icon.appendChild(elem);
	            }
	        }

	        if (data.hasOwnProperty('IconClickThrough') || data.hasOwnProperty('IconClickTracking')) {
	            var iconClicks = xmlDoc.createElement('IconClicks');
	            if (data.hasOwnProperty('IconClickThrough')) {
	                elem = xmlDoc.createElement('IconClickThrough');
	                cdata = xmlDoc.createCDATASection(data.IconClickThrough);
	                elem.appendChild(cdata);
	                iconClicks.appendChild(elem);
	            }
	            if (data.hasOwnProperty('IconClickTracking')) {
	                elem = xmlDoc.createElement('IconClickTracking');
	                cdata = xmlDoc.createCDATASection(data.IconClickTracking);
	                elem.appendChild(cdata);
	                iconClicks.appendChild(elem);
	            }
	            icon.appendChild(iconClicks);
	        }

	        return icon;
	    }
	};

	module.exports = Icons;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	var prefixOfLog = "CapabilityDetection";
	var APN_Logger = __webpack_require__(9);
	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog,message);
	};


	/**
	 * Capability Detection module.
	 * @module CapabilityDetection
	 */

	function isMobile(){
	    if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
	        return true;
	    }
	    return false;
	}

	function hasFlashPlugin(){
	    var flash_installed = typeof navigator.plugins !== 'undefined' && typeof navigator.plugins['Shockwave Flash'] === 'object';
	    if (!flash_installed) {
	        flash_installed = window.ActiveXObject && (new ActiveXObject('ShockwaveFlash.ShockwaveFlash'));
	    }
	    return flash_installed;
	}

	function isFlashOnlyType(type) {
	    return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
	        type === 'application/x-shockwave-flash';
	}

	function isHtml5VpaidType(type) {
	    return type === 'application/javascript' || type === 'application/x-javascript';
	}

	function isIphone() {
	    var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	}

	function isIos() {
	    var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	}

	function isAndroid() {
	    return (/android/i.test(navigator.userAgent.toLowerCase()));
	}

	module.exports = {
	    /** Checks for Flash support.
	     * @returns {boolean} True is flash is supported, false otherwise.
	     */
	    supportsFlash: function() {
	        return !isMobile() && hasFlashPlugin();
	    },

	    /** Detects browser on mobile devices.
	     * @returns {boolean} True is browser on mobile, false otherwise.
	     */
	    isBrowserOnMobile: function() {
	        return isMobile();
	    },

	    /** Detects browser.
	     * @returns {string} browser name.
	     */
	    getBrowserName: function() {
	        var ua = navigator.userAgent,
	            tem,
	            M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

	        if (/trident/i.test(M[1])) {
	            tem =/\brv[ :]+(\d+)/g.exec(ua) || [];
	            return 'IE';
	        }
	        if (M[1] === 'Chrome') {
	            tem = ua.match(/\bOPR\/(\d+)/);
	            if (tem !== null) {
	                return 'Opera';
	            }
	        }
	        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
	        if ((tem = ua.match(/version\/(\d+)/i)) !== null) {
	            M.splice(1,1,tem[1]);
	        }
	        return M[0];
	    },

	    /** Detects is video type playable for particular browser.
	     * @param {string} mimeType - media type from VAST xml.
	     * @param {string} codec - codec from VAST xml if present.
	     * @returns {boolean} True if playable, false otherwise.
	     */
	    canPlay: function(mimeType, codec) {

	        //VIDLA-139
	        //Edge browser can have error when calling canPlayType method in video element - this is suggested safe way for all browsers reffered by https://developer.microsoft.com/en-us/microsoft-edge/platform/documentation/dev-guide/html5/video/
	        var wrapperOfCanPlayType = function(vid, type, codec) {
	            debug("invoke canPlayType with video(" + vid + ") and type(" + type + ") and codec(" + codec + ")");
	            if (vid && vid.canPlayType) {
	                var result = vid.canPlayType(type + ';codecs="' + codec + '"');
	                debug("result : " + result);
	                return result;
	            } else {
	                debug("result : failed to invoke canPlayType with " + vid);
	                return "";
	            }
	        };

	        var alternativeCodec = null;
	        if (isFlashOnlyType(mimeType.toLowerCase())) {
	            return !isMobile() && hasFlashPlugin();
	        }
	        else if (isHtml5VpaidType(mimeType.toLowerCase())) {
	            return true;		// always allow to play html5 vpaid
	        }
	        else {
	            var type = mimeType.toLowerCase();
	            if (!codec || codec === '') {
	                if (type === 'video/mp4') {
	                    codec = 'avc1.42E01E,mp4a.40.2';
	                    //only test with video codec for alternativeCodec
	                    alternativeCodec = 'avc1.42E01E';//iphone7 + iOS10GM will return "maybe" for the "mp4a.40.2", so alternative codecs should be tested more to provide extra opportunity to be choosen by canPlayType
	                    //vid.canPlayType("video/mp4;codecs=avc1.42E01E,mp4a.40.2");
	                    //iphone 7 + iOS10GM : maybe
	                    //iphone 6 + iOS10GM : probably
	                }
	                else if (type === 'video/webm') {
	                    codec = 'vp8,vorbis';
	                }
	                else if (type === 'video/ogg') {
	                    codec = 'theora,vorbis';
	                }
	                else {
	                    return false;	// unknown video mime type
	                }
	            }
	            var vid = document.createElement('video');
	            //var response = vid.canPlayType(type + ';codecs="' + codec + '"');//VIDLA-139
	            var response = wrapperOfCanPlayType(vid, type, codec);



	            if (response === 'probably') {
	                return true;
	            }
	            if (response === 'maybe') {
	                if (type === 'video/webm') {
	                    return true;
	                }
	                //if alternativeCodec exists, do a test once again to give additoinal opportunity to be tested
	                //if (alternativeCodec && vid.canPlayType(type + ';codecs="' + alternativeCodec + '"') === "probably") {
	                //VIDLA-139
	                if (alternativeCodec && wrapperOfCanPlayType(vid, type, alternativeCodec) === "probably") {
	                    return true;
	                }
	            }
	            return false;
	        }
	    },

	    /** Returns information about device where ad is running.
	     * @returns {string} One of the following: desktop-flash, desktop-no-flash, mobile-Android, mobile-iOS, mobile-unknown.
	     */
	    getPlatformType: function() {
	        if (isMobile()) {
	            if (isAndroid()) {
	                return 'mobile-Android';
	            }
	            if (isIos()) {
	                return 'mobile-iOS';
	            }
	            return 'mobile-unknown';
	        }
	        else {
	            if (hasFlashPlugin()) {
	                return 'desktop-flash';
	            }
	            return 'desktop-no-flash';
	        }
	    }
	};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VAST Parser module.
	 * @module VastParser
	 */

	var VastXMLParserHelper = __webpack_require__(54);

	var APN_CompanionAds = __webpack_require__(55);
	var APN_Icons = __webpack_require__(56);

	var VastModifier = function (parserData, adToken, notifyUrl, contentSource, buyerMemberId, viewabilityConfig, additionalTrackers, creativeId) {

	    var _logger = __webpack_require__(9);
	    var _prefix = 'VAST Parser';

	    var _parserData = parserData;
	    var _adToken = adToken;
	    var _notifyUrl = notifyUrl;
	    var _creativeId = creativeId;
	    var _buyerMemberId = buyerMemberId;
	    var _contentSource = contentSource;
	    var _viewabilityConfig = viewabilityConfig;
		var _additionalTrackers = additionalTrackers;
	    var _helper = new VastXMLParserHelper();

	    function trimXml(strVastXml) {
	        var nPos = strVastXml.indexOf('<');
	        var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
	        nPos = strXml.lastIndexOf('>');
	        if (nPos !== -1) {
	            strXml = strXml.substr(0, nPos + 1);
	        }
	        return strXml;
	    }

	    function prepareDocObject(strVastXml) {
	        var strXml = trimXml(strVastXml);
	        var xmlDoc = null;
	        if (typeof window.DOMParser !== 'undefined') {
	            xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
	            if (xmlDoc.documentElement.nodeName === 'parsererror') {
	                try {
	                    _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
	                }
	                catch (e) {
	                }
	                return null;
	            }
	        }
	        else if (typeof window.ActiveXObject !== 'undefined') {
	            try {
	                xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
	                xmlDoc.loadXML(strXml);
	                if (xmlDoc.parseError.errorCode !== 0) {
	                    _logger.error(_prefix, xmlDoc.parseError);
	                    return null;
	                }
	            }
	            catch (ex) {
	                _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
	                return null;
	            }
	        }
	        else {
	            _logger.error(_prefix, 'Failed to get vast xml parser');
	            return null;
	        }
	        return xmlDoc;
	    }

	    var _xmlDoc = prepareDocObject(parserData.vastXml);

	    function updateVastVersion(vastVersion) {
	        if (_xmlDoc) {
	            var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	            if (vastNode) {
	                var attr = _xmlDoc.createAttribute('version');
	                attr.value = vastVersion;
	                vastNode.setAttributeNode(attr);
	            }
	        }
	    }

	    updateVastVersion(parserData.vastVersion);

	    function appendAttributesToAdNode() {
	        if (_xmlDoc) {
	            var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	            if (vastNode) {
	                var ads = _helper.getSubNodes(vastNode, 'Ad');
	                if (ads && ads.length > 0) {
	                    for (var i = 0; i < ads.length; i++) {
	                        if (_notifyUrl) {
	                            var attr = _xmlDoc.createAttribute('notifyurl');
	                            attr.value = _notifyUrl;
	                            ads[i].setAttributeNode(attr);
	                        }
	                        if (_contentSource && _contentSource === 'rtb') {
	                            var attr2 = _xmlDoc.createAttribute('rtb');
	                            attr2.value = 'true';
	                            ads[i].setAttributeNode(attr2);
	                        }
	                        var attr3 = _xmlDoc.createAttribute('sequence');
	                        attr3.value = _parserData.sequence.toString();
	                        ads[i].setAttributeNode(attr3);
	                        if (_buyerMemberId) {
	                            var attr4 = _xmlDoc.createAttribute('buyerMemberId');
	                            attr4.value = _buyerMemberId;
	                            ads[i].setAttributeNode(attr4);
	                        }
	                        if (_viewabilityConfig) {
	                            var attr5 = _xmlDoc.createAttribute('viewabilityConfig');
	                            attr5.value = _viewabilityConfig;
	                            ads[i].setAttributeNode(attr5);
	                        }
	                        if (_creativeId) {
	                            var attr6 = _xmlDoc.createAttribute('creativeId');
	                            attr6.value = _creativeId;
	                            ads[i].setAttributeNode(attr6);
	                        }
	                    }
	                }
	            }
	        }
	    }

	    appendAttributesToAdNode();

	    function addCdataBlock(parentNode, url) {
	        var cdata = _xmlDoc.createCDATASection(url);
	        parentNode.appendChild(cdata);
	    }

	    var _creativesNode = null;

	    function getLinearNode() {
	        if (_adToken) {
	            var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	            var attr = _xmlDoc.createAttribute('adtoken');
	            attr.value = _adToken;
	            vastNode.setAttributeNode(attr);
	        }

	        var inLine = _helper.getSubNode(_xmlDoc, 'InLine');
	        if (!inLine) {
	            return null;	// VAST xml has no InLine node
	        }

	        var i;
	        var impNode;
	        if (_parserData.extImpressionUrls && typeof _parserData.extImpressionUrls === 'string') {
	            var impTrackers = JSON.parse(_parserData.extImpressionUrls);
	            if (Array.isArray(impTrackers) && impTrackers.length > 0) {
	                for (i = 0; i < impTrackers.length; i++) {
	                    impNode = _xmlDoc.createElement('Impression');
	                    addCdataBlock(impNode, impTrackers[i]);
	                    inLine.appendChild(impNode);
	                }
	            }
	            delete _parserData.extImpressionUrls;
	        }
	    	if (_additionalTrackers && _additionalTrackers.impressions) {
	    		for (i = 0; i < _additionalTrackers.impressions.length; i++) {
	    			if (_additionalTrackers.impressions[i]) {
		            	impNode = _xmlDoc.createElement('Impression');
		            	addCdataBlock(impNode, _additionalTrackers.impressions[i]);
		            	inLine.appendChild(impNode);
	    			}
	    		}
	    	}
	        	
	    	var errNode;
	        if (_parserData.extErrorUrls && typeof _parserData.extErrorUrls === 'string') {
	            var errTrackers = JSON.parse(_parserData.extErrorUrls);
	            if (Array.isArray(errTrackers) && errTrackers.length > 0) {
	                for (i = 0; i < errTrackers.length; i++) {
	                    errNode = _xmlDoc.createElement('Error');
	                    addCdataBlock(errNode, errTrackers[i]);
	                    inLine.appendChild(errNode);
	                }
	            }
	            delete _parserData.extErrorUrls;
	        }
	    	if (_additionalTrackers && _additionalTrackers.errors) {
	    		for (i = 0; i < _additionalTrackers.errors.length; i++) {
	    			if (_additionalTrackers.errors[i]) {
		            	errNode = _xmlDoc.createElement('Error');
		            	addCdataBlock(errNode, _additionalTrackers.errors[i]);
		            	inLine.appendChild(errNode);
	    			}
	    		}
	    	}
	    	
	        if (_parserData.extViewableImpression && typeof _parserData.extViewableImpression === 'string') {
	            var viewableImpressions = JSON.parse(_parserData.extViewableImpression);
	            var viNode = _xmlDoc.createElement('ViewableImpression');
	            if (Array.isArray(viewableImpressions.viewable) && viewableImpressions.viewable.length > 0) {
	                for (i = 0; i < viewableImpressions.viewable.length; i++) {
	                    var viewableNode = _xmlDoc.createElement('Viewable');
	                    addCdataBlock(viewableNode, viewableImpressions.viewable[i]);
	                    viNode.appendChild(viewableNode);
	                }
	            }
	            if (Array.isArray(viewableImpressions.notViewable) && viewableImpressions.notViewable.length > 0) {
	                for (i = 0; i < viewableImpressions.notViewable.length; i++) {
	                    var notViewableNode = _xmlDoc.createElement('NotViewable');
	                    addCdataBlock(notViewableNode, viewableImpressions.notViewable[i]);
	                    viNode.appendChild(notViewableNode);
	                }
	            }
	            if (Array.isArray(viewableImpressions.undeterminated) && viewableImpressions.undeterminated.length > 0) {
	                for (i = 0; i < viewableImpressions.undeterminated.length; i++) {
	                    var undeterminatedNode = _xmlDoc.createElement('ViewUndeterminated');
	                    addCdataBlock(undeterminatedNode, viewableImpressions.undeterminated[i]);
	                    viNode.appendChild(undeterminatedNode);
	                }
	            }
	            inLine.appendChild(viNode);
	            delete _parserData.extViewableImpression;
	        }
	        	
	        var uaParser = __webpack_require__(13);
	        var ua = uaParser();
	        var browser = ua.browser.name.toLowerCase();
	        if (_parserData.extExtensions && typeof _parserData.extExtensions === 'string') {
	            var extensions = _parserData.extExtensions;
	            if (extensions.length > 0) {
	                var extensionsNode = _helper.getSubNode(inLine, 'Extensions');
	                if (!extensionsNode) {
	                    extensionsNode = _xmlDoc.createElement('Extensions');
	                    inLine.appendChild(extensionsNode);
	                    if (browser === 'ie') {
	                    	extensionsNode.textContent = extensions;
	                    }
	                    else {
	                        extensionsNode.innerHTML = extensions;
	                    }
	                }
	                else {
	                    if (browser === 'ie') {
	                    	extensionsNode.textContent = extensionsNode.textContent.toString() + extensions;
	                    }
	                    else {
	                        extensionsNode.innerHTML = extensionsNode.innerHTML.toString() + extensions;
	                    }
	                }
	            }
	            delete _parserData.extExtensions;
	        }

	        _creativesNode = _helper.getSubNode(inLine, 'Creatives');
	        if (!_creativesNode) {
	            _creativesNode = _xmlDoc.createElement('Creatives');
	            inLine.appendChild(_creativesNode);
	        }
	        var linearNode = _helper.getSubNode(_creativesNode, 'Linear');
	        if (!linearNode) {
	            var creativeNode = _xmlDoc.createElement('Creative');
	            _creativesNode.appendChild(creativeNode);
	            linearNode = _xmlDoc.createElement('Linear');
	            creativeNode.appendChild(linearNode);
	        }
	        return linearNode;
	    }

	    function iconAlreadyExist(iconsNode, program) {
	        var icons = _helper.getSubNodes(iconsNode, 'Icon');
	        if (icons && icons.length > 0) {
	            for (var i = 0; i < icons.length; i++) {
	                var programAttr = _helper.getNodeAttributeValue(icons[i], 'program');
	                if (programAttr.toLowerCase() === program.toLowerCase()) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    }

	    function appendTrackings(linearNode) {
	        var i;
	        if (_parserData.extTrackingUrls && typeof _parserData.extTrackingUrls === 'string' &&
	            _parserData.extTrackingUrls.length > 5) {
	            var videoTrackers = JSON.parse(_parserData.extTrackingUrls);
	            var trackersNode = _helper.getSubNode(linearNode, 'TrackingEvents');
	            if (!trackersNode) {
	                trackersNode = _xmlDoc.createElement('TrackingEvents');
	                linearNode.appendChild(trackersNode);
	            }
	            // enumerate video trackers
	            for (var name in videoTrackers) {
	                var urls = videoTrackers[name];
	                for (i = 0; i < urls.length; i++) {
	                    var trackerNode = _xmlDoc.createElement('Tracking');
	                    var attr = _xmlDoc.createAttribute('event');
	                    attr.value = name;
	                    trackerNode.setAttributeNode(attr);
	                    //trackerNode.textContent = urls[i];
	                    addCdataBlock(trackerNode, urls[i]);
	                    trackersNode.appendChild(trackerNode);
	                }
	            }
	            delete _parserData.extTrackingUrls;
	        }

	        var videoClicksNode;
	        if (_parserData.extClickUrls && typeof _parserData.extClickUrls === 'string') {
	            var videoClicks = JSON.parse(_parserData.extClickUrls);
	            if (Array.isArray(videoClicks) && videoClicks.length > 0) {
	                videoClicksNode = _helper.getSubNode(linearNode, 'VideoClicks');
	                if (!videoClicksNode) {
	                    videoClicksNode = _xmlDoc.createElement('TrackingEvents');
	                    linearNode.appendChild(videoClicksNode);
	                }
	                if (!_helper.getSubNode(videoClicksNode, 'ClickThrough')) {
	                    var clickNode = _xmlDoc.createElement('ClickThrough');
	                    //clickNode.textContent = videoClicks[0];
	                    addCdataBlock(clickNode, videoClicks[0]);
	                    videoClicksNode.appendChild(clickNode);
	                }
	            }
	            delete _parserData.extClickUrls;
	        }

	        if (_parserData.extClickTrackingUrls && typeof _parserData.extClickTrackingUrls === 'string') {
	            var clickTrackings = JSON.parse(_parserData.extClickTrackingUrls);
	            if (Array.isArray(clickTrackings) && clickTrackings.length > 0) {
	                videoClicksNode = _helper.getSubNode(linearNode, 'VideoClicks');
	                if (!videoClicksNode) {
	                    videoClicksNode = _xmlDoc.createElement('VideoClicks');
	                    linearNode.appendChild(videoClicksNode);
	                }
	                for (i = 0; i < clickTrackings.length; i++) {
	                    var clickTrackingNode = _xmlDoc.createElement('ClickTracking');
	                    //clickTrackingNode.textContent = clickTrackings[i];
	                    addCdataBlock(clickTrackingNode, clickTrackings[i]);
	                    videoClicksNode.appendChild(clickTrackingNode);
	                }
	            }
	            delete _parserData.extClickTrackingUrls;
	        }

	        if (_parserData.extIcons && typeof _parserData.extIcons === 'string') {
	            var icons = JSON.parse(_parserData.extIcons);
	            if (Array.isArray(icons) && icons.length > 0) {
	                var iconsNode = _helper.getSubNode(linearNode, 'Icons');
	                if (!iconsNode) {
	                    iconsNode = _xmlDoc.createElement('Icons');
	                    linearNode.appendChild(iconsNode);
	                }
	                for (i = 0; i < icons.length; i++) {
	                    // avoid duplicate icons with same program
	                    if (!iconAlreadyExist(iconsNode, icons[i].program)) {
	                        var iconNode = APN_Icons.createIconNode(_xmlDoc, icons[i]);
	                        if (iconNode) {
	                            iconsNode.appendChild(iconNode);
	                        }
	                    }
	                }
	            }
	            delete _parserData.extIcons;
	        }
	    }

	    function appendNewCompanion(companionAdsNode, newCompanion) {
	        // get companions with resources
	        var companionNode, j;
	        var companionAdsObj = {companions: []};
	        APN_CompanionAds.parse(companionAdsObj, companionAdsNode, _helper);
	        var resCompanions = companionAdsObj.companions;
	        if (newCompanion.StaticResource || newCompanion.IFrameResource || newCompanion.HTMLResource) {
	            var sameSize = false;
	            for (j = 0; j < resCompanions.length; j++) {
	                if (newCompanion.width === resCompanions[j].width &&
	                    newCompanion.height === resCompanions[j].height) {
	                    sameSize = true;
	                    break;
	                }
	            }
	            if (!sameSize) {
	                companionNode = APN_CompanionAds.createCompanionNode(_xmlDoc, newCompanion);
	                companionAdsNode.appendChild(companionNode);
	            }
	        }
	        else {
	            // aggregate companion without resorces into companions with resources
	            var needUpdate = false;
	            for (j = 0; j < resCompanions.length; j++) {
	                if (newCompanion.width === resCompanions[j].width && newCompanion.height === resCompanions[j].height) {
	                    if ((newCompanion.id && newCompanion.id === resCompanions[j].id) || (!newCompanion.id)) {
	                        // add click trackings
	                        if (newCompanion.CompanionClickTracking) {
	                            if (!resCompanions[j].CompanionClickTracking) {
	                                resCompanions[j].CompanionClickTracking = [];
	                            }
	                            resCompanions[j].CompanionClickTracking = resCompanions[j].CompanionClickTracking.concat(newCompanion.CompanionClickTracking);
	                        }
	                        // add view trackings
	                        if (newCompanion.TrackingEvents) {
	                            if (!resCompanions[j].TrackingEvents) {
	                                resCompanions[j].TrackingEvents = [];
	                            }
	                            resCompanions[j].TrackingEvents = resCompanions[j].TrackingEvents.concat(newCompanion.TrackingEvents);
	                        }
	                        needUpdate = true;
	                        break;
	                    }
	                }
	            }
	            if (needUpdate) {
	                while (companionAdsNode.firstChild) {
	                    companionAdsNode.removeChild(companionAdsNode.firstChild);
	                }
	                for (var i = 0; i < resCompanions.length; i++) {
	                    companionNode = APN_CompanionAds.createCompanionNode(_xmlDoc, resCompanions[i]);
	                    companionAdsNode.appendChild(companionNode);
	                }
	            }
	        }
	    }

	    function appendCompanions() {
	        if (_parserData.extCompanions && typeof _parserData.extCompanions === 'string') {
	            var companions = JSON.parse(_parserData.extCompanions);
	            if (Array.isArray(companions.companions) && companions.companions.length > 0) {
	                var companionAdsNode = _helper.getSubNode(_creativesNode, 'CompanionAds');
	                if (!companionAdsNode) {
	                    companionAdsNode = _xmlDoc.createElement('CompanionAds');
	                    _creativesNode.appendChild(companionAdsNode);
	                }
	                var attr;
	                if (companions.required !== 'unknown') {
	                    attr = _xmlDoc.createAttribute('required');
	                    attr.value = companions.required;
	                    companionAdsNode.setAttributeNode(attr);
	                }
	                for (var i = 0; i < companions.companions.length; i++) {
	                    appendNewCompanion(companionAdsNode, companions.companions[i]);
	                }
	            }
	        }
	    }

	    this.addTrackers = function () {
	        if (!_xmlDoc) {
	            return '';
	        }
	        var linearNode = getLinearNode();
	        if (!linearNode) {
	            return '';
	        }
	        appendTrackings(linearNode);
	        if (_creativesNode) {
	            appendCompanions();
	        }
	        var strOut;
	        var uaParser = __webpack_require__(13);
	        var ua = uaParser();
	        var browser = ua.browser.name.toLowerCase();
	        if (browser === 'edge') {
	            // VIDLA-683. Edge is loosing nested CDATA during serialization to string.
	            strOut = _xmlDoc.childNodes[0].outerHTML;
	        }
	        else if (browser === 'ie') {
	            // VIDLA-683. IE is loosing nested CDATA during parsing XML string to DOM.
	            // We have to restore nested CDATA for AdParameters if needed.
	            var nodes = _xmlDoc.getElementsByTagName('AdParameters');
	            for (var i = 0; i < nodes.length; i++) {
	                if (nodes[i].textContent.indexOf(']]>') > 0 && nodes[i].textContent.substr(0, 9) !== '<![CDATA[') {
	                    nodes[i].textContent = nodes[i].textContent.replace(/]]>/g, "]]]]><![CDATA[>");
	                    nodes[i].textContent = '<![CDATA[' + nodes[i].textContent + ']]>';
	                }
	            }
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	            strOut = strOut.replace(/&lt;/g, '<');
	            strOut = strOut.replace(/&gt;/g, '>');
	        }
	        else {
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	        }
	        return strOut;
	    };
	};

	module.exports = VastModifier;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VastMerger module.
	 * @module VastParser
	 */

	var VastXMLParserHelper = __webpack_require__(54);

	var VastMerger = function (xmlList) {

	    var _logger = __webpack_require__(9);
	    var _prefix = 'VAST Parser';

	    var _xmls = xmlList;
	    var _helper = new VastXMLParserHelper();

	    function trimXml(strVastXml) {
	        var nPos = strVastXml.indexOf('<');
	        var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
	        nPos = strXml.lastIndexOf('>');
	        if (nPos !== -1) {
	            strXml = strXml.substr(0, nPos + 1);
	        }
	        return strXml;
	    }

	    function prepareDocObject(strVastXml) {
	        var strXml = trimXml(strVastXml);
	        var xmlDoc = null;
	        if (typeof window.DOMParser !== 'undefined') {
	            xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
	            if (xmlDoc.documentElement.nodeName === 'parsererror') {
	                try {
	                    _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
	                }
	                catch (e) {
	                }
	                return null;
	            }
	        }
	        else if (typeof window.ActiveXObject !== 'undefined') {
	            try {
	                xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
	                xmlDoc.loadXML(strXml);
	                if (xmlDoc.parseError.errorCode !== 0) {
	                    _logger.error(_prefix, xmlDoc.parseError);
	                    return null;
	                }
	            }
	            catch (ex) {
	                _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
	                return null;
	            }
	        }
	        else {
	            _logger.error(_prefix, 'Failed to get vast xml parser');
	            return null;
	        }
	        return xmlDoc;
	    }

	    var _xmlDoc = prepareDocObject(_xmls[0]);
	    if (!_xmlDoc) {
	        return;
	    }

	    var _vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	    var attr = _xmlDoc.createAttribute('apn_waterfall');
	    attr.value = true;
	    _vastNode.setAttributeNode(attr);

	    var adNodes = [];
	    for (var i = 0; i < _xmls.length; i++) {
	        var doc = prepareDocObject(_xmls[i]);
	        var vastNode = _helper.getSubNode(doc, 'VAST');
	        var ads = _helper.getSubNodes(vastNode, 'Ad');
	        if (ads && ads.length > 0) {
	            for (var j = 0; j < ads.length; j++) {
	                adNodes.push(ads[j]);
	            }
	        }
	    }

	    adNodes.sort(function (a, b) {
	        return _helper.getNodeAttributeNumberValue(a, 'sequence') - _helper.getNodeAttributeNumberValue(b, 'sequence');
	    });

	    var uaParser = __webpack_require__(13);
	    var ua = uaParser();
	    var browser = ua.browser.name.toLowerCase();
	    
	    if (browser === 'ie') {
	        _vastNode.textContent = '';
	    }
	    else {
	        _vastNode.innerHTML = '';
	    }
	    for (i = 0; i < adNodes.length; i++) {
	        _vastNode.appendChild(adNodes[i]);
	    }

	    this.getVastXml = function () {
	        if (!_xmlDoc) {
	            return '';
	        }
	        var strOut;
	        if (browser === 'edge') {
	            // VIDLA-683. Edge is loosing nested CDATA during serialization to string.
	            strOut = _xmlDoc.childNodes[0].outerHTML;
	        }
	        else if (browser === 'ie') {
	            // VIDLA-683. IE is loosing nested CDATA during parsing XML string to DOM.
	            // We have to restore nested CDATA for AdParameters if needed.
	            var nodes = _xmlDoc.getElementsByTagName('AdParameters');
	            for (var i = 0; i < nodes.length; i++) {
	                if (nodes[i].textContent.indexOf(']]>') > 0 && nodes[i].textContent.substr(0, 9) !== '<![CDATA[') {
	                    nodes[i].textContent = nodes[i].textContent.replace(/]]>/g, "]]]]><![CDATA[>");
	                    nodes[i].textContent = '<![CDATA[' + nodes[i].textContent + ']]>';
	                }
	            }
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	            strOut = strOut.replace(/&lt;/g, '<');
	            strOut = strOut.replace(/&gt;/g, '>');
	        }
	        else {
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	        }
	        return strOut;
	    };
	};

	module.exports = VastMerger;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Tracking Manager module.
	 * @module TrackingManager
	 */

	/**
	 * @description Unified Tracking Event Names
	 * Tracking events will be stored under the following names.
	 * These are the names that should be used when requesting tracking for an event
	 * Names being passed in from parsing or other structures will be mapped to these events.
	 * 	- bid-impression
	 *  - network-request
	 *  - network-response
	 * 	- impression
	 * 	- video-start
	 *  - video-first-quartile
	 *  - video-mid
	 *  - video-third-quartile
	 *  - video-complete
	 *  - ad-click
	 *  - video-pause
	 *  - video-rewind
	 *  - video-resume
	 *  - audio-mute
	 *  - audio-unmute
	 *  - video-fullscreen
	 *  - video-exit-fullscreen
	 *  - creative-view
	 *  - ad-expand
	 *  - ad-collapse
	 *  - user-accept-invitation
	 *  - user-close
	 *  - ad-progress
	 *  - error
	 * If an eventName cannot be mapped (for custom cases), then the name passed in will be used to store the set of video urls.
	 */
	/////////////////////////////////////////
	// VARIABLES
	/////////////////////////////////////////
	// CONSTANTS
	//var ERROR_TYPE_GENERAL = 0;
	var ERROR_TYPE_VAST = 1;
	//var ERROR_TYPE_HTTP = 2;
	var VAST_ERROR_MACRO = "[ERRORCODE]";
	var CACHE_BUSTING_MACRO = "[CACHEBUSTING]";
	var DEFAULT_KEY = "AN_DEFAULT";

	/////////////////////////////////////////
	// VARIABLES
	 var tracker = __webpack_require__(24);
	 var utils = __webpack_require__(23);

	 var prefix = "TM";
	 var trackingEvents = {};


	//////////////////////////////////////////
	// Log methods as following https://corpwiki.appnexus.com/pages/viewpage.action?spaceKey=SSV&title=Client+Side+JS+Browser+Console+Logging+Proposal
	var APN_Logger = __webpack_require__(9);
	// var always = function (message) {
	//     //log level 1
	//     APN_Logger.always(prefix, message);
	// };
	// var error = function (message) {
	//     //log level 2
	//     APN_Logger.error(prefix, message);
	// };
	var warn = function (message) {
	    //log level 3
	    APN_Logger.warn(prefix, message);//for such a case of network related like "url not found"
	};
	var info = function (message) {//for only initial tracking request
	    //log level 4
	    APN_Logger.info(prefix, message);
	};
	var log = function (message) {//for additional tracking request following intial trackings if it's required
	    //log level 5
	    APN_Logger.log(prefix, message);
	};
	// var debug = function (message) {
	//     //log level 6
	//     APN_Logger.debug(prefix, message);
	// };
	var verbose = function (message) {
	    //log level 7
	    APN_Logger.verbose(prefix, message);//for a registration part
	};

	verbose("Tracking Manager Version 1.0.9");




	/////////////////////////////////////////
	// CREATING TRACKING EVENTS DATA STRUCTURE
	// reset the trackingEvents object
	 function initTrackingEventsObject(){
		 trackingEvents = {};
	 }

	 // create a default tracking event object for a particular event
	 // this function assumes that that eventName has been normalized
	 // default setting for reportOnce is true
	 function createTrackingEventObject(eventName, adId){
		 if (!trackingEvents) {
			 trackingEvents = {};
		 }

		 adId = adId || DEFAULT_KEY;

		 if (!trackingEvents[adId]) {
		 	trackingEvents[adId] = {};
		 }

		 var obj = {};
		 obj.isImpression = false;
		 obj.reportOnce = true;
		 obj.reported = false;
		 obj.urls = [];

		 trackingEvents[adId][eventName] = obj;
		 verbose("tracking data created, adId=" + adId + ", event=" + eventName);
	 }

	 // normalize all tracking events into standard names
	 // unknown names will use the eventName passed in
	 function normalizeTrackingEventName(eventName) {
		 var answer = eventName;

		 // map eventnames found in VAST tags or appnexus structure to standard tracking event name
		 switch (eventName) {
		 case "impressionUrls" :
			 answer = "impression";
			 break;

		 case "clickTrackingUrls" :
		 case "click" :
			 answer = "ad-click";
			 break;

		 case "errorUrls" :
			 //answer = "vast-error";
			 answer = "error";
			 break;

		 case "imp_tracking_url" :
			 answer = "bid-impression";
			 break;

		 case "init_cb" :
			 answer = "ad-request";
			 break;

		 case "result_cb" :
			 answer = "ad-response";
			 break;

		 case "start" :
			 answer = "video-start";
			 break;

		 case "firstQuartile" :
			 answer = "video-first-quartile";
			 break;

		 case "midpoint" :
			 answer = "video-mid";
			 break;

		 case "thirdQuartile" :
			 answer = "video-third-quartile";
			 break;

		 case "thirdQuartile" :
			 answer = "video-third-quartile";
			 break;

		 case "complete" :
			 answer = "video-complete";
			 break;

		 case "unmute" :
			 answer = "audio-unmute";
			 break;

	     case "mute" :
	         answer = "audio-mute";
	         break;

		 case "pause" :
			 answer = "video-pause";
			 break;

		 case "rewind" :
			 answer = "rewind";
			 break;

		 case "resume" :
			 answer = "video-resume";
			 break;


		 case "fullscreen" :
			 answer = "video-fullscreen";
			 break;

		 case "exitFullscreen" :
			 answer = "video-exit-fullscreen";
			 break;

		 case "creativeView" :
			 answer = "creative-view";
			 break;

		 case "expand" :
			 answer = "ad-expand";
			 break;

		 case "collapse" :
			 answer = "ad-collapse";
			 break;

		 case "acceptInvitation" :
			 answer = "user-accept-invitation";
			 break;

		 case "close" :
			 answer = "user-close";
			 break;

		 case "progress" :
			 answer = "ad-progress";
			 break;

	     case "skip" :
	         answer = "video-skip";
	         break;
		 }

		 return answer;
	 }

	/////////////////////////////////////////
	// ADDING TRACKING EVENTS TO TRACKING MANAGER
	 // adds a tracking url for the specified eventName
	 // if an event object for that eventName does not already exist,
	 // it will be created with default values
	 function addTrackingUrlForEvent(eventName, trackingUrl, adId) {
		 adId = adId || DEFAULT_KEY;

		 eventName = normalizeTrackingEventName(eventName);

		 if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
			 createTrackingEventObject(eventName, adId);
		 }

		 trackingEvents[adId][eventName].urls.push(trackingUrl);
		 verbose("Tracking added, adId=" + adId + ", event=" + eventName + ", url=" + trackingUrl);
	 }

	 // create a mediation event name for a specific network
	 // this will be the key where the tracking urls are stored
	 // as well as the key for looking up the tracking urls for a mediation event for a network
	 function createMediationEventName(eventName, networkName) {
		 var answer = "";

		 if (utils.isNotEmpty(eventName) && utils.isNotEmpty(networkName)) {
			 eventName = normalizeTrackingEventName(eventName);
			 answer = eventName + "_" + networkName;
		 }

		 return answer;
	 }

	 ////////////////////////////////////////////////////////////////////////////
	// CONTROLLING TRACKING
	//returns true if the event name is considered an impression tracker
	//otherwise returns false
	function isImpressionEvent(eventName, adId) {
		adId = adId || DEFAULT_KEY;

		var answer = false;

		var eventObj = trackingEvents[adId][eventName];
		if (eventObj && eventObj.hasOwnProperty("isImpression")) {
			answer = (eventObj.isImpression === true);
		}

		return answer;
	}

	// sets property to control whether an event can be reported only once
	// if it is a mediation tracking event - you need to also pass in the networkName
	// and the eventName will be a combination of the event name and the network name
	 // true = report only once, false = may be reported multiple times
	 function setReportOnlyOnce(eventName, restricted, adId) {
	 	adId = adId || DEFAULT_KEY;

		 if (utils.isNotEmpty(eventName)) {
			 if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
				 createTrackingEventObject(eventName, adId);
			 }

			 var eventObj = trackingEvents[adId][eventName];
			 eventObj.reportOnce = restricted;
			 verbose("setting report once, adId=" + adId + ", event=" + eventName + ", setting=" + restricted);
		 }
	 }

	// sets property to control whether an event can be reported only once
	// if it is a mediation tracking event - you need to also pass in the networkName
	// and the eventName will be a combination of the event name and the network name
	 // true = report only once, false = may be reported multiple times
	 function setReportOnlyOnceMediation(eventName, restricted, networkName, adId) {
		 adId = adId || DEFAULT_KEY;

		 if (utils.isNotEmpty(eventName)) {
			 // normalize the event name, adding in the network name if specified
			 eventName = normalizeTrackingEventName(eventName);
			 if (utils.isNotEmpty(networkName)) {
				 eventName = createMediationEventName(eventName, networkName);
			 }

			 if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
				 createTrackingEventObject(eventName, adId);
			 }

			 var eventObj = trackingEvents[adId][eventName];
			 eventObj.reportOnce = restricted;
			 verbose("setting report once, adId=" + adId + ", event=" + eventName + ", setting=" + restricted);
		 }
	 }

	 // resets the reported flag back to false for all the events with the exception of impression events
	 // if the resetImpression arg is true, then impression events will also be reset to false
	function resetTrackingEventReported(resetImpression, adId) {
		adId = adId || DEFAULT_KEY;

		if (trackingEvents && trackingEvents.hasOwnProperty(adId)) {
			var adObject = trackingEvents[adId];
			for (var eventName in adObject) {
				if (isImpressionEvent(eventName, adId) && !resetImpression) {
					verbose("reset history skipping impression event=" + eventName + ", adId=" + adId);
				}
				else {
					 var eventObj = trackingEvents[adId][eventName];
					 eventObj.reported = false;
					 verbose("reset history for adId= " + adId + ", event=" + eventName);
				}
			}
		}
	}

	// marks an event as an impression type
	// used when resetting reporting history -
	// you may or may not want to also reset impression events
	function setEventAsImpression(eventName, isImpression, adId){
		adId = adId || DEFAULT_KEY;

		 eventName = normalizeTrackingEventName(eventName);

		 if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
			 createTrackingEventObject(eventName, adId);
		 }

		 trackingEvents[adId][eventName].isImpression = isImpression;
	}


	/////////////////////////////////////////
	// EXECUTING TRACKING EVENTS

	//passes the url over to the module that will actually hit the tracking pixel
	//defined for a particular event
	function hitTrackingUrl(url, eventName){
	    log("requesting tracking for " + eventName + ", url=" + url);
	    tracker.trackPixel(url, eventName);
	}

	//add a param value at the end of a url as a query string value
	//e.g. ?error=123
	//if the url already contains some query string parameters
	//meaning that the ? is already there
	//append the parameter using the &
	function addParameterAsQueryString(url, paramValue) {
	    var answer = url;

	    var delimiter = "?";
	    if (url.indexOf("?") > -1) {
	        delimiter = "&";
	    }

	    answer = url + delimiter + paramValue;

	    return answer;
	}


	//replace the macro with the param value
	//this function assumes that you have already checked to make sure
	//that the macro is present
	//if the macro is not found, then the url will be unchanged
	function addParameterAsMacro(url, paramValue, macroValue) {
	    var answer = url;

	    if (url.indexOf(macroValue) > -1){
	        answer = url.replace(macroValue, paramValue);
	    }

	    return answer;
	}



	//adds a specified parameter to a stored tracking url
	//param is an object which may contain two fields:
	//		- value (required) = value should be added to the tracking url
	//		= macro (optional) = macro which will be replaced with the value
	//if a macro is not specified or if the macro is not found in the url,
	//then the param will be added at the end as a query string parameter
	function addParameterToTrackingUrl(url, param) {
	    if (param) {
	        // get the value to add to the url
	        var val = param.value;
	        val = (val && typeof(val) === "number") ? val.toString() : val;//work-around of a bug of isNotEmpty function, isNotEmpty could return false if parameter is integrer and it will be a consequence to not perform the macro substition for VID-2120
	        if (utils.isNotEmpty(val)) {
	            // check to see if there if a macro
	            var macro = param.macro;
	            if (utils.isNotEmpty(macro)) {
	                // check to see if the url contains the macro
	                // if so add the parameter as a macro replacement
	                if (url.indexOf(macro) > -1) {
	                    url = addParameterAsMacro(url, val, macro);
	                }
	            }
	            else {
	                // a macro was not specified
	                // so add the parameter as a query string parameter
	                url = addParameterAsQueryString(url, val);
	            }
	        }
	    }

	    return url;
	}

	//Reports all tracking urls associated with a particular tracking event name
	function trackEvent(eventName, param, adId){
		adId = adId || DEFAULT_KEY;

		var fnd = false;
		if (trackingEvents.hasOwnProperty(adId) && trackingEvents[adId].hasOwnProperty(eventName)) {
			var eventObj = trackingEvents[adId][eventName];
			if (eventObj){
				// check to make sure that the event may be reported more than once
				// or, if it can be reported only once, that it has not already been reported
				if ((eventObj.reportOnce) && (eventObj.reported)) {
					info("Cannot report event - event has already been reported: " + eventName + " for adId=" + adId);
					fnd = true;
				}
				else {
					var urls = eventObj.urls;
					if (urls) {
						eventObj.reported = true;
						for (var i = 0; i < urls.length; i++) {
							var url = urls[i];
							if (utils.isNotEmpty(url)) {
								fnd = true;
								if (param) {
									url = addParameterToTrackingUrl(url, param);
								}
								// VIDLA-1062 Add Cache busting query string parameter to trackers firing more than once.
								// VIDLA-984 - make sure to resolve [CACHEBUSTING] macro if present
								var rndNum = '' + Math.floor(Math.random() * 10000000);
							    if (url.indexOf(CACHE_BUSTING_MACRO) > -1){
									url = addParameterToTrackingUrl(url, {macro: CACHE_BUSTING_MACRO, value: rndNum});
							    }
							    else {
									// VIDLA-2146 Do not add cachebuster to end of Click Trackers.
									// Doing so can create issues if the click tracker urls use redirect mechanism or rely on other params/macros.
									// TODO- Fix VIDLA-2149 Rely on the No cache response headers of the first tracker fired.
									if (!eventObj.reportOnce && eventName !== 'ad-click') {
										var rnd = 'apn_rnd=' + rndNum;
										url = addParameterToTrackingUrl(url, {value:rnd});
									}
							    }
								hitTrackingUrl(url, eventName);
							}
						}
					}
				}
			}
		}

		if (!fnd) {
			warn("No tracking urls found for adId=" + adId + ", event = " + eventName);
		}
	}

	//Get all tracking urls associated with a particular tracking event name
	function getParamTrackingUrls(eventName, param, adId){
		adId = adId || DEFAULT_KEY;

		var retUrls = [];
		if (trackingEvents.hasOwnProperty(adId) && trackingEvents[adId].hasOwnProperty(eventName)) {
			var eventObj = trackingEvents[adId][eventName];
			if (eventObj){
				var urls = eventObj.urls;
				if (urls) {
					for (var i = 0; i < urls.length; i++) {
						var url = urls[i];
						if (utils.isNotEmpty(url)) {
							if (param) {
								url = addParameterToTrackingUrl(url, param);
							}
							retUrls.push(url);
						}
					}
				}
			}
		}
		return retUrls;
	}

	//Get all tracking urls associated with a particular tracking event name
	function getUrlsForEvent(eventName, adId){
		adId = adId || DEFAULT_KEY;

		var trackingUrls = [];
		var fnd = false;
		if (trackingEvents.hasOwnProperty(adId) && trackingEvents[adId].hasOwnProperty(eventName)) {
			var eventObj = trackingEvents[adId][eventName];
			if (eventObj){
				var urls = eventObj.urls;
				if (urls) {
					for (var i = 0; i < urls.length; i++) {
						var url = urls[i];
						if (utils.isNotEmpty(url)) {
							fnd = true;
							trackingUrls.push(url);
						}
					}
				}
			}
		}

		if (!fnd) {
			warn("No tracking urls found for adId=" + adId + ", event = " + eventName);
		}
		return trackingUrls;
	}


	/////////////////////////////////////////
	// ADDING PARAMETERS TO TRACKING URLS
	// creates a param object for mediation events
	// each field in the object will be a key and the value of the field will be the value
	// the resulting string
	function createMediationTrackingParams (params){
	    verbose("Creating params for mediation tracking from obj: " + utils.objectToString(params));
	    var answer = {};
	    var paramString = "";

	    if (params) {
	        for (var key in params) {
	            if (params[key] !== null && params[key] !== 'undefined'){
	                if (paramString.length > 0) {
	                    paramString += "&";
	                }
	                var str = key + "=" + params[key];
	                paramString += str;
	            }
	        }
	    }

	    answer.value = paramString;
	    return answer;
	}


	// reports all tracking urls for a specific event and network
	// params will be added ot the tracking urls
	function trackMediationEvent(eventName, networkName, params, adId) {
		var ename =  createMediationEventName(eventName, networkName);
		var paramObj = createMediationTrackingParams(params);
		trackEvent(ename, paramObj, adId);
	}






	// create an event name for a progress event for a particular offset
	function createProgressEventName(offset) {
		return ("progress>" + offset);
	}
	/////////////////////////////////////////////////////////////////
	// CLEAN UP
	function removeEventsForKey(key, adId) {
		adId = adId || DEFAULT_KEY;
		if (trackingEvents && trackingEvents.hasOwnProperty(adId)) {
			var eventList = trackingEvents[adId];
			for (var field in eventList) {
				// data.substring(0, input.length) === input
				if (field.indexOf(key) > -1) {
					delete trackingEvents[adId][field];
					verbose("Removing event: " + field + " for key=" + key + " and adId=" + adId);
				}
			}
			if (trackingEvents[adId].length === 0) {
				delete trackingEvents[adId];
			}
		}
	}

	function removeEvents(adId) {
		adId = adId || DEFAULT_KEY;
		if (trackingEvents && trackingEvents.hasOwnProperty(adId)) {
			var eventList = trackingEvents[adId];
			delete trackingEvents[adId];
			for (var event in eventList) {
				verbose("Removing event: " + event + " for adId=" + adId);
			}
		}
	}

	////////////////////////////////////////////////////////////////
	// EXPORTS
	module.exports = {
		/**
		 * Resets all the data structures for the Tracking Manager
		 * @param(array) unrestrictedEventsList - an array of eventNames for events that may be reported more than once
		 * 	by default, tracking events are reported only once
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		init : function(unrestrictedEventsList, adId){
			removeEvents(adId);
			if (unrestrictedEventsList) {
				for (var i = 0; i < unrestrictedEventsList.length; i++) {
					setReportOnlyOnce(unrestrictedEventsList[i], false, adId);
				}
			}
		},

		/**
		 * Add a tracking event to the set of tracking events
		 * being managed by the Tracking Manager
		 * @param (string) eventName - name of the event to be tracked
		 * @param (string) trackingUrl - tracking url to "hit" whenever this event is reported
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		addTrackingEvent: function(eventName, trackingUrl, adId){
			addTrackingUrlForEvent(eventName, trackingUrl, adId);
		},

		/**
		 * Merge the tracking events provided in the argument with
		 * the set of tracking events being managed by the Tracking Manager
		 * @param (json) trackingObject - object which contains a set of tracking events with associated tracking urls
		 * 		- each field name in trackingObject is the name of a tracking event (e.g. "video-start")
		 * 		- the value of each field is an array of tracking urls - even if there is only one tracking url
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		addTrackingEvents: function(trackingObject, adId){
			if (trackingObject) {
				for (var eventName in trackingObject) {
					var urls = trackingObject[eventName];
					if (utils.isNotEmpty(urls)){
						for (var i = 0; i < urls.length; i++) {
							addTrackingUrlForEvent(eventName, urls[i], adId);
						}
					}
				}
			}
		},

		/**
		 * Add tracking events that are used when running client side mediation
		 * each url is network dependent so the event name stored in Tracking Manager
		 * will contain both the event name and the network name
		 * @param (string) eventName = name of tracking event that will be requested
		 * 		- eventName will be normalized to a standardized name if needed
		 * @param (string) networkName = identifier which uniquely identifies a network to hit for mediation
		 * 		- initially this name will be internally generated
		 * @param (string) trackingUrl = tracking url to "hit" whenever this event is reported
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		addMediationTrackingEvent : function(eventName, networkName, trackingUrl, adId) {
			var ename = createMediationEventName(eventName, networkName);
			verbose("creating event name for adId=" + (adId ? adId : DEFAULT_KEY) + ", event=" + eventName + ", networkName=" + networkName + " =>" + ename);
			addTrackingUrlForEvent(ename, trackingUrl, adId);
		},

		/**
		 * adds a tracking url for a progress event for a particular offset (as defined in the VAST xml)
		 * @param (string) offset = some time when this event should be reported
		 * 	- this can be a elapsed time in HH:MM:SS or HH:MM:SS.mmm or a %
		 * @param (string) trackingUrl = url that is to be hit when this event is to be tracked
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		addProgressTrackingEvent : function (offset, trackingUrl, adId) {
			var eventName = createProgressEventName(offset);
			addTrackingUrlForEvent(eventName, trackingUrl, adId);
		},

		/**
		 * Marks an event as an "impression event" - this is used when resetting the reporting history
		 * @param (string) eventName = name of event - this name will be normalized
		 * @param (boolean) isImpression
		 * 		- true = event is an impression event
		 * 		- false = event is NOT an impression event
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		markAsImpressionEvent : function(eventName, isImpression, adId) {
			verbose("marking event as impression: " + eventName + ", adId=" + (adId ? adId : DEFAULT_KEY) + ", value=" + isImpression);
			setEventAsImpression(eventName, isImpression, adId);
		},

		/**
		 * Marks an event as an "impression event" - this is used when resetting the reporting history
		 * @param (string) eventName = name of event - this name will be normalized
		 * @param (boolean) isImpression
		 * 		- true = event is an impression event
		 * 		- false = event is NOT an impression event
		 * @param (string) networkName = name of a network that is involved in mediation events
		 * 		- use only when the event is conisdered to be a mediation event
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		markAsMediationImpressionEvent : function(eventName, isImpression, networkName, adId) {
			if (utils.isNotEmpty(networkName)) {
				eventName = createMediationEventName(eventName, networkName);
			}

			verbose("marking event as impression: " + eventName + ", adId=" + (adId ? adId : DEFAULT_KEY) + ", value=" + isImpression);
			setEventAsImpression(eventName, isImpression, adId);
		},

		/**
		 * Mark a tracking event as being "report-only-once", meaning that if the event has already been
		 * reported, do not report it again.
		 * There will be another method that will reset all the reporting settings, if needed
		 * @param (string) eventName - the name of the tracking event
		 * @param (boolean) restricted - indicates whether the event may only be reported once
		 * 		- true = event will only be reported once (default)
		 * 		- false = event will be reported every time it is requested
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		reportOnlyOnce : function(eventName, restricted, adId) {
			setReportOnlyOnce(eventName, restricted, adId);
		},

		/**
		 * Mark a tracking event as being "report-only-once", meaning that if the event has already been
		 * reported, do not report it again.
		 * There will be another method that will reset all the reporting settings, if needed
		 * @param (string) eventName - the name of the tracking event
		 * @param (boolean) restricted - indicates whether the event may only be reported once
		 * 		- true = event will only be reported once (default)
		 * 		- false = event will be reported every time it is requested
		 * @param (string) networkName = name of network
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		reportMediationOnlyOnce : function(eventName, restricted, networkName, adId) {
			setReportOnlyOnceMediation(eventName, restricted, networkName, adId);
		},

		/**
		 * Clears tracking reporting history - used in the case where the ad is being re-played
		 * and the ad unit wants to be able to re-report video events and other events
		 * or the player is being used for another ad
		 * @param (boolean) resetImpression - indicates whether impression events should also be reset
		 * 		- true = also reset the impression events
		 * 		- false = do NOT reset the impression events
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		resetTrackingHistory : function(resetImpression, adId) {
			resetTrackingEventReported(resetImpression, adId);
		},

		/**
		 * request tracking for a tracking event
		 * @param(string) eventName - name of the event being tracked
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		requestTracking : function(eventName, adId){
			info("tracking requested for " + eventName + ", adId=" + (adId ? adId : DEFAULT_KEY));
			trackEvent(eventName, null, adId);
		},

		/**
		 * get tracking URLs for a tracking event
		 * @param(string) eventName - name of the event being tracked
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		getTrackingUrls : function(eventName, adId){
			info("URLs requested for " + eventName + ", adId=" + (adId ? adId : DEFAULT_KEY));
			return getUrlsForEvent(eventName, adId);
		},

		/**
		 * request tracking for a tracking event that requires a parameter (such as error reporting)
		 * @param (string) eventName - name of event being tracked
		 * @param (object) param - object containing information about parameters to add to tracking url
		 * 		- value = field in object identifying the value to add to the tracking url
		 * 		- macro = (optional) field in object identifying a macro present in the tracking url where to place
		 * 					the value
		 * 		- if macro field is missing or empty, then the param will be added at the end as a query string param
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		requestParamTracking : function(eventName, param, adId){

			info("tracking requested for " + eventName + " with param=" + utils.objectToString(param) + ", adId=" + (adId ? adId : DEFAULT_KEY));
			trackEvent(eventName, param, adId);
		},

		/**
		 * request tracking for a mediation related event for a specific network
		 * parameters may also be optionally passed in to add to the tracking url
		 * @param (string) eventName = name of the event being tracked
		 * @param (string) networkName = name identifying the network for whom the event is being tracked
		 * @param (json) params = optional object containing parameters that need to be added to the tracking url
		 * 		- will contain fields which will be used to create query string params that will
		 * 			be added to the end of a mediation tracking url
		 * 			example: reason: 0, latency_type: 1, latency: 1500}
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		requestMediationTracking : function(eventName, networkName, params, adId) {
			info("tracking requested for mediation event: " + eventName + ", network=" + networkName + " , params=" + utils.objectToString(params) + ", adId=" + (adId ? adId : DEFAULT_KEY));
			trackMediationEvent(eventName, networkName, params, adId);
		},

		/**
		 * request tracking for an error condition
		 * @param (integer) errorCode = error code identifying the error condition
		 * @param (integer) errorType = identifies the type of error (this controls how this is reported); can be one of the following
		 * 		0 = general appnexus error
		 * 		1 = vast-error (one of the error codes specified in the VAST spec)
		 * 		2 = http error
		 * @param (string) errorDescription = string used primarily for logging the error
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		requestErrorTracking : function (errorCode, errorType, errorDescription, adId) {
			info("error reported: " + errorCode + ", type=" + errorType + ", desc=" + errorDescription, + ", adId=" + (adId ? adId : DEFAULT_KEY));
			var paramObj = {};
			var eventName = "";

			// check to see if it is a VAST error (which requires macro substitution)
			switch (errorType) {
			case ERROR_TYPE_VAST :
				paramObj.macro = VAST_ERROR_MACRO;
				paramObj.value = errorCode;
				//eventName = "vast-error";	// note we have to collapse vast errors and errors into errors because impbus also returns error tracking url
				eventName = "error";
				break;

			default :
				paramObj.value = ("error=" + errorCode);
				eventName = "error";
			}

			this.requestParamTracking(eventName, paramObj, adId);
		},

		/**
		 * request tracking urls for an error condition
		 * @param (integer) errorCode = error code identifying the error condition
		 * @param (integer) errorType = identifies the type of error (this controls how this is reported); can be one of the following
		 * 		0 = general appnexus error
		 * 		1 = vast-error (one of the error codes specified in the VAST spec)
		 * 		2 = http error
		 * @param (string) errorDescription = string used primarily for logging the error
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 * @return(array) - array of error urls
		 */
		requestErrorTrackingUrls : function (errorCode, errorType, errorDescription, adId) {
			var paramObj = {};
			var eventName = "";

			// check to see if it is a VAST error (which requires macro substitution)
			switch (errorType) {
			case ERROR_TYPE_VAST :
				paramObj.macro = VAST_ERROR_MACRO;
				paramObj.value = errorCode;
				eventName = "error";
				break;

			default :
				paramObj.value = ("error=" + errorCode);
				eventName = "error";
			}

			return getParamTrackingUrls(eventName, paramObj, adId);
		},

		/**
		 * request tracking for a progress event for a particular offset
		 * @param (string) offset = some time when this event should be reported
		 * 	- this can be a elapsed time in HH:MM:SS or HH:MM:SS.mmm or a %
		 *  - NOTE: the offset being passed must be exact same format as how the event was created
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		requestProgressTracking : function (offset, adId) {
			var eventName = createProgressEventName(offset);

			info("Tracking requested for progress event, adId=" + (adId ? adId : DEFAULT_KEY) + ", offset=" + offset);
			this.requestTracking(eventName, adId);
		},

		/**
		 * clears all the events from the tracking events data structure with adId=adId (or default)
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 *      - if an adId is passes into the function, will remove all events associated with the adId
		 *      - if no adId is passed, will remove all events associated with the default adId
		 */
		removeEvents : function(adId) {
			removeEvents(adId);
		},

		/**
		 * clears all the events from the tracking events data structure with an eventName starting with 'key'
		 * optional adId parameter to search through ads associated with a particular adId
		 * @param (string) key = string to identify a set of tracking data for a particular set
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		removeEventsForKey : function(key, adId) {
			removeEventsForKey(key, adId);
		},

		/**
		 * clears all events from tracking events data structure
		 * only use if you are sure you want to remove all events regardless of adId
		 */
		removeAllEvents : function() {
			initTrackingEventsObject();
		}
	};

/***/ })
/******/ ]);